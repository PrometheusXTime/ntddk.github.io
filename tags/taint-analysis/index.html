<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tag: taint analysis | 一生あとで読んでろ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="一生あとで読んでろ">
<meta property="og:url" content="http://ntddk.github.io/tags/taint-analysis/index.html">
<meta property="og:site_name" content="一生あとで読んでろ">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一生あとで読んでろ">
<meta name="twitter:description">
<meta name="twitter:creator" content="@ntddk">
  
    <link rel="alternative" href="/atom.xml" title="一生あとで読んでろ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一生あとで読んでろ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技術ブログ</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-autoprobe" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/12/11/autoprobe/">マルウェアの動的解析に基づくC&amp;Cサーバの探索</a>
  

      </header>
    
    <time class="article-date" datetime="2015-12-11T03:00:00.000Z" itemprop="datePublished">12-11-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>　本稿は<a href="http://www.adventar.org/calendars/784" target="_blank" rel="external">情報セキュリティ系論文紹介 Advent Calendar 2015</a>の11日目である．</p>
<h1 id="TL;DR:">TL;DR:</h1><p>　テイント解析（taint analysis）やプログラムスライシング（program slicing），記号的実行（symbolic execution）やファジング（fuzzing）といったバイナリ解析技術を総動員して，マルウェアが通信するC&amp;Cサーバのフィンガープリントを<strong>C&amp;Cサーバと通信せずとも</strong>生成する手法—AUTOPROBE[1]を紹介する．</p>
<h1 id="背景">背景</h1><p>　マルウェアによるサイバー犯罪はC&amp;Cサーバやコンフィグファイルの配布元，二次検体の配布元など様々な悪性サーバ（malicious server）からなるインフラによって支えられている．攻撃者はこれらの悪性サーバを頻繁に閉鎖・移転させて対策から逃れようとする．とりわけ攻撃者の命令を送信してマルウェアの動作を決定するC&amp;Cサーバはその後の攻撃の起点となるため早期発見が望ましい．したがって不審なサーバがC&amp;Cサーバかどうか判定するフィンガープリントが必要となる．<br>　しかしながら従来のフィンガープリント生成手法にはC&amp;Cサーバとの長期的な通信を前提としている[2]，サーバとして動作するマルウェアを前提としている[3]といった問題点があった．</p>
<h1 id="問題定義">問題定義</h1><p>　あるマルウェアのファミリFに属する検体Pを入力として受け取り，Fが用いるC&amp;Cサーバのフィンガープリントφを出力することがAUTOPROBEの目的である．C&amp;Cサーバ側のコードは参照できず，マルウェアの検体はシンボル情報やソースコードを含んでいなくともよい．またマルウェアは複数のリクエストをC&amp;Cサーバに送信するものとする．</p>
<h1 id="提案手法">提案手法</h1><p>　あるサーバにマルウェアと同様のリクエストを送って，マルウェアがコマンドとして解釈できるレスポンスが返ってきたら，そのサーバは疑いようもなくC&amp;Cサーバである—AUTOPROBEの鍵となる発想は至極単純だ．<br>　AUTOPROBEは検体の命令・API・システムコールの実行を—おそらくQEMUによって—トレースし，リクエストを生成する処理とレスポンスをハンドルする処理をそれぞれマルウェアから抽出する．つづいて前者によって不審なサーバに対するリクエストを生成し，後者によってレスポンスをハンドルする．レスポンスハンドリングの可否をもってフィンガープリントとするから，その処理の抽出さえできれば不審なサーバがC&amp;Cサーバかどうか判定するまで実際のC&amp;Cサーバと通信する必要はない—でもどうやって？</p>
<h2 id="リクエスト生成">リクエスト生成</h2><p>　マルウェアの多くは時間や擬似乱数，OS情報などの環境依存の値によって動作を変更する．たとえばWin32/LoadMoney.AFはレジストリキーの有無によって送信するリクエストを変更する：</p>
<p><img src="/image/autoprobe/win32_loadmoney.af.png" width="50%" height="50%"></p>
<p>　不審なサーバがC&amp;Cサーバかどうか判定するためには攻撃者の期待するリクエストをより多く送信しより多くレスポンスを得たい．そこでAUTOPROBEは以下のアルゴリズムにしたがって複数の実行トレースを得る．これは条件分岐の度に直前のシステムコールを参照する，ある種の深さ優先探索として実装される：</p>
<p><img src="/image/autoprobe/request.png" width="50%" height="50%"></p>
<p>　さらにAUTOPROBEはトレースをスライスし，システムコールの結果に依存する値を環境依存の値として決定論的な値・定数と区別する．ここで環境依存の値を書き換えれば攻撃者の期待するリクエストを送信できるようになる．また環境依存の値に影響するシステムコールの戻り値に時間，IPアドレス，擬似乱数，OS情報など200種類のラベルを設定しているとのことだ．</p>
<h2 id="レスポンスハンドリング">レスポンスハンドリング</h2><p>　生成したリクエストをC&amp;Cサーバに送信してレスポンスを得たら，AUTOPROBEはレスポンスの各バイトを記号値として扱い，実行トレースから検体の分岐制約を充足する解およびスライスθ<sub>1</sub>を得る．ここで探索の終了条件は<code>closesocket</code>や<code>exitprocess</code>に到達した場合，データを受信してから50個の条件分岐にわたってそのデータを参照するものが存在しない場合である．つづいてレスポンスとして正しく解釈できない値を検体に与え，実行トレースから分岐制約を充足する解およびスライスθ<sub>2</sub>を得る．ここでηは以下の式によって得られる実行経路の類似度である：</p>
<p><img src="/image/autoprobe/slice.png" width="50%" height="50%"></p>
<p>　bnとfnはそれぞれ各スライスに含まれるユニークなコードブロックとシステムコールの数を示す．AUTOPROBEはηが閾値10を下回ればレスポンスを正しく解釈していない実行経路とみなしてスライスを破棄し，上回れば別々のハンドラであるとしてそれぞれの分岐制約をフィンガープリントとして保持する．たとえばこんなふうに：</p>
<p><img src="/image/autoprobe/equations.png" width="50%" height="50%"></p>
<p>　C&amp;Cサーバからレスポンスを得られなければ，AUTOPROBEは記号的実行とファジング，フラグレジスタの書き換えによる強制実行（forced execution）を併用してレスポンスに依存する実行経路を探索する：</p>
<p><img src="/image/autoprobe/response.png" width="55%" height="55%"></p>
<p>　このファジングでは検体にランダム値を与えるが，検体が用いるアルゴリズムがHTTPなど既知のものであればエラーメッセージのハンドラを起点に探索する．<br>　AUTOPROBEはこのように探索したレスポンスのハンドラをフィンガープリントとするが，期待されるレスポンスが得られずさきほどのアルゴリズムによって探索した場合は以下のようにC&amp;Cサーバの尤もらしさを算出する：</p>
<p><img src="/image/autoprobe/score.png" width="50%" height="50%"></p>
<h1 id="評価">評価</h1><p>　論文ではふたつのデータセットを用いてAUTOPROBEの性能を評価している．ひとつはSality, ZeroAccess, Ramnit, Bamital, Taidoorを含む37ファミリ10亜種計370検体．もうひとつはネットワーク通信の特徴量に基づいてフィンガープリントを生成する既存研究—CYBERPROBE[2]で用いられた19ファミリ． “which have been kindly provided to us by the authors of CYBERPROBE”って書いてるけどAUTOPROBEと同じメンバーじゃねえか．<br>　検体の実行時間は5分．</p>
<h2 id="リクエスト生成-1">リクエスト生成</h2><p>　まずはリクエストの生成から．可能であればC&amp;Cサーバとの接続をともなうがAlexaトップ10,000サイトは除外している．ここでAUTOPROBEはC&amp;Cサーバに接続せずとも検体のバイナリを分析してCYBERPROBEと同様の結果を得ている：</p>
<p><img src="/image/autoprobe/request_eval.png"></p>
<p>　AUTOPROBEはふたつのデータセットに含まれる56ファミリのトレースから105のリクエストを生成した．生成にかかった時間は平均13.2分．リクエストはすべてHTTPであったとのこと．</p>
<h2 id="レスポンスハンドリング-1">レスポンスハンドリング</h2><p>　生成したリクエストのうち76件がC&amp;Cサーバからのレスポンスを引き出した．さらにAUTOPROBEは<code>HTTP 200</code>レスポンスコードを含む同数のランダムなレスポンスを生成し，検体に与えた．これはレスポンスハンドリングの可否によって検体の異なる挙動を確認したいためだ．結果として76件のテストケース中71件（93％）で検体は異なる挙動を示した—<strong>期待される受信データを得たマルウェアは一般に10以上のシステムコールと50以上のコードブロックを実行する</strong>．残りの5件はC&amp;Cサーバではなかった．つまりAUTOPROBEはマルウェアの通信先がC&amp;Cサーバかどうか正しく判定できている．</p>
<h2 id="ケーススタディ">ケーススタディ</h2><p>　たとえばBamitalのリクエストはファイル名・<code>GetVersionEx</code>によって得たOS情報・DGA(domain generation algorithm)によって生成したホスト名を含んでいた．AUTOPROBEはこれらの値が依存するシステムコールを得ている：</p>
<p><img src="/image/autoprobe/bamital.png" width="50%" height="50%"></p>
<p>　C&amp;Cサーバと接続せずとも<code>HTTP/1.1 200 OK</code>を与えればBamitalのハンドラは分析できるとのこと．<br>　また標的型攻撃に用いられるTaidoorのリクエストは<code>GetAdaptersInfo</code>によって得たMACアドレスに依存する値を含んでいた．これによってTaidoorのC&amp;Cサーバは感染端末のみで動作するレスポンスを送信していたようだ．<br>　ドライブバイダウンロード検体であるSalityのC&amp;Cサーバは<code>spm/s_tasks.php</code>, <code>logos_s.gif</code>, <code>231013_d.exe</code>というファイルをレスポンスに含んでいた．AUTOPROBEはこれらのファイルの存在するサーバをSalityのC&amp;Cサーバとみなす．などなど．</p>
<h2 id="限定的な探索">限定的な探索</h2><p>　Malware Domain Listに含まれる9,500アドレスの近傍/24サブネット・2.6Mアドレスのスキャン結果：</p>
<p><img src="/image/autoprobe/localized.png" width="60%" height="60%"></p>
<p>　VirusTotal, Malware Domain List, そしてURLQueryに発見されていないC&amp;Cサーバを特定できている．</p>
<h2 id="インターネット全体の探索">インターネット全体の探索</h2><p>　ここではBGPからインターネット全体をスキャンし，7,100万ものHTTPサーバを発見している：</p>
<p><img src="/image/autoprobe/horizontal.png"></p>
<p>　このうちマルウェア3ファミリのC&amp;Cサーバをどれだけ発見できるかCYBERPROBEと比較した結果：</p>
<p><img src="/image/autoprobe/comparison.png"></p>
<p>　CYBERPROBEが40件のC&amp;Cサーバを特定しているのにたいしてAUTOPROBEは54件のC&amp;Cサーバを特定している．<br>　高度化するマルウェアが通信内容を難読化・秘匿する傾向にあることを鑑みると，CYBERPROBEのようにネットワーク通信の特徴量を用いる手法よりもAUTOPROBEのようにバイナリ解析を応用した手法こそ吟味されるべきだろう．</p>
<h1 id="感想">感想</h1><p>　AUTOPROBEは折しも私が昨年度のインターンシップでほとんど同じようなテーマに取り組んでいたとき発表された．テイント解析のソースを受信データではなくシステムコールの結果に設定することで，リクエストのセマンティクスを復元しようとするAUTOPROBEの発想は野心的であり，さまざまなバイナリ解析技術を結集して未知のC&amp;Cサーバを発見する手際は鮮やかというほかない．<br>　私は来年書くことになる卒業論文のテーマとして，インターネット接続のない閉環境におけるマルウェアの分析に本手法を応用できないか検討している．Ryzhykら[4]はデバイスドライバと環境（デバイスおよびOS）との相互作用を有限オートマトンを用いて表現し，デバイスドライバを半自動的に合成する手法を提案している．問題領域は異なるがこうした手法も検討したい．</p>
<h1 id="用語解説">用語解説</h1><ul>
<li>テイント解析<ul>
<li>任意のデータに設定したタグをルールにしたがって伝搬させることで，データ間の依存関係を分析する手法</li>
</ul>
</li>
<li>プログラムスライシング<ul>
<li>任意のデータに依存する処理部分をプログラムから抽出する手法</li>
</ul>
</li>
<li>記号的実行<ul>
<li>プログラムの分岐条件を充足論理問題とし，制約を充足する解を得る手法</li>
</ul>
</li>
<li>ファジング<ul>
<li>開発者が意図しない入力を自動生成してプログラムに与えることで脆弱性を顕在化させる手法</li>
</ul>
</li>
</ul>
<h1 id="参考文献">参考文献</h1><ul>
<li>[1]Zhaoyan Xu, Antonio Nappa, Robert Baykov, Guangliang Yang, Juan Caballero, and Guofei Gu, “<a href="http://www.cs.wm.edu/~ksun/csci780-f14/papers/AutoProbe-CCS14.pdf" target="_blank" rel="external">AUTOPROBE: Towards Automatic Active Malicious Server Probing Using Dynamic Binary Analysis[PDF]</a>,” In Proc. of the 21st ACM Conference on Computer and Communications Security (CCS’14), 2014.</li>
<li>[2]Antonio Nappa, Zhaoyan Xu, M. Zubair Rafique, Juan Caballero, and Guofei Gu, “<a href="http://faculty.cs.tamu.edu/guofei/paper/CyberProbe_NDSS14.pdf" target="_blank" rel="external">Cyberprobe: Towards Internet-Scale Active Detection of Malicious Servers[PDF]</a>,” In Network and Distributed System Security Symposium (NDSS’14), 2014.</li>
<li>[3]Zhaoyan Xu, Lingfeng Chen, Guofei Gu, and Christopher Kruegel, “<a href="http://dl.acm.org/citation.cfm?id=2382257" target="_blank" rel="external">Peerpress: Utilizing Enemies’ P2P Strength against Them</a>,” In ACM Conference on Computer and Communications Security (CCS’12), 2012.</li>
<li>[4]Leonid Ryzhyk, Adam Walker, John Keys, Alexander Legg, Arun Raghunath, Michael Stumm, and Mona Vij, “<a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/ryzhyk" target="_blank" rel="external">User-Guided Device Driver Synthesis</a>,” In Proc. of the 11th USENIX Conference on Operating Systems Design and Implementation (OSDI’14), 2014.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/12/11/autoprobe/" data-id="cii1a7ypb001eswos5zgvyhav" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-automated-malware-analysis-using-decaf-in-seccamp15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/08/16/automated-malware-analysis-using-decaf-in-seccamp15/">DECAFによるマルウェア自動解析</a>
  

      </header>
    
    <time class="article-date" datetime="2015-08-16T09:00:00.000Z" itemprop="datePublished">08-16-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>2015.08.11~15にわたって開催された<a href="https://www.ipa.go.jp/jinzai/camp/2015/zenkoku2015.html" target="_blank" rel="external">セキュリティ・キャンプ全国大会 2015</a>に解析トラックの講師として参加した．講義では「仮想化技術を用いてマルウェア解析」と題して，QEMUをベースに開発が行われている<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="external">DECAF</a>という解析プラットフォームを用いて演習を行った．</p>
<h1 id="講義資料">講義資料</h1><script async class="speakerdeck-embed" data-id="11c7632b9b844e199ac966e4494a1dd2" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<h1 id="講義内容">講義内容</h1><p>演習では実際のマルウェアに用いられている解析妨害機能を備えたサンプルプログラムを扱った．素のDECAFには解析妨害機能への対策が施されていない．そこで，受講者にはDECAFのプラグインを拡張し，対策手法を実装して頂いた．<br>演習で用いたプログラムはGitHub上で公開している．</p>
<ul>
<li>解析妨害機能を備えたサンプルプログラム<ul>
<li><a href="https://github.com/ntddk/blue" target="_blank" rel="external">ntddk/blue</a></li>
</ul>
</li>
<li>DECAFプラグインのひな形<ul>
<li><a href="https://github.com/ntddk/geteip" target="_blank" rel="external">ntddk/geteip</a></li>
</ul>
</li>
</ul>
<p>ひな形にある通り，IsDebuggerPresent()をフックするDECAFプラグインは以下のように書ける．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> DECAF_Handle isdebuggerpresent_handle = DECAF_NULL_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> call_stack[<span class="number">1</span>]; <span class="comment">//paramters and return address</span></span><br><span class="line">        DECAF_Handle hook_handle;</span><br><span class="line">&#125; IsDebuggerP<span class="keyword">resent_hook_context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * BOOL IsDebuggerPresent(VOID);</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_ret</span><span class="params">(<span class="keyword">void</span> *param)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span> *)param;</span><br><span class="line">        hookapi_remove_hook(ctx-&gt;hook_handle);</span><br><span class="line">        DECAF_printf(<span class="string">"EIP = %08x, EAX = %d\n"</span>, cpu_single_env-&gt;eip, cpu_single_env-&gt;regs[R_EAX]);</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_call</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        DECAF_printf(<span class="string">"IsDebuggerPresent "</span>);</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(IsDebuggerP<span class="keyword">resent_hook_context_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!ctx) <span class="keyword">return</span>;</span><br><span class="line">        DECAF_read_mem(NULL, cpu_single_env-&gt;regs[R_ESP], <span class="number">4</span>, ctx-&gt;call_stack);</span><br><span class="line">        ctx-&gt;hook_handle = hookapi_hook_return(ctx-&gt;call_stack[<span class="number">0</span>], IsDebuggerPresent_ret, ctx, <span class="keyword">sizeof</span>(*ctx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">geteip_loadmainmodule_callback</span><span class="params">(VMI_Callback_Params* params)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(params-&gt;cp.name,targetname) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                DECAF_printf(<span class="string">"Process %s you spcecified starts \n"</span>, params-&gt;cp.name);</span><br><span class="line">                target_cr3 = params-&gt;cp.cr3;</span><br><span class="line">                isdebuggerpresent_handle = hookapi_hook_function_byname(<span class="string">"kernel32.dll"</span>, <span class="string">"IsDebuggerPresent"</span>, <span class="number">1</span>, target_cr3, IsDebuggerPresent_call, NULL, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在のプロセスがデバッガのコンテキストで実行されていない場合，IsDebuggerPresent()は0を返す．ここで，IsDebuggerPresent()の戻り値を0にするには，モジュール（この場合はkernel32.dll）から戻る段階でeaxを書き換えてやればよい．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_ret</span><span class="params">(<span class="keyword">void</span> *param)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span> *)param;</span><br><span class="line">        hookapi_remove_hook(ctx-&gt;hook_handle);</span><br><span class="line">        cpu_single_env-&gt;regs[R_EAX] = <span class="number">0</span>; <span class="comment">// 追加</span></span><br><span class="line">        DECAF_printf(<span class="string">"EIP = %08x, EAX = %d\n"</span>, cpu_single_env-&gt;eip, cpu_single_env-&gt;regs[R_EAX]);</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このようにDECAFのプラグインを書くことで，ゲストOSに解析用のエージェントを挿入することなくAPIの戻り値を書き換えることができる．<br>APIの引数を書き換えたい場合はモジュールに入る段階でコンテキスト構造体の<code>call_stack[]</code>を書き換えてやればよい．</p>
<h1 id="おわりに">おわりに</h1><p>受講者にサンドボックス開発の楽しさと難しさを実感してもらえたなら，講師として冥利に尽きる．<br>サンプルプログラムには4種類の解析妨害機能を実装しており，APIフックで対処できるのはうち前半2つだけとなっている．限られた演習時間の制約上，3つ目以降の解析妨害機能を回避できた受講者はいなかった．解析トラックリーダーの岩村さんから，受講者の2割がギリギリ解けないような問題を作るようにと仰せつかっていたが，やや意地悪な問題設定だったと思う．<br>なお，今回は拙作のサンプルを用いたが，より多くの解析妨害機能を備えたOSSに<a href="https://github.com/a0rtega/pafish" target="_blank" rel="external">pafish</a>がある．pafishはBackdoor.Win32.Agent.dkbp(MD5: de1af0e97e94859d372be7fcf3a5daa5)など一部のマルウェアに流用されている．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/08/16/automated-malware-analysis-using-decaf-in-seccamp15/" data-id="cii1a7ypb001hswos37rvbs17" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pin-to-pemu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/04/03/pin-to-pemu/">PinからPEMUへ</a>
  

      </header>
    
    <time class="article-date" datetime="2015-04-03T11:45:00.000Z" itemprop="datePublished">04-03-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Dynamic_Binary_Instrumentation">Dynamic Binary Instrumentation</h1><p>Dynamic Binary Instrumentation(DBI)とは，実行中のプログラムにコードを挿入する技術である．<br>その目的は，プログラムの性能評価であったり，アーキテクチャのシミュレーションであったり，プログラムのデバッグであったり，プログラムのsheparding（ポリシを用いたセキュリティ制限）であったり，プログラムの最適化であったり，テイント解析などのデータフロー解析であったり，リバースエンジニアリングであったり，マルウェア解析であったり，……と多岐にわたっている．<br>デバッガとDBIを区別することは難しく，ニュアンスの問題になってしまうが，DBIはより「挿入するコードがプログラマブルであること」を重視している．また，instrumentation（名詞）/instrument（動詞）という語は，コードの挿入を通してプログラムの情報を取得したり，プログラムを制御したりといったニュアンスを含んでいる．<br>DBIのメリットとして，言語に依存しないこと，古いソフトウェアに対しても適用できること，再コンパイルの必要がないこと，動的に生成されるコードを扱うことができること，実行中のプロセスにアタッチできることが挙げられる．</p>
<h1 id="Pin">Pin</h1><p>Intelによって開発されている<a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool" target="_blank" rel="external">Pin</a>は，DBIフレームワークの中でも最も成功している一つであり，そのAPIの数は450種類を越える．<br>Pinにおけるinstrumentationの手法は，コードの実行時にinstrumentするjust-in-time Instrumentation(JITI)と，イメージ（実行ファイルや共有ライブラリ，構造体）のロード時にinstrumentするahead-of-time-insturumentation(AOTI)の二種類に大別される．<br>これらのinstrumentにあたって，Pinは解析対象のプログラムにpinvm.dllを挿入する．</p>
<h2 id="JITI">JITI</h2><p>JIITは以下の三種類を単位として行うことができる．</p>
<h3 id="Instruction_Level">Instruction Level</h3><p>第一に，最も低い粒度として，命令単位のinstrumentationがサポートされている．<br>これは，<code>INS_AddInstrumentFunction</code>のコールバックとして実現される．関連するAPIは，Pin 2.1.3の時点で142種類存在する．</p>
<h3 id="Basic_Block_Level(BBL)">Basic Block Level(BBL)</h3><p>第二に，Basic Block(BB)単位のinstrumentationがサポートされている．<br>ここでのBBとは，一つの入口と一つの出口を持ち，内部に分岐を含まない命令列のことであり，コンパイラ最適化におけるそれと同義である．Pinでは，<code>BBL_InsHead</code>や<code>BBL_InsTail</code>，<code>BBL_Next</code>や<code>BBL_Prev</code>といった関数を用いてBBの有向グラフを操作することができる．一方で<code>BBL_AddInstrumentationFunction</code>のコールバックは<strong>存在しない</strong>．関連するAPIは，Pin 2.1.3の時点で14種類存在する．</p>
<h3 id="Trace_Level">Trace Level</h3><p>第三に，Trace単位のinstrumentationがサポートされている．<br>Traceとは，Pin独自の単位であり，分岐命令を入り口とし，無条件分岐（<code>jmp</code>, <code>call</code>, <code>ret</code>など）を出口とする命令列のことである．つまり，Traceは<strong>複数のBBを含みうる</strong>．これは，<code>TRACE_AddInstrumentFunction</code>のコールバックとして実現される．関連するAPIは，Pin 2.1.3の時点で14種類存在する．<br>Pinでは，objdumpなどと同様に線型分析法によってバイナリを逆アセンブルし，Traceを取得する．ここで，JITIに用いるVMをトラップすることなく別のTraceに分岐を行うための<a href="http://www.cs.virginia.edu/kim/courses/cs851/papers/luk05pin.pdf" target="_blank" rel="external">trace-linking optimization[PDF]</a>が行われる．そのため，Trace単位のinstrumentationが命令単位のinstrumentationよりも高速になる場合がある．</p>
<h2 id="AOTI">AOTI</h2><p>AOTIは以下の二種類を単位として行うことができる．</p>
<h3 id="IMG_instrumentation">IMG instrumentation</h3><p>第一に，IMG単位のinstrumentationがサポートされている．<br>IMGは，特定の実行ファイルないし共有ライブラリ，構造体に相当する単位である．これは，<code>IMG_AddInstrumentFunction</code> APIによって実現される．また，IMGのセクション(SEC)についてもinstrumentを行うことができる．関連するAPIは，IMGについて27種類，SECについて16種類が存在する．</p>
<h3 id="RTN_instrumentation">RTN instrumentation</h3><p>第二に，RTN単位のinstrumentationがサポートされている．<br>RTNとは関数(Routine)に相当する単位である．これは，<code>RTN_AddInstrumentFunction</code> APIによって実現される．関連するAPIは，Pin 2.1.3の時点で39種類存在する．</p>
<h2 id="Transparency">Transparency</h2><p>このように様々な機能を備えるPinだが，マルウェア解析においてはどれほど有用なのだろうか．<br>Pinのinstrumentationは，素朴なDLLインジェクションによって成り立っており，Anti-Debuggingについては考えられていない．そのためPinは，親プロセス，引数，ロードされるpinvm.dll, エクスポート関数である<code>CharmVersionC</code>, <code>ZwAllocateVirtualMemory</code>の実行権限，<code>KiUserApcDispatcher</code>, <code>KiUserCallbackDispatcher</code>, <code>KiUserExceptionDispatcher</code>, <code>LdrInitializeThunk</code>のインラインフック，命令のパターン，セクション名，<code>FSTENV</code>命令，<code>FSAVE</code>命令，<code>FXSAVE</code>命令，……といった様々な要素から検出される危険性を孕んでいる．<br>これらは，<a href="http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=view&amp;type=tool&amp;name=eXait" target="_blank" rel="external">eXait</a>を用いてテストできる．なお，筆者の環境では<code>int2e</code>/<code>SYSENTER</code>についてfalse positiveが発生した．<br>Pinを検出するマルウェアの存在は寡聞にして知らないが，Pinをマルウェア解析に用いるのであれば，現状の構造は不適切である．<br>Anti-Debuggingのイタチごっこから脱するためには，エージェントをゲストOSに挿入するin-VMではなく，エージェントをゲストOSに挿入しないout-of-VMな解析環境でなければならない．</p>
<h1 id="QEMU">QEMU</h1><p>さらにPinにはカーネルへのinstrumentationが不可能であるという欠点が存在する．<br>翻って<a href="https://github.com/qemu/qemu" target="_blank" rel="external">QEMU</a>は，フルシステムエミュレーションを行うため，アーキテクチャに依存することなくカーネルへのinstrumentationを行うことができる．しかしながら，QEMUのソースコードは難解であり，PinのようにユーザーフレンドリーなAPIが提供されていない．QEMUはC言語によるメタプログラミングとオブジェクト指向の良質なサンプルであるとも言えるが，できることなら避けて通りたい道である．</p>
<h1 id="TEMU">TEMU</h1><p>QEMUにテイント解析機能を搭載し，これまで多くの研究で用いられてきた<a href="http://bitblaze.cs.berkeley.edu/temu.html" target="_blank" rel="external">TEMU</a>は，QEMUのソースコードを理解するための労力を削減することに成功した（と，後述するPEMUの論文にすら書かれている）が，APIの充実度はPinに劣っている．また，カーネルモジュールをゲストOSに挿入する必要があり，マルウェアから検出される可能性があること，いまや時代遅れのQEMU 0.9.1をベースとしていることから，現代的なマルウェア解析環境の候補からは外れつつある．<br>後継の<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="external">DECAF</a>はQEMU 1.0.0をベースとしており，カーネルモジュールを必要としないものの，APIの充実度はTEMUと変わらない．</p>
<h1 id="PEMU">PEMU</h1><p>こうした流れを汲んで開発されたのが，VEE’15にて新たに発表された<a href="https://github.com/utds3lab/pemu" target="_blank" rel="external">PEMU</a>である．嬉しい事にオープンソースとして提供されている．<br>Pinはin-VMであり，マルウェアの解析やカーネルへのinstrumentationに適さない．QEMUやTEMUはout-of-VMだが，Pinほど充実したAPIを用いることができない．そこでPEMUは，両者の利点と欠点を踏まえた上で，以下の四点を目的として開発された．</p>
<ol>
<li>Rich APIs<ul>
<li>Pinの既存APIをそのまま流用できること</li>
</ul>
</li>
<li>Cross-OS<ul>
<li>WindowsとLinuxをサポート</li>
</ul>
</li>
<li>Strong Isolation<ul>
<li>ゲストOSのRing 3やRing 0ではなく，out-of-VM(Ring -1)から監視(VM Introspection)を行うこと</li>
</ul>
</li>
<li>VM Introspection<ul>
<li>ゲストOSのプロセスやカーネルのセマンティクス情報を取得するAPIを提供すること</li>
</ul>
</li>
</ol>
<p>これらを達成するため，PEMUはQEMUの動的バイナリ変換器Tiny Code Generator(TCG)に手を加えてPin APIのサポートを追加した．</p>
<h2 id="Instrumentation_Engine">Instrumentation Engine</h2><p>さて，PEMUにおけるinstrumentationはどのようになっているのだろうか．<br>問題となるのは，QEMUとPinとの差異である．QEMUは命令とBB単位でしかinstrumentできず，PinにおけるTrace単位をサポートしていない．また，PEMUのベースとなっているQEMU 1.5.3では，BBの数が640までと制限されている．<br>そこで，PEMUではBBとTraceを対応付けるTRACE Constructorと，PinのAPIを通じてinstrumentするCode Injectorが導入された．</p>
<h3 id="TRACE_Constructor">TRACE Constructor</h3><p>TRACE Constructorは，複数のBBを組み合わせてTraceの単位に抽象化するものである．<br>まずXED2ライブラリを用いて，ゲストの実行前にQEMUでBBの先頭から条件分岐命令まで逆アセンブルを行う(<code>/target-i386/PEMU/DISAS.c</code>)．スワップされたか，ロードされていない命令については，ページフォルトを通じて取得する．さらに，コードを挿入する命令の位置をglobal hooking point hash-table(HPHT)にキャッシュする(<code>/target-i386/PEMU/hashTable.c</code>)．<br>ここにおけるアルゴリズムは以下のようになっている．</p>
<p><img src="/image/pemu_algorithm.png"></p>
<p>まず，Trace単位の開始アドレスであるPCの度にXED2を呼び出し，PCをTPCという保存領域に保存する．次に，全命令を逆アセンブルし，命令単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．さらに，無条件分岐の度にBBとTraceを対応付け，BB単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．そして，新しいBBを割り当て，次のTrace単位が始まるアドレスを探す．Trace単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．そして，さらなるTraceを逆アセンブルしていくといった仕組みになる．</p>
<h3 id="Code_Injector">Code Injector</h3><p>TraceとBBの対応が取れた後は，QEMUのTCGが提供する<code>tcg_gen_helper</code>を用いてHPHTを参照し，instrumentを行えばよい（<code>/target-i386/PEMU/pemu_hook_helper.c</code>）．<br>IMGやSEC単位のinstrumentは<code>malloc</code>などの引数を確認する（セマンティクス情報を復元する）ことで実現している．<br>全体像は以下のようになる．</p>
<p><img src="/image/pemu_engine.png"></p>
<h2 id="Introspection_Engine">Introspection Engine</h2><p>PEMUでは，Page Global Directory(PGD)とCR3レジスタの対応を用いてプロセスの識別を行う(<code>target-i386/PEMU/pemu_helper.h</code>)．ここでは，プロセス作成時に発生するCR3レジスタへの<code>MOV</code>を検出して利用する．終了したプロセスのCR3は再利用されるため，プロセスの終了を検出する必要があるが，これは<code>exit</code> syscallを監視することで実現できる．スレッドは，kernel stack pointerのマスクから識別する．<br>ゲストとのセマンティックギャップの解決にあたっては，一時的にゲストを停止してシステムコールを挿入する手法を用いる．<code>PEMU_</code>というprefixでsyscallに相当するAPIが提供され，<code>getpid</code>, <code>gettimeofday</code>などゲストOSの情報を取得するためのAPI 28種類と，<code>open</code>, <code>fstat</code>, <code>lseek</code>などゲストOSを操作するためのAPI 15種を用いることができる．これらは都度レジスタコンテキストの退避と復元を伴って実行される．</p>
<h2 id="評価">評価</h2><p>論文での性能評価では，32-bit Ubuntu 12.04(Linux kernel 3.0.0-31-generic-pae)をホストとし，Intel Core i7, メモリ8GBのマシンが用いられた．速度の評価には32-bit Ubuntu 11.04(Linux kernel 2.6.38-8-generic)がゲストとして用いられた．<br>その結果として，PEMUではQEMUよりも4.33倍，Pinよりも83.61倍のオーバーヘッドが生じることが明らかになっている．</p>
<p><img src="/image/pemu_performance.png"></p>
<p>また，eXaitを用いた検出テストのため，Windows XP 32bitがゲストとして用いられた．論文ではeXaitの17手法全てがPinを検出した一方で，いずれの手法もPEMUを検出することができなかった．</p>
<h2 id="関連研究">関連研究</h2><p>PEMUがQEMUにPin APIのサポートを追加したのに対して，<a href="http://dl.acm.org/citation.cfm?id=1254830" target="_blank" rel="external">PinOS</a>はXenにPin APIのサポートを追加した．だがPinOSのinstrumentationは貧弱であり，セマンティクス情報を取得するAPIが提供されていない．また，解析ルーチンがカーネルや解析対象からアクセスできるため，isolationとして不十分である．<br>また，PinOS以外にカーネルへのinstrumentationをサポートしている<a href="https://github.com/DynamoRIO/drk" target="_blank" rel="external">DRK</a>は，LKMとして実装されているため，in-VMな手法に留まっている．</p>
<h1 id="おわりに">おわりに</h1><p>こうして，Pin APIを用いてout-of-VMにマルウェアを解析するための道標が示された．<br>今後のPEMUを用いた研究に期待したい，と他人事のように言っている場合ではなく，そろそろ論文を書かなければ．</p>
<h1 id="補足">補足</h1><p>PEMUは新しいといえどQEMU 1.5.3をベースとしており，やがてはQEMU 0.9.1をベースとしているTEMUのように技術的負債となるだろう．<br>そこで，PEMUを<a href="https://github.com/ntddk/pemu" target="_blank" rel="external">forkし</a>，<a href="https://github.com/ntddk/pemu/commit/af5bf0b7a3efcbb7c4b21abbfba0da02f034f95a" target="_blank" rel="external">QEMU 1.5.3からQEMU 2.2.1にアップデートを試みた</a>．が，QEMU 2.2.1に至るまで<code>cpu_single_env</code>変数が廃止されたことと，謎のコンパイルエラーが発生することから頓挫中である．そのうち何とかする．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi and Kim Hazelwood,<br>“<a href="http://www.cs.virginia.edu/kim/courses/cs851/papers/luk05pin.pdf" target="_blank" rel="external">Pin: building customized program analysis tools with dynamic instrumentation[PDF]</a>,”<br>In Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation, PLDI’05, pp. 190–200, 2005.</li>
<li>Francisco Falcón, Nahuel Riva,<br>“<a href="http://recon.cx/2012/schedule/events/216.en.html" target="_blank" rel="external">Dynamic Binary Instrumentation Frameworks: I know you’re there spying on me</a>,”<br>RECon 2012.</li>
<li>Junyuan Zeng, Yangchun Fu, and Zhiqiang Lin,<br>“<a href="http://dl.acm.org/citation.cfm?id=2731201" target="_blank" rel="external">PEMU: A Pin Highly Compatible Out-of-VM Dynamic Binary Instrumentation Framework</a>,”<br>In Proceedings of the 11th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments, pp. 147-160, VEE’15, 2015.</li>
<li>Prashanth P. Bungale, Chi-Keung Luk,<br>“<a href="http://dl.acm.org/citation.cfm?id=1254830" target="_blank" rel="external">PinOS: a programmable framework for whole-system dynamic instrumentation</a>,”<br>In Proceedings of the 3rd international conference on Virtual execution environments, VEE’07, pp. 137-147, 2007.</li>
<li>Peter Feiner, Angela Demke, and Ashvin Goel,<br>“<a href="http://dl.acm.org/citation.cfm?id=2150992" target="_blank" rel="external">Comprehensive Kernel Instrumentation via Dynamic Binary Translation</a>,”<br>In Proceedings of the 17th international conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS’12, pp. 135-146, 2012.</li>
<li>Yangchun Fu, Junyuan Zeng, and Zhiqiang Lin,<br>“<a href="https://www.usenix.org/conference/atc14/technical-sessions/presentation/fu" target="_blank" rel="external">HYPERSHELL: A Practical Hypervisor Layer Guest OS Shell for Automated In-VM Management</a>,”<br>In Proceedings of the 2014 USENIX conference on USENIX Annual Technical Conference, USENIX ATC’14, pp. 85-96, 2014.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/04/03/pin-to-pemu/" data-id="cii1a7ypb0016swos22a0cylz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-v2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/09/v2e/">マルウェア解析におけるRecord and Replayの設計</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-09T09:00:00.000Z" itemprop="datePublished">12-09-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>“という論文を通して，Record and Replayを用いた解析環境の設計を学ぶ．</p>
<h1 id="著者">著者</h1><p>この論文のラストオーサーであるYinはSyracuse Universityの助教である．彼はテイント解析の第一人者として知られ，現在は<a href="https://code.google.com/p/decaf-platform/" target="_blank" rel="external">DECAF</a>の開発を主導している．またBitBlaze ProjectのDawn Songや，マルウェア解析の大御所であるChristopher Kruegelと過去に共著を出している．<br>ファーストオーサーのYanは提案手法をAndroidに適用し，2013年に博士論文を著している．Android向けの拡張にあたっては，DECAFのサブプロジェクトであるDroidScopeを用いているようだ．</p>
<h1 id="Record_and_Replay">Record and Replay</h1><p>あるいはLogging and Replay, Lockstep, 順序再演法，最小情報トレースなどと呼ばれるこれらは，仮想マシンモニタ上のイベントを記録し，再生するための技術である．乱暴に言うとhistoryからdockerfileやvagrantfileを作成し，deployするようなものだ．<br>一般にステートマシンにおける命令の出力は，内部状態から一意に与えられる．そこで，ある環境の初期状態と入力のみを記録(Record)し，同じ環境を別の環境の上に再生(Raplay)するといった試みがなされてきた．実マシンにおいては，時刻や割り込みなどの非決定性とその記録の困難性からRecord and Replayは不可能であるとされる．だが，仮想マシンモニタの世界ではこれらの問題をある程度無視できる．実際，VMware Workstationなどにこの機能は実装されている．<br>本論文では，マルウェア解析に求められるサンドボックスの特性を加味したRecord and Replayについて論じられている．かつて大居さん(<a href="https://twitter.com/a4lg" target="_blank" rel="external">@a4lg</a>)が研究されていた内容に近い．</p>
<h1 id="背景">背景</h1><p>マルウェアを解析するためのサンドボックスは検出不可能(transparent)であり，なおかつ拡張可能であるべきだ．<br>いかに仮想マシンモニタの存在を隠蔽しようと，Timing Attackなどが成り立つ以上，transparentなサンドボックスを実現することは不可能である．しかし，Intel VTなどハードウェア仮想化技術を用いることで，ほぼtransparentな環境を作り出すことは可能である．例えば，<a href="http://ether.gtisc.gatech.edu/" target="_blank" rel="external">Ether</a>は命令・システムコール単位の解析機能を備えているが，Xenをベースに高いtransparent性を実現している．<br>だが，ハードウェア仮想化技術に依存した解析環境には拡張性の点で問題がある．特に，instrumentationによる詳細な解析が不可能であるという点は，大きな痛手である．<br>他方，QEMUなどのソフトウェアエミュレーションは動的バイナリ変換を用いることでDBI(dynamic binary instrumentation)と解析効率の向上を実現している．しかし，transparentなサンドボックスには至れない．<br>QEMUの動的バイナリ変換はバイナリをコードブロック単位で変換し，softmmuからTLBを参照してアドレス変換を行うというものだ．<br>そしてその性質から，以下のような自己書き換えコードによって検出されうる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm&#123;&#10;&#9;xor eax, eax&#10;&#9;mov edi, target&#10;&#9;mov esi, copy_insn&#10;&#9;mov ecx, 3&#10;&#10;target:&#10;&#9;rep movsw&#9;&#9;// f3 66 a5&#10;&#9;jmp qemu_found&#9;&#9;// eb XX&#10;&#9;nop&#9;&#9;&#9;// 90&#10;&#10;non_qemu:&#10;&#9;...&#10;&#10;qemu_found:&#10;&#9;...&#10;&#10;copy_insn:&#10;&#9;_emit 0xeb&#9;&#9;// eb&#10;&#9;_emit 0x01&#9;&#9;// 01&#10;&#9;_emit 0x90&#9;&#9;// 90&#10;&#9;_emit 0xeb&#10;&#9;_emit 0x01&#10;&#9;_emit 0x90&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>実マシンでは，<code>ecx*word=6</code>バイトが1回で書き換わるが，QEMUの動的バイナリ変換では2バイトずつ3回で書き換わる．そのため，1回目の書き換えで<code>0xeb 0x01 0xa5</code>すなわち<code>jmp +01</code>になってしまい，<code>qemu_found</code>にジャンプしてしまう．<br>その他には，ページ境界を越えてブロックの変換が行われた場合にページフォルトが発生してしまうことも考えられるし，ブロック境界でのみ割り込みが行われる，CPUサイクルの消費が著しいといった実マシンとの相違点もある．<br>さらに問題なのが，フラグの遅延評価だ．例えば，<code>cmp</code>と<code>jz</code>の組み合わせなどの条件分岐は，EFLAGSを更新する．だが，QEMUにおいては<code>cmp</code>が実行される段階でEFLAGSの計算は行われない．実際に計算されるのは<code>jz</code>の実行時，それも分岐を決定するためのZFのみが計算される．この設計はエミュレーションの高速化に寄与しているが，もちろん検出に用いることが可能だ．<br>当然ながら命令のエミュレーション自体にも限界がある．SIMDさえ厳しいのだ，システム管理モードやIntel TXTなんてものは考えたくないだろう．<br>このように，QEMUによるエミュレーションが検出される余地は枚挙に暇がない．<br>なお，解析環境検出をテーマとした最近の研究では，第2回システム系論文輪読会で<a href="http://ntddk.github.io/barecloud/">紹介した</a>BareCloudや忠鉢さん(<a href="https://twitter.com/yuzuhara" target="_blank" rel="external">@yuzuhara</a>)のTENTACLEなどがある．</p>
<h1 id="研究目的">研究目的</h1><p>ハードウェア仮想化技術を用いる解析環境とソフトウェアエミュレーションを用いる解析環境にはそれぞれ問題がある．そこで，ハードウェア仮想化技術を用いる解析環境でRecordを行い，ソフトウェアエミュレーションを用いる解析環境でReplayを行うことで，検出不可能性と拡張可能性という二つの目的について達成したのが，今回紹介するV2Eである．</p>
<h1 id="形式的定義">形式的定義</h1><p>本論文におけるRecord and Replayの設計はどのようなものか．<br>Recorderにおける遷移関数<code>f</code>について，毎時<sub><code>i</code></sub>におけるプログラムの状態を<code>S</code><sub><code>i</code></sub>とし，入力を<code>I</code><sub><code>i</code></sub>とする．すなわち<code>f</code>は<code>S</code><sub><code>i</code></sub><code>= f(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と表される．<br>次にReplayerにおける遷移関数<code>f&#39;</code>についてプログラムの初期状態を<code>S</code><sub><code>0</code></sub>とし，全ての入力を<code>I</code>としたとき，<code>f = f&#39;</code>と言えないだろうか．<br>これは二つのチューリング機械の同値性が解決可能であるかという問題に相当する．だが<code>EQ</code><sub><code>TM</code></sub><code>= {(M</code><sub><code>1</code></sub><code>, M</code><sub><code>2</code></sub>)<code>|M</code><sub><code>1</code></sub><code>とM</code><sub><code>2</code></sub><code>はTMであり，L(M</code><sub><code>1</code></sub><code>) = L(M</code><sub><code>2</code></sub><code>)}</code>は判定不可能とされ（『計算理論の基礎』における定理5.4），実装上でもハードウェアの割り込みなどの要因から<code>f != f&#39;</code>となってしまう．<br>そこでV2Eは，プログラムの初期状態と全ての入力を保存することに加え，<code>S</code><sub><code>j</code></sub><code>= S&#39;</code><sub><code>j</code></sub>となるような<sub><code>j</code></sub>について状態の変化を保存することにした．これは<code>⊿</code><sub><code>j</code></sub><code>= S</code><sub><code>j</code></sub><code>- S</code><sub><code>j-1</code></sub>と表される．<br>ここで，新たな遷移関数<code>f&#39;</code><sub><code>r</code></sub>を<code>S&#39;</code><sub><code>i</code></sub><code>= f&#39;</code><sub><code>r</code></sub><code>(S&#39;</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>, ⊿</code><sub><code>i</code></sub><code>)</code>として定義する．これは，<code>⊿</code><sub><code>i</code></sub><code>!= null</code>のとき<code>S&#39;</code><sub><code>i-1</code></sub><code>+ ⊿</code><sub><code>i</code></sub>と同値であり，それ以外について<code>f&#39;(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と同値をとる．<br>なお，<code>S</code><sub><code>0</code></sub>, <code>I</code>, <code>⊿</code>および<code>f&#39;</code><sub><code>r</code></sub>, <code>S&#39;</code><sub><code>i</code></sub><code>= S</code><sub><code>i</code></sub>は<code>i ∈ [0, n]</code>について恒真である．<br>これを実装に起こすと，特定の命令やイベントが正しくエミュレート可能な場合は単にそれらをエミュレートし，そうでなければ状態の変化を記録し，Replayにあたって変更を適用するというアプローチになる．</p>
<h1 id="理論と実際">理論と実際</h1><p>プログラムの大部分を占める<code>mov</code>, <code>push</code>, <code>pop</code>などのデータ転送命令，<code>call</code>, <code>ret</code>, <code>jz</code>, <code>jmp</code>などの制御転送命令，<code>add</code>, <code>shl</code>などの整数演算命令におけるエミュレーションは失敗しないものと見做せる．これらはそのままRecorderでエミュレートされる．<br>一方で，割り込み，MMIO, Port IO, DMA, TSCについては，V2Eは既存研究を踏襲し，監視領域においてのみこれらをRecordするようになっている．<br>では，例外，モデル固有レジスタ，<code>cpuid</code>はどうすべきだろうか．既存手法は，これらのエミュレーションは困難であるという理由から，そもそも入力として扱わない戦略を採っていたようだ．V2Eではこれらを<code>⊿</code>, すなわちエミュレートが困難な状態の変化としてRecordすることで，Replayの正確性を高めている．<br>次に問題となるのが浮動小数点演算とSIMDの扱いだ．MMXやSSEを正確にエミュレートするのは難しい．だが，<code>⊿</code>として命令の結果を記録する設計は大幅なパフォーマンスの低下を招く．そこでV2EはReplayにあたってこれらの命令をパススルーする．もちろん，ReplayerはSIMDをサポートしているマシンで実行されることが前提にある．</p>
<h1 id="Transparent_Recorder">Transparent Recorder</h1><p>RecorderはKVMを用いて実装されている．<br>V2EはRecord対象の領域とそれ以外のシステムを分割するため，TDP(two dimensional paging)を用いている．何のことかと思ったら，Intel EPTやAMD NPTの総称らしい．<br><img src="/image/tdp.jpg"><br>要するに，TDPとは仮想マシンと物理マシン間のページテーブルのことだ．通常のページングでは，メモリアクセスに応じてMMUによってページテーブルが参照され，仮想アドレスが物理アドレスへと変換される．TDPでは，ゲストマシンからの仮想メモリ空間へのアクセスに応じてCR3にセットされたページテーブルが参照され，ゲスト物理アドレスがホスト物理アドレスへと変換される．<br>この仕組を用いたV2Eは，<strong>監視対象用のTDPテーブルと，それ以外用のTDPテーブルを別々に作成する</strong>．マルウェアに属するページはCR3の監視に基づき監視対象用のTDPテーブルに書き込まれる．マルウェアとそれ以外の部分のインタラクションはTDPページフォルトや<code>VMExit</code>によって媒介される．共有されるデータは読み取り専用として双方に与えられる．なお，TDPページフォルトに応じてCPUの状態が入力<code>I</code><sub><code>i</code></sub>として保存される．</p>
<h1 id="Precise_Replayer">Precise Replayer</h1><p>ReplayerはTEMUを用いて実装されている．バイナリ変換器に中間表現がなく，単純に古いQEMU 0.9.1をベースとしているのが玉に瑕だが，TEMUは動的テイント解析に求められる機能をほぼ網羅している．<br>TEMUはプラグインを共有ライブラリとしてロードし，コールバック関数からテイント解析の機能を呼び出すプラットフォームとなっている．V2EのReplayerは既存のプラグインであるtracecap, unpackerを用いる．だがRecordされたログには監視対象の情報のみが記述されているため，<br><code>return ((*TEMU_cpu_hflags &amp; HF_CPL_MASK) != 3)</code>といった，現在実行しているコードが解析対象のものかどうか判定するコードは除去されているようだ．TEMUのプラグインについては，こうした僅かな変更しか施されていない．<br>一方でその下で動くQEMUには結構手が加えられている．フラグの遅延評価は廃止され，ページフォルト以外の例外は除去されており，SIMDについては独自のヘルパー関数が追加されたようだ．QEMUのdyngenに手を加えるのはなかなか骨の折れる作業だと思う．<br>さて，Replayを行うためには，ReplayerはRecorderと同様のページングの仕組みをエミュレーションによって再現しなければならない．そこで，V2Eは物理ページコンテナという仕組みを用いている．これは，物理ページがログからロードされていることを示すものである．通常，物理ページコンテナは監視対象用のTDPテーブルを複製する．Replayされたプログラムが物理ページコンテナに存在しないページにアクセスした場合，Replayerは適切なタイミングでログからCPUの状態を復元し，ロードするようになっている．<br>V2Eにおけるテイント解析はおそらく，マルウェアのメモリ領域を正確に把握するためのものではない．それは，Recorderの段階でTDPテーブルの分割というアプローチによって実現されるべきものだからだ．TEMUのプラグインを使いたかったのだろうが，論文中からはあまりテイント解析を導入することのメリットが読み取れなかった．ここでのテイント解析は解析環境検出の対策に先立つものとして設定されているのだろうか．</p>
<h1 id="評価">評価</h1><p>解析環境検出については問題なし．<code>cpuid</code>, <code>rdtsc</code>, <code>cmpxch8b</code>, <code>icbp</code>, <code>rep stosb</code>, <code>fnstcw</code>といった命令や，一般保護例外などについてテストされている．なお，<code>rdtsc</code>については<code>VMRESUME</code>前にホストのTSCを参照することで対応している．<br>in-the-wildのマルウェアについても実験が行われており，アンパッカーとして期待できるパフォーマンスを見せている．<br>Recordにおける速度だが，コンテキストスイッチが頻繁に発生するカーネルモードルートキットで17倍，Internet Explorerで5倍と高速だ．KVMのシングルステップモードには3000倍のオーバーヘッドがあると言うのに．<br>全体的にpositiveな結果で，かなり良い．</p>
<h1 id="おわりに">おわりに</h1><p>マルウェアによる解析環境検出に対して，復数の環境を組み合わせたRecord and Replayを用いる研究について紹介した．何より，監視対象とそれ以外で別個にTDPテーブルを作るというアプローチが素晴らしい．自分も研究でテイント解析を扱っているが，この流れを包摂していきたい．<br>ただ，これはサンドボックス全般に言えることなのだが，感染ホストにおけるユーザーのブラウザ操作が条件分岐に影響するMITBマルウェアについて，どう対処すべきなのだろうか．正常系のユーザーのブラウザ操作をデータセットとしてRecorderに与えたいところだが，果たしてどうなるのか．<br>このエントリは<a href="http://www.adventar.org/calendars/440" target="_blank" rel="external">システム系論文紹介 Advent Calendar 2014</a>の9日目として書かれた．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Lok-Kwong Yan, Manjukumar Jayachandra, Mu Zhang and Heng Yin,<br>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>,”<br>Proceedings of the 8th ACM SIGPLAN/SIGOPS conference on Virtual Execution Environments, pp. 227-238, NY, USA, 2012.</li>
<li>George W. Dunlap, Samuel T. King, Sukru Cinar, Murtaza A. Basrai and Peter M. Chen,<br>“<a href="http://web.engr.illinois.edu/~kingst/Research_files/dunlap02.pdf" target="_blank" rel="external">ReVirt: Enabling Intrusion Analysis through Virtual-Machine Logging and Replay[PDF]</a>,”<br>Proceedings of the 2002 Symposium on Operating Systems Design and Implementation, pp. 211-224, NY, USA, 2002.</li>
<li>A. Dinaburg, P. Royal, M. Sharif and W. Lee.<br>“<a href="http://ether.gtisc.gatech.edu/ether_ccs_2008.pdf" target="_blank" rel="external">Ether: malware analysis via hardware virtualization extensions[PDF]</a>,”<br>Proceedings of the 15th ACM Conference on Computer and Communications Security, pp. 51–62, NY, USA, 2008.</li>
<li>大居司,<br>“<a href="http://www.slideshare.net/a4lg/a-new-tracer-for-reverse-engineering" target="_blank" rel="external">リバースエンジニアリングのための新しいトレース手法</a>,”<br>PacSec 2010, 東京, 日本, 2010.</li>
<li>Dhilung Kirat, Giovanni Vigna, and Christopher Kruegel,<br>“<a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kirat.pdf" target="_blank" rel="external">BareCloud: Bare-metal Analysis-based Evasive Malware Detection[PDF]</a>,”<br>Proceedings of the 23rd USENIX conference on Security Symposium, pp. 287-301, CA, USA, 2014.</li>
<li>忠鉢洋輔, 愛甲健二,<br>“<a href="https://pacsec.jp/psj14/PSJ2014_chubachi_final_ja.pdf" target="_blank" rel="external">TENTACLE: Environment-Sensitive Malware Palpation[PDF]</a>,”<br>PacSec Tokyo 2014, 東京, 日本, 2014.</li>
<li>M. Siper,<br>“<a href="http://www.cs.virginia.edu/~robins/Sipser_2006_Second_Edition_Problems.pdf" target="_blank" rel="external">Introduction to the Theory of Computation. International</a>,”<br>Thomson Publishing, 1996.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/09/v2e/" data-id="cii1a7yog000jswosimpsos7h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vine-howto" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/28/vine-howto/">Vineを動かす</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-27T20:56:08.000Z" itemprop="datePublished">09-28-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>ここでは，<a href="http://bitblaze.cs.berkeley.edu/" target="_blank" rel="external">BitBlaze</a>のうち，静的解析に特化したコンポーネントであるVineを動かしてみる．</p>
<h1 id="BitBlaze">BitBlaze</h1><p>BitBlazeはDawn Songらによるバイナリ解析プラットフォームで，2008年に<a href="http://bitblaze.cs.berkeley.edu/papers/bitblaze_iciss08.pdf" target="_blank" rel="external">BitBlaze: A New Approach to Computer Security via Binary Analysis [PDF]</a>が発表されて以来，数多くの研究に用いられてきた．BitBlazeは，動的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/temu.html" target="_blank" rel="external">TEMU</a>，静的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/vine.html" target="_blank" rel="external">Vine</a>，動的シンボリック実行コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/rudder.html" target="_blank" rel="external">Rudder</a>から構成される．このうち，TEMUとVineのソースコードが公開されている．</p>
<h2 id="TEMU:_The_BitBlaze_Dynamic_Analysis_Component">TEMU: The BitBlaze Dynamic Analysis Component</h2><p>TEMUはQEMUをベースとしたエミュレータで，テイント解析(taint analysis)の機能を備えている．テイント解析とは，タグを設定したデータの伝搬を追跡することで，データ同士の依存関係を解析する技術である．TEMUはtracecapというプラグインを用いて，ゲストOS上で動作するアプリケーションのトレースログを取得することができる．</p>
<h2 id="Vine:_The_BitBlaze_Static_Analysis_Component">Vine: The BitBlaze Static Analysis Component</h2><p>Vineは，逆アセンブリやTEMUのトレースファイルから，中間表現VineILや最弱事前条件，STP formulaなどを出力する．公開されているVineには，TEMU/tracecapのトレースファイルとしてfive.traceが同梱されている．これを例にVineの機能を見てみよう．</p>
<h1 id="Vineのインストール">Vineのインストール</h1><p><a href="http://bitblaze.cs.berkeley.edu/release/vine-1.0/howto.html" target="_blank" rel="external">Vine installation and user manual</a>の通り．OCamlで記述されているため，関連のパッケージを導入する必要がある．また，32bit環境での動作を前提としている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ ocaml ocaml-findlib libgdome2-ocaml-dev camlidl \ &#10;                     libextlib-ocaml-dev ocaml-native-compilers \ &#10;                     libocamlgraph-ocaml-dev binutils-dev texlive \ &#10;                     texlive-latex-extra transfig hevea</span><br></pre></td></tr></table></figure>
<h1 id="trace_reader">trace_reader</h1><p>TEMU/tracecapが出力するトレースファイルはhuman-readableではなく，閲覧はVineのtrace_readerを介して行う必要がある．five.traceでは，T1がタグの識別子となっており，T0はデータに設定されたタグが存在しないことを意味する．なお，ここではキーボードからの入力にタグが設定されている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../trace_utils/trace_reader -trace five.trace | grep T1 | head -n 20&#10;42075911:&#9;movzbl (%eax),%eax&#9;R@eax[0x40014000][4]&#9;T0&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077e0c:&#9;cmp    $0xffffffff,%eax&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077e14:&#9;movzbl (%edx),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205abc5:&#9;mov    %eax,-0xac(%ebp)&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff69c[0x00000000][4]&#9;T0&#10;4205abce:&#9;mov    -0xa8(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff6a0[0x00000000][4]&#9;T0&#10;4205abd5:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205abf5:&#9;mov    -0xac(%ebp),%edx&#9;R@edx[0x40014001][4]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac0b:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac14:&#9;movzbl -0xac(%ebp),%eax&#9;R@eax[0x42130b80][4]&#9;T0&#9;M@0xbffff69c[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac24:&#9;push   %eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff604[0x4213030c][4]&#9;T0&#10;4205ac25:&#9;mov    0x8(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff750[0x4212d980][4]&#9;T0&#10;4207793a:&#9;mov    0xc(%ebp),%edx&#9;R@edx[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff604[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077945:&#9;cmp    %dl,-0x1(%eax)&#9;R@dl[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077974:&#9;movzbl %dl,%eax&#9;R@dl[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;R@eax[0x40014000][4]&#9;T0&#10;42077960:&#9;cmp    $0xffffffff,%eax&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac39:&#9;movzbl -0x9d(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff6ab[0x00000064][1]&#9;T0&#10;4205c550:&#9;mov    $0xa,%edx&#9;I@0x00000000[0x0000000a][4]&#9;T0&#9;R@edx[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205c566:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205dcd1:&#9;movzbl (%eax),%edi&#9;R@edi[0x00000000][4]&#9;T0&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205dcd8:&#9;mov    %edi,-0xac(%ebp)&#9;R@edi[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;</span><br></pre></td></tr></table></figure>
<h1 id="VineIL">VineIL</h1><p>Vineが生成するVineILは静的単一代入形式の中間表現であり，CFGの情報が損なわれることはない．中間表現の生成をinstruction liftingという．なお，VineILはValgrindの中間表現を扱うライブラリVEXをもとに生成される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -ir-out five.ir&#10;~/vine/examples$ cat five.ir | awk &#39;NR==1000,NR==1020&#39;&#10;R_CC_OP_16:reg32_t = 0xd:reg32_t;&#10;T_32t9_1114:reg32_t = cast(T_8t3_1108:reg8_t)U:reg32_t;&#10;R_CC_DEP1_17:reg32_t = T_32t9_1114:reg32_t;&#10;R_CC_DEP2_18:reg32_t = 0:reg32_t;&#10;R_CC_NDEP_19:reg32_t = 0:reg32_t;&#10;/*eflags thunk: logic*/&#10;&#10;R_CF_10:reg1_t = false;&#10;T_7_1115:reg8_t = cast(T_32t9_1114:reg32_t)L:reg8_t;&#10;R_PF_11:reg1_t =&#10;!cast(&#10;      ((T_7_1115:reg8_t &#62;&#62; 7:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 6:reg32_t)&#10;         ^ (T_7_1115:reg8_t &#62;&#62; 5:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 4:reg32_t))&#10;       ^ &#10;         ((T_7_1115:reg8_t &#62;&#62; 3:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 2:reg32_t)&#10;            ^ (T_7_1115:reg8_t &#62;&#62; 1:reg32_t ^ T_7_1115:reg8_t))&#10;         )L:reg1_t;&#10;R_AF_12:reg1_t = false;&#10;R_ZF_13:reg1_t = T_32t9_1114:reg32_t == 0:reg32_t;&#10;R_SF_14:reg1_t = 1:reg32_t == (1:reg32_t &#38; T_32t9_1114:reg32_t &#62;&#62; 7:reg32_t);&#10;R_OF_15:reg1_t = false;</span><br></pre></td></tr></table></figure>
<p>出力している行の番号は適当．</p>
<h1 id="最弱事前条件">最弱事前条件</h1><p>最弱事前条件(weakest precondition)はDijkstraによる述語変換意味論の基礎を成す概念である．Sを条件，式をRとした際，最弱事前条件WP(S, R)は，Rを実行する前にS’が成り立っていればSの実行後にSが成り立つ最も弱い条件S’を表す．単純な例だと，以下のように表現される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WP(S, x=e) = S[e/x]&#10;WP(new == org,  new = new+taint) &#10;=  new+taint == org</span><br></pre></td></tr></table></figure>
<p>Vineにおける最弱事前条件の出力は，以下のようになる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -wp-out five.wp&#10;~/vine/examples$ grep let five.wp | head -n 20&#10;let post_1681:reg1_t = true in&#10;let R_EAX_1682:reg32_t = 0x40014000:reg32_t in&#10;let idx_1683:reg32_t = 0x40014000:reg32_t in&#10;let val_1684:reg8_t = INPUT_1001_0000_61:reg8_t in&#10;let temp_1685:reg8_t = val_1684:reg8_t &#38; 0xff:reg8_t in&#10;let temp_1686:reg8_t = temp_1685:reg8_t &#62;&#62; 0:reg8_t in&#10;let towrite_1688:reg8_t = cast(temp_1686:reg8_t)L:reg8_t in&#10;let mem_arr_1687:reg8_t[4294967296] =&#10;    let mem_arr_57[0x40014000:reg32_t]:reg8_t = towrite_1688:reg8_t in&#10;    mem_arr_57:reg8_t[4294967296]&#10;in&#10;let R_EAX_1689:reg32_t = 0x40014000:reg32_t in&#10;let R_GDT_1690:reg32_t = 0xc02dbd80:reg32_t in&#10;let R_LDT_1691:reg32_t = 0xc02dcc58:reg32_t in&#10;let R_DFLAG_1692:reg32_t = 1:reg32_t in&#10;let T_32t0_1693:reg32_t = R_EAX_1689:reg32_t in&#10;let T_8t2_1694:reg8_t = mem_arr_1687[0x40014000:reg32_t]:reg8_t in&#10;let T_32t1_1695:reg32_t = cast(T_8t2_1694:reg8_t)U:reg32_t in&#10;let R_EAX_1696:reg32_t = T_32t1_1695:reg32_t in&#10;let temp_1697:reg32_t = R_EAX_1696:reg32_t &#38; 0xffff00ff:reg32_t in&#10;let temp_1698:reg32_t = cast(0:reg8_t)U:reg32_t in&#10;let temp_1699:reg32_t = temp_1698:reg32_t &#60;&#60; 8:reg8_t in</span><br></pre></td></tr></table></figure>
<p>このような手法でソースコードの存在しないバイナリから最弱事前条件を抽出し，仕様書を復元する試みがあるらしい．ゾッとする．</p>
<h1 id="STP_formula">STP formula</h1><p>Vineは，TEMUのトレースファイルからSTP formulaを出力する．STP formulaとはSMTソルバであるSTP用のフォーマットである．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -stp-out five.stp&#10;~/vine/examples$ head -n 20 five.stp&#10;% free variables: &#10;mem_arr_57 : ARRAY BITVECTOR(64) OF BITVECTOR(8);&#10;INPUT_1001_0000_61 : BITVECTOR(8);&#10;% end free variables.&#10; &#10; &#10;ASSERT( 0bin1 =&#10;(LET post_1681 =&#10;    0bin1&#10;IN&#10;(LET R_EAX_1682 =&#10;    0hex40014000&#10;IN&#10;(LET idx_1683 =&#10;    0hex40014000&#10;IN&#10;(LET val_1684 =&#10;    INPUT_1001_0000_61&#10;IN&#10;(LET temp_1685 =</span><br></pre></td></tr></table></figure>
<p>SMTソルバは充足可能性問題を解く．では，ここで与えられる命題とは何か．それは，任意の初期値がトレースファイルの結果と一致するというものだ．STPは命題が充足可能か解こうとし，充足不能であった場合は反例を出力する．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ cat &#62;&#62;five.stp&#10;QUERY(FALSE);&#10;COUNTEREXAMPLE;</span><br></pre></td></tr></table></figure>
<p>ここで出力される反例は，実行経路に影響を与えた入力値となるようだ．five.traceでは，0x35(ASCIIで5)という入力値が分岐に影響を与えている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../stp/stp five.stp&#10;Invalid.&#10;ASSERT( INPUT_1001_0_61  = 0hex35  );</span><br></pre></td></tr></table></figure>
<p>これはトレースファイルに対する静的なシンボリック実行だと言える．シンボリック実行とは，記号によって表現したプログラムの変数を操作することで，実行経路に影響する制約を抽出する静的解析の手法である．シンボリック実行は到達定義の解析などモデルベーステストの領域で発展してきたが，マルウェアの挙動解析に役立てられないだろうか．</p>
<h1 id="BAP">BAP</h1><p><a href="http://bap.ece.cmu.edu" target="_blank" rel="external">BAP</a>はDavid BrumleyらによるVineの再実装である．彼らはCMUに所属しており，PPPのメンバーでもある．彼らは脆弱性解析の自動化をmotivationとしてBitBlazeを扱ってきた．BAPはVineをより発展させたプロジェクトであり，逆アセンブリやTEMUのトレースファイルから中間表現BILを生成するほか，CFGのみならずCDG(control dependence graphs)やDDG(data dependence graphs)の出力をサポートしているようだ．</p>
<h1 id="おわりに">おわりに</h1><p>TEMUのトレースファイルについて，ざっくりVineによる静的解析を行った．とりあえず動かしてみただけなので，コードを噛み砕く必要がある．気になるのはやはり中間表現のフォーマットだ．一度，QEMU，Valgrind，DynamoRIO，LLVM，Vine，BAPなどの中間表現について，対応を整理したほうが良いかもしれない．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/28/vine-howto/" data-id="cii1a7yog000cswosh34f11lw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 ntddk<br>
      <a href="https://github.com/steven5538/hexo-theme-athena" target="_blank">Athena</a> by <a href="http://steven5538.tw" target="_blank">Steven5538</a> | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>