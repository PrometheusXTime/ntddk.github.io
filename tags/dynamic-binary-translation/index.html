<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tag: dynamic binary translation | 一生あとで読んでろ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="一生あとで読んでろ">
<meta property="og:url" content="http://ntddk.github.io/tags/dynamic-binary-translation/index.html">
<meta property="og:site_name" content="一生あとで読んでろ">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一生あとで読んでろ">
<meta name="twitter:description">
<meta name="twitter:creator" content="@ntddk">
  
    <link rel="alternative" href="/atom.xml" title="一生あとで読んでろ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一生あとで読んでろ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技術ブログ</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-automated-malware-analysis-using-decaf-in-seccamp15" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/08/16/automated-malware-analysis-using-decaf-in-seccamp15/">DECAFによるマルウェア自動解析</a>
  

      </header>
    
    <time class="article-date" datetime="2015-08-16T09:00:00.000Z" itemprop="datePublished">08-16-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>2015.08.11~15にわたって開催された<a href="https://www.ipa.go.jp/jinzai/camp/2015/zenkoku2015.html" target="_blank" rel="external">セキュリティ・キャンプ全国大会 2015</a>に解析トラックの講師として参加した．講義では「仮想化技術を用いてマルウェア解析」と題して，QEMUをベースに開発が行われている<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="external">DECAF</a>という解析プラットフォームを用いて演習を行った．</p>
<h1 id="講義資料">講義資料</h1><script async class="speakerdeck-embed" data-id="11c7632b9b844e199ac966e4494a1dd2" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<h1 id="講義内容">講義内容</h1><p>演習では実際のマルウェアに用いられている解析妨害機能を備えたサンプルプログラムを扱った．素のDECAFには解析妨害機能への対策が施されていない．そこで，受講者にはDECAFのプラグインを拡張し，対策手法を実装して頂いた．<br>演習で用いたプログラムはGitHub上で公開している．</p>
<ul>
<li>解析妨害機能を備えたサンプルプログラム<ul>
<li><a href="https://github.com/ntddk/blue" target="_blank" rel="external">ntddk/blue</a></li>
</ul>
</li>
<li>DECAFプラグインのひな形<ul>
<li><a href="https://github.com/ntddk/geteip" target="_blank" rel="external">ntddk/geteip</a></li>
</ul>
</li>
</ul>
<p>ひな形にある通り，IsDebuggerPresent()をフックするDECAFプラグインは以下のように書ける．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> DECAF_Handle isdebuggerpresent_handle = DECAF_NULL_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> call_stack[<span class="number">1</span>]; <span class="comment">//paramters and return address</span></span><br><span class="line">        DECAF_Handle hook_handle;</span><br><span class="line">&#125; IsDebuggerP<span class="keyword">resent_hook_context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * BOOL IsDebuggerPresent(VOID);</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_ret</span><span class="params">(<span class="keyword">void</span> *param)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span> *)param;</span><br><span class="line">        hookapi_remove_hook(ctx-&gt;hook_handle);</span><br><span class="line">        DECAF_printf(<span class="string">"EIP = %08x, EAX = %d\n"</span>, cpu_single_env-&gt;eip, cpu_single_env-&gt;regs[R_EAX]);</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_call</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        DECAF_printf(<span class="string">"IsDebuggerPresent "</span>);</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(IsDebuggerP<span class="keyword">resent_hook_context_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!ctx) <span class="keyword">return</span>;</span><br><span class="line">        DECAF_read_mem(NULL, cpu_single_env-&gt;regs[R_ESP], <span class="number">4</span>, ctx-&gt;call_stack);</span><br><span class="line">        ctx-&gt;hook_handle = hookapi_hook_return(ctx-&gt;call_stack[<span class="number">0</span>], IsDebuggerPresent_ret, ctx, <span class="keyword">sizeof</span>(*ctx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">geteip_loadmainmodule_callback</span><span class="params">(VMI_Callback_Params* params)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(params-&gt;cp.name,targetname) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                DECAF_printf(<span class="string">"Process %s you spcecified starts \n"</span>, params-&gt;cp.name);</span><br><span class="line">                target_cr3 = params-&gt;cp.cr3;</span><br><span class="line">                isdebuggerpresent_handle = hookapi_hook_function_byname(<span class="string">"kernel32.dll"</span>, <span class="string">"IsDebuggerPresent"</span>, <span class="number">1</span>, target_cr3, IsDebuggerPresent_call, NULL, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在のプロセスがデバッガのコンテキストで実行されていない場合，IsDebuggerPresent()は0を返す．ここで，IsDebuggerPresent()の戻り値を0にするには，モジュール（この場合はkernel32.dll）から戻る段階でeaxを書き換えてやればよい．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_ret</span><span class="params">(<span class="keyword">void</span> *param)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span> *)param;</span><br><span class="line">        hookapi_remove_hook(ctx-&gt;hook_handle);</span><br><span class="line">        cpu_single_env-&gt;regs[R_EAX] = <span class="number">0</span>; <span class="comment">// 追加</span></span><br><span class="line">        DECAF_printf(<span class="string">"EIP = %08x, EAX = %d\n"</span>, cpu_single_env-&gt;eip, cpu_single_env-&gt;regs[R_EAX]);</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このようにDECAFのプラグインを書くことで，ゲストOSに解析用のエージェントを挿入することなくAPIの戻り値を書き換えることができる．<br>APIの引数を書き換えたい場合はモジュールに入る段階でコンテキスト構造体の<code>call_stack[]</code>を書き換えてやればよい．</p>
<h1 id="おわりに">おわりに</h1><p>受講者にサンドボックス開発の楽しさと難しさを実感してもらえたなら，講師として冥利に尽きる．<br>サンプルプログラムには4種類の解析妨害機能を実装しており，APIフックで対処できるのはうち前半2つだけとなっている．限られた演習時間の制約上，3つ目以降の解析妨害機能を回避できた受講者はいなかった．解析トラックリーダーの岩村さんから，受講者の2割がギリギリ解けないような問題を作るようにと仰せつかっていたが，やや意地悪な問題設定だったと思う．<br>なお，今回は拙作のサンプルを用いたが，より多くの解析妨害機能を備えたOSSに<a href="https://github.com/a0rtega/pafish" target="_blank" rel="external">pafish</a>がある．pafishはBackdoor.Win32.Agent.dkbp(MD5: de1af0e97e94859d372be7fcf3a5daa5)など一部のマルウェアに流用されている．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/08/16/automated-malware-analysis-using-decaf-in-seccamp15/" data-id="cipa8jboy001yxsosweez4pqt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-qemu-dbt-bottleneck" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/07/13/qemu-dbt-bottleneck/">QEMUの動的バイナリ変換におけるボトルネック</a>
  

      </header>
    
    <time class="article-date" datetime="2015-07-13T06:00:00.000Z" itemprop="datePublished">07-13-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>QEMUは動的バイナリ変換を用いた完全仮想化式のハイパーバイザである．<br>QEMUは実行対象の命令列を逆アセンブルし，いちど中間表現に変換したうえで，ホストのアーキテクチャの命令列に変換して実行する．これによりQEMUは異なるアーキテクチャのバイナリを実行することができる．<br>しかしQEMUは遅かったため，アクセラレータとしてkqemuが開発された．<br>kqemuはユーザーモードのコードをホストのCPUに実行させる準仮想化ドライバであり，やがてKVMへと変貌を遂げた．さらにKVMはハードウェアによる仮想化支援機能を用いることで，さらなる高速化を実現した．もはやKVMにおいてQEMUはハードウェアのエミュレーションにしか用いられていない．<br>かわいそうなQEMU！<br>しかしQEMUの活躍する場面はいまだ多く残されている．たとえばマルウェア解析で．<br>それでも遅いのは困りものだ．QEMUはどこが遅いのだろうか．<br>ここでは<code>perf</code>を用いてQEMUのボトルネックを<strong>雑に</strong>特定する．</p>
<h1 id="実験">実験</h1><p>今回はARMエミュレーションについて調査した．ホスト・ゲストともOSにはUbuntu 12.04(3.2.0-23-generic)を用いた．<code>perf</code>でQEMUのプロファイリングを行っている間，ゲストではgccを用いてコンパイルを実行した．</p>
<ul>
<li><p>ARM版Ubuntu 12.04のインストール</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install qemu&#10;# wget http://odroid.us/odroid/users/osterluk/qemu-example/qemu-example.tgz&#10;# tar xzf qemu-example.tgz ./zImage&#10;# wget http://releases.linaro.org/12.04/ubuntu/precise-images/developer/linaro-precise-developer-20120426-86.tar.gz&#10;# tar xzf linaro-precise-developer-20120426-86.tar.gz&#10;# qemu-img create -f raw rootfs.img 3G&#10;# mkfs.ext3 rootfs.img&#10;# mkdir mnt&#10;# sudo mount -o loop rootfs.img mnt&#10;# rsync -a binary/boot/filesystem.dir/ mnt/&#10;# sudo umount mnt</span><br></pre></td></tr></table></figure>
</li>
<li><p>QEMUのビルド</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get build-dep qemu&#10;# git clone git://git.qemu-project.org/qemu.git&#10;# cd qemu&#10;# git log | grep &#39;^commit&#39; | head -1 | awk &#39;&#123;print $2&#125;&#39;&#10;6169b60285fe1ff730d840a49527e721bfb30899&#10;# git submodule update --init dtc&#10;# git submodule update --init pixman&#10;# ./configure --extra-ldflags=-pg --target-list=arm-softmmu&#10;# make</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>perf</code>のインストール</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install linux-tools&#10;# sudo echo 0 &#62; /proc/sys/kernel/perf_event_paranoid</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>perf</code>によるプロファイリング</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># perf record -a -g -F100000 qemu/arm-softmmu/qemu-system-arm -M vexpress-a9 -m 512 -kernel zImage -sd rootfs.img -append &#34;root=/dev/mmcblk0 rw physmap.enabled=0 console=ttyAMA0&#34; -monitor stdio&#10;WARNING: Image format was not specified for &#39;../../rootfs.img&#39; and probing guessed raw.&#10;         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.&#10;         Specify the &#39;raw&#39; format explicitly to remove the restrictions.&#10;QEMU 2.3.90 monitor - type &#39;help&#39; for more information&#10;(qemu) audio: Could not init `oss&#39; audio driver&#10;&#10;(qemu) q&#10;[ perf record: Woken up 37 times to write data ]&#10;[ perf record: Captured and wrote 9.465 MB perf.data (~413514 samples) ]&#10;&#10;&#10;Failed to open /tmp/perf-6993.map, continuing without symbols&#10;Failed to open [vmxnet], continuing without symbols&#10;Failed to open [vmci], continuing without symbols&#10;Failed to open [vsock], continuing without symbols&#10;no symbols found in /bin/dash, maybe install a debug package?&#10;no symbols found in /usr/bin/xargs, maybe install a debug package?&#10;no symbols found in /usr/bin/updatedb.mlocate, maybe install a debug package?&#10;no symbols found in /usr/bin/dpkg-query, maybe install a debug package?</span><br></pre></td></tr></table></figure>
</li>
<li><p>Flame Graphsによる可視化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.githubusercontent.com/brendangregg/FlameGraph/master/stackcollapse-perf.pl&#10;# wget https://raw.githubusercontent.com/brendangregg/FlameGraph/master/flamegraph.pl&#10;# perf script&#62; perf_data.txt&#10;# perl stackcollapse-perf.pl perf_data.txt|perl flamegraph.pl --title &#34;Flame Graphs - qemu-system-arm&#34; &#62; flamegraphs-qemu-system-arm.svg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>perf</code>の結果をFlame Graphsを用いて可視化すると下図のようになった．Flame GraphsはUSENIX LISA’2013にて発表された可視化ツールである．</p>
<p><img src="/image/flamegraphs-qemu-system-arm.png"></p>
<p>x軸は時系列，y軸はコールスタックを意味する．横幅が広く上位に位置する関数がボトルネックであるといえる．<br>よってボトルネックは<code>clear_page()</code>すなわちTCGの各関数で発生しているページフォルトである．</p>
<h1 id="おわりに">おわりに</h1><p>ページフォルトだけは勘弁してほしい．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>“perf + Flame Graphs で Linux カーネル内のボトルネックを特定する - ablog,” <a href="http://d.hatena.ne.jp/yohei-a/20150706/1436208007" target="_blank" rel="external">http://d.hatena.ne.jp/yohei-a/20150706/1436208007</a></li>
<li>Brendan Gregg, “<a href="https://www.usenix.org/conference/lisa13/technical-sessions/plenary/gregg" target="_blank" rel="external">Blazing Performance with Flame Graphs</a>,” Proceedings of the 27th Large Installation System Administration Conference, USENIX LISA’13, Washington, D.C., USA, 2013.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/07/13/qemu-dbt-bottleneck/" data-id="cipa8jbnz0015xsos7z433cjp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pin-to-pemu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/04/03/pin-to-pemu/">PinからPEMUへ</a>
  

      </header>
    
    <time class="article-date" datetime="2015-04-03T11:45:00.000Z" itemprop="datePublished">04-03-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Dynamic_Binary_Instrumentation">Dynamic Binary Instrumentation</h1><p>Dynamic Binary Instrumentation(DBI)とは，実行中のプログラムにコードを挿入する技術である．<br>その目的は，プログラムの性能評価であったり，アーキテクチャのシミュレーションであったり，プログラムのデバッグであったり，プログラムのsheparding（ポリシを用いたセキュリティ制限）であったり，プログラムの最適化であったり，テイント解析などのデータフロー解析であったり，リバースエンジニアリングであったり，マルウェア解析であったり，……と多岐にわたっている．<br>デバッガとDBIを区別することは難しく，ニュアンスの問題になってしまうが，DBIはより「挿入するコードがプログラマブルであること」を重視している．また，instrumentation（名詞）/instrument（動詞）という語は，コードの挿入を通してプログラムの情報を取得したり，プログラムを制御したりといったニュアンスを含んでいる．<br>DBIのメリットとして，言語に依存しないこと，古いソフトウェアに対しても適用できること，再コンパイルの必要がないこと，動的に生成されるコードを扱うことができること，実行中のプロセスにアタッチできることが挙げられる．</p>
<h1 id="Pin">Pin</h1><p>Intelによって開発されている<a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool" target="_blank" rel="external">Pin</a>は，DBIフレームワークの中でも最も成功している一つであり，そのAPIの数は450種類を越える．<br>Pinにおけるinstrumentationの手法は，コードの実行時にinstrumentするjust-in-time Instrumentation(JITI)と，イメージ（実行ファイルや共有ライブラリ，構造体）のロード時にinstrumentするahead-of-time-insturumentation(AOTI)の二種類に大別される．<br>これらのinstrumentにあたって，Pinは解析対象のプログラムにpinvm.dllを挿入する．</p>
<h2 id="JITI">JITI</h2><p>JIITは以下の三種類を単位として行うことができる．</p>
<h3 id="Instruction_Level">Instruction Level</h3><p>第一に，最も低い粒度として，命令単位のinstrumentationがサポートされている．<br>これは，<code>INS_AddInstrumentFunction</code>のコールバックとして実現される．関連するAPIは，Pin 2.1.3の時点で142種類存在する．</p>
<h3 id="Basic_Block_Level(BBL)">Basic Block Level(BBL)</h3><p>第二に，Basic Block(BB)単位のinstrumentationがサポートされている．<br>ここでのBBとは，一つの入口と一つの出口を持ち，内部に分岐を含まない命令列のことであり，コンパイラ最適化におけるそれと同義である．Pinでは，<code>BBL_InsHead</code>や<code>BBL_InsTail</code>，<code>BBL_Next</code>や<code>BBL_Prev</code>といった関数を用いてBBの有向グラフを操作することができる．一方で<code>BBL_AddInstrumentationFunction</code>のコールバックは<strong>存在しない</strong>．関連するAPIは，Pin 2.1.3の時点で14種類存在する．</p>
<h3 id="Trace_Level">Trace Level</h3><p>第三に，Trace単位のinstrumentationがサポートされている．<br>Traceとは，Pin独自の単位であり，分岐命令を入り口とし，無条件分岐（<code>jmp</code>, <code>call</code>, <code>ret</code>など）を出口とする命令列のことである．つまり，Traceは<strong>複数のBBを含みうる</strong>．これは，<code>TRACE_AddInstrumentFunction</code>のコールバックとして実現される．関連するAPIは，Pin 2.1.3の時点で14種類存在する．<br>Pinでは，objdumpなどと同様に線型分析法によってバイナリを逆アセンブルし，Traceを取得する．ここで，JITIに用いるVMをトラップすることなく別のTraceに分岐を行うための<a href="http://www.cs.virginia.edu/kim/courses/cs851/papers/luk05pin.pdf" target="_blank" rel="external">trace-linking optimization[PDF]</a>が行われる．そのため，Trace単位のinstrumentationが命令単位のinstrumentationよりも高速になる場合がある．</p>
<h2 id="AOTI">AOTI</h2><p>AOTIは以下の二種類を単位として行うことができる．</p>
<h3 id="IMG_instrumentation">IMG instrumentation</h3><p>第一に，IMG単位のinstrumentationがサポートされている．<br>IMGは，特定の実行ファイルないし共有ライブラリ，構造体に相当する単位である．これは，<code>IMG_AddInstrumentFunction</code> APIによって実現される．また，IMGのセクション(SEC)についてもinstrumentを行うことができる．関連するAPIは，IMGについて27種類，SECについて16種類が存在する．</p>
<h3 id="RTN_instrumentation">RTN instrumentation</h3><p>第二に，RTN単位のinstrumentationがサポートされている．<br>RTNとは関数(Routine)に相当する単位である．これは，<code>RTN_AddInstrumentFunction</code> APIによって実現される．関連するAPIは，Pin 2.1.3の時点で39種類存在する．</p>
<h2 id="Transparency">Transparency</h2><p>このように様々な機能を備えるPinだが，マルウェア解析においてはどれほど有用なのだろうか．<br>Pinのinstrumentationは，素朴なDLLインジェクションによって成り立っており，Anti-Debuggingについては考えられていない．そのためPinは，親プロセス，引数，ロードされるpinvm.dll, エクスポート関数である<code>CharmVersionC</code>, <code>ZwAllocateVirtualMemory</code>の実行権限，<code>KiUserApcDispatcher</code>, <code>KiUserCallbackDispatcher</code>, <code>KiUserExceptionDispatcher</code>, <code>LdrInitializeThunk</code>のインラインフック，命令のパターン，セクション名，<code>FSTENV</code>命令，<code>FSAVE</code>命令，<code>FXSAVE</code>命令，……といった様々な要素から検出される危険性を孕んでいる．<br>これらは，<a href="http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=view&amp;type=tool&amp;name=eXait" target="_blank" rel="external">eXait</a>を用いてテストできる．なお，筆者の環境では<code>int2e</code>/<code>SYSENTER</code>についてfalse positiveが発生した．<br>Pinを検出するマルウェアの存在は寡聞にして知らないが，Pinをマルウェア解析に用いるのであれば，現状の構造は不適切である．<br>Anti-Debuggingのイタチごっこから脱するためには，エージェントをゲストOSに挿入するin-VMではなく，エージェントをゲストOSに挿入しないout-of-VMな解析環境でなければならない．</p>
<h1 id="QEMU">QEMU</h1><p>さらにPinにはカーネルへのinstrumentationが不可能であるという欠点が存在する．<br>翻って<a href="https://github.com/qemu/qemu" target="_blank" rel="external">QEMU</a>は，フルシステムエミュレーションを行うため，アーキテクチャに依存することなくカーネルへのinstrumentationを行うことができる．しかしながら，QEMUのソースコードは難解であり，PinのようにユーザーフレンドリーなAPIが提供されていない．QEMUはC言語によるメタプログラミングとオブジェクト指向の良質なサンプルであるとも言えるが，できることなら避けて通りたい道である．</p>
<h1 id="TEMU">TEMU</h1><p>QEMUにテイント解析機能を搭載し，これまで多くの研究で用いられてきた<a href="http://bitblaze.cs.berkeley.edu/temu.html" target="_blank" rel="external">TEMU</a>は，QEMUのソースコードを理解するための労力を削減することに成功した（と，後述するPEMUの論文にすら書かれている）が，APIの充実度はPinに劣っている．また，カーネルモジュールをゲストOSに挿入する必要があり，マルウェアから検出される可能性があること，いまや時代遅れのQEMU 0.9.1をベースとしていることから，現代的なマルウェア解析環境の候補からは外れつつある．<br>後継の<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="external">DECAF</a>はQEMU 1.0.0をベースとしており，カーネルモジュールを必要としないものの，APIの充実度はTEMUと変わらない．</p>
<h1 id="PEMU">PEMU</h1><p>こうした流れを汲んで開発されたのが，VEE’15にて新たに発表された<a href="https://github.com/utds3lab/pemu" target="_blank" rel="external">PEMU</a>である．嬉しい事にオープンソースとして提供されている．<br>Pinはin-VMであり，マルウェアの解析やカーネルへのinstrumentationに適さない．QEMUやTEMUはout-of-VMだが，Pinほど充実したAPIを用いることができない．そこでPEMUは，両者の利点と欠点を踏まえた上で，以下の四点を目的として開発された．</p>
<ol>
<li>Rich APIs<ul>
<li>Pinの既存APIをそのまま流用できること</li>
</ul>
</li>
<li>Cross-OS<ul>
<li>WindowsとLinuxをサポート</li>
</ul>
</li>
<li>Strong Isolation<ul>
<li>ゲストOSのRing 3やRing 0ではなく，out-of-VM(Ring -1)から監視(VM Introspection)を行うこと</li>
</ul>
</li>
<li>VM Introspection<ul>
<li>ゲストOSのプロセスやカーネルのセマンティクス情報を取得するAPIを提供すること</li>
</ul>
</li>
</ol>
<p>これらを達成するため，PEMUはQEMUの動的バイナリ変換器Tiny Code Generator(TCG)に手を加えてPin APIのサポートを追加した．</p>
<h2 id="Instrumentation_Engine">Instrumentation Engine</h2><p>さて，PEMUにおけるinstrumentationはどのようになっているのだろうか．<br>問題となるのは，QEMUとPinとの差異である．QEMUは命令とBB単位でしかinstrumentできず，PinにおけるTrace単位をサポートしていない．また，PEMUのベースとなっているQEMU 1.5.3では，BBの数が640までと制限されている．<br>そこで，PEMUではBBとTraceを対応付けるTRACE Constructorと，PinのAPIを通じてinstrumentするCode Injectorが導入された．</p>
<h3 id="TRACE_Constructor">TRACE Constructor</h3><p>TRACE Constructorは，複数のBBを組み合わせてTraceの単位に抽象化するものである．<br>まずXED2ライブラリを用いて，ゲストの実行前にQEMUでBBの先頭から条件分岐命令まで逆アセンブルを行う(<code>/target-i386/PEMU/DISAS.c</code>)．スワップされたか，ロードされていない命令については，ページフォルトを通じて取得する．さらに，コードを挿入する命令の位置をglobal hooking point hash-table(HPHT)にキャッシュする(<code>/target-i386/PEMU/hashTable.c</code>)．<br>ここにおけるアルゴリズムは以下のようになっている．</p>
<p><img src="/image/pemu_algorithm.png"></p>
<p>まず，Trace単位の開始アドレスであるPCの度にXED2を呼び出し，PCをTPCという保存領域に保存する．次に，全命令を逆アセンブルし，命令単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．さらに，無条件分岐の度にBBとTraceを対応付け，BB単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．そして，新しいBBを割り当て，次のTrace単位が始まるアドレスを探す．Trace単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．そして，さらなるTraceを逆アセンブルしていくといった仕組みになる．</p>
<h3 id="Code_Injector">Code Injector</h3><p>TraceとBBの対応が取れた後は，QEMUのTCGが提供する<code>tcg_gen_helper</code>を用いてHPHTを参照し，instrumentを行えばよい（<code>/target-i386/PEMU/pemu_hook_helper.c</code>）．<br>IMGやSEC単位のinstrumentは<code>malloc</code>などの引数を確認する（セマンティクス情報を復元する）ことで実現している．<br>全体像は以下のようになる．</p>
<p><img src="/image/pemu_engine.png"></p>
<h2 id="Introspection_Engine">Introspection Engine</h2><p>PEMUでは，Page Global Directory(PGD)とCR3レジスタの対応を用いてプロセスの識別を行う(<code>target-i386/PEMU/pemu_helper.h</code>)．ここでは，プロセス作成時に発生するCR3レジスタへの<code>MOV</code>を検出して利用する．終了したプロセスのCR3は再利用されるため，プロセスの終了を検出する必要があるが，これは<code>exit</code> syscallを監視することで実現できる．スレッドは，kernel stack pointerのマスクから識別する．<br>ゲストとのセマンティックギャップの解決にあたっては，一時的にゲストを停止してシステムコールを挿入する手法を用いる．<code>PEMU_</code>というprefixでsyscallに相当するAPIが提供され，<code>getpid</code>, <code>gettimeofday</code>などゲストOSの情報を取得するためのAPI 28種類と，<code>open</code>, <code>fstat</code>, <code>lseek</code>などゲストOSを操作するためのAPI 15種を用いることができる．これらは都度レジスタコンテキストの退避と復元を伴って実行される．</p>
<h2 id="評価">評価</h2><p>論文での性能評価では，32-bit Ubuntu 12.04(Linux kernel 3.0.0-31-generic-pae)をホストとし，Intel Core i7, メモリ8GBのマシンが用いられた．速度の評価には32-bit Ubuntu 11.04(Linux kernel 2.6.38-8-generic)がゲストとして用いられた．<br>その結果として，PEMUではQEMUよりも4.33倍，Pinよりも83.61倍のオーバーヘッドが生じることが明らかになっている．</p>
<p><img src="/image/pemu_performance.png"></p>
<p>また，eXaitを用いた検出テストのため，Windows XP 32bitがゲストとして用いられた．論文ではeXaitの17手法全てがPinを検出した一方で，いずれの手法もPEMUを検出することができなかった．</p>
<h2 id="関連研究">関連研究</h2><p>PEMUがQEMUにPin APIのサポートを追加したのに対して，<a href="http://dl.acm.org/citation.cfm?id=1254830" target="_blank" rel="external">PinOS</a>はXenにPin APIのサポートを追加した．だがPinOSのinstrumentationは貧弱であり，セマンティクス情報を取得するAPIが提供されていない．また，解析ルーチンがカーネルや解析対象からアクセスできるため，isolationとして不十分である．<br>また，PinOS以外にカーネルへのinstrumentationをサポートしている<a href="https://github.com/DynamoRIO/drk" target="_blank" rel="external">DRK</a>は，LKMとして実装されているため，in-VMな手法に留まっている．</p>
<h1 id="おわりに">おわりに</h1><p>こうして，Pin APIを用いてout-of-VMにマルウェアを解析するための道標が示された．<br>今後のPEMUを用いた研究に期待したい，と他人事のように言っている場合ではなく，そろそろ論文を書かなければ．</p>
<h1 id="補足">補足</h1><p>PEMUは新しいといえどQEMU 1.5.3をベースとしており，やがてはQEMU 0.9.1をベースとしているTEMUのように技術的負債となるだろう．<br>そこで，PEMUを<a href="https://github.com/ntddk/pemu" target="_blank" rel="external">forkし</a>，<a href="https://github.com/ntddk/pemu/commit/af5bf0b7a3efcbb7c4b21abbfba0da02f034f95a" target="_blank" rel="external">QEMU 1.5.3からQEMU 2.2.1にアップデートを試みた</a>．が，QEMU 2.2.1に至るまで<code>cpu_single_env</code>変数が廃止されたことと，謎のコンパイルエラーが発生することから頓挫中である．そのうち何とかする．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi and Kim Hazelwood,<br>“<a href="http://www.cs.virginia.edu/kim/courses/cs851/papers/luk05pin.pdf" target="_blank" rel="external">Pin: building customized program analysis tools with dynamic instrumentation[PDF]</a>,”<br>In Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation, PLDI’05, pp. 190–200, 2005.</li>
<li>Francisco Falcón, Nahuel Riva,<br>“<a href="http://recon.cx/2012/schedule/events/216.en.html" target="_blank" rel="external">Dynamic Binary Instrumentation Frameworks: I know you’re there spying on me</a>,”<br>RECon 2012.</li>
<li>Junyuan Zeng, Yangchun Fu, and Zhiqiang Lin,<br>“<a href="http://dl.acm.org/citation.cfm?id=2731201" target="_blank" rel="external">PEMU: A Pin Highly Compatible Out-of-VM Dynamic Binary Instrumentation Framework</a>,”<br>In Proceedings of the 11th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments, pp. 147-160, VEE’15, 2015.</li>
<li>Prashanth P. Bungale, Chi-Keung Luk,<br>“<a href="http://dl.acm.org/citation.cfm?id=1254830" target="_blank" rel="external">PinOS: a programmable framework for whole-system dynamic instrumentation</a>,”<br>In Proceedings of the 3rd international conference on Virtual execution environments, VEE’07, pp. 137-147, 2007.</li>
<li>Peter Feiner, Angela Demke, and Ashvin Goel,<br>“<a href="http://dl.acm.org/citation.cfm?id=2150992" target="_blank" rel="external">Comprehensive Kernel Instrumentation via Dynamic Binary Translation</a>,”<br>In Proceedings of the 17th international conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS’12, pp. 135-146, 2012.</li>
<li>Yangchun Fu, Junyuan Zeng, and Zhiqiang Lin,<br>“<a href="https://www.usenix.org/conference/atc14/technical-sessions/presentation/fu" target="_blank" rel="external">HYPERSHELL: A Practical Hypervisor Layer Guest OS Shell for Automated In-VM Management</a>,”<br>In Proceedings of the 2014 USENIX conference on USENIX Annual Technical Conference, USENIX ATC’14, pp. 85-96, 2014.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/04/03/pin-to-pemu/" data-id="cipa8jbo60019xsosvuwv33bt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sandbox-transparency" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/01/23/sandbox-transparency/">サンドボックスの透明性</a>
  

      </header>
    
    <time class="article-date" datetime="2015-01-23T14:45:59.000Z" itemprop="datePublished">01-23-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="VMI">VMI</h1><p>仮想マシンモニタからゲストのリソースを監視・制御する技術をVMI(Virtual Machine Introspection)という．<br>その発祥は2003年に遡る．当時はハニーポットの研究が盛んな時期であり，VMIは仮想マシンにおける侵入検知を実現する手法として提案された．これはマルウェア解析の自動化に応用されており，仮想マシンモニタによるサンドボックスを構築し，VMIによってマルウェアの挙動を監視するというアプローチが一般的となっている．<br>さて，VMIにおける問題点にセマンティックギャップというものがある．原義は高級言語とハードウェアとの乖離であるが，OSと同じ粒度で情報を取得することのできるゲスト内部(in-the-box)とハードウェアの粒度で情報を取得することしかできないゲスト外部(out-of-the-box)の乖離という意味でも援用される．</p>
<h1 id="Transparent_Sandbox">Transparent Sandbox</h1><p>セマンティックギャップを解決する方法として，ゲスト内部にエージェントを挿入し，仮想マシンモニタに情報を送信するというアプローチが考えられる．<br>だがマルウェア解析において，ゲスト内部にエージェントを挿入することは，自らの姿を曝け出していることにほかならない．ファイルやサービス名，フックによって変化するAPIの挙動といったものは，マルウェアがエージェントと同じ権限で動作する限り避けられない．そもそも仮想マシンモニタは特権を有していたところで<code>RDTSC</code>や<code>ICEBP</code>などの命令，あるいはハードウェア名やIDTといった要素から検出される可能性を孕んでいる．そのため，ゲスト内部にエージェントを挿入することは，仮想マシンモニタがマルウェアから検出される可能性を高めることに繋がる．フォレンジックにおける完全性(integrity)のためにも，ゲスト内部にエージェントを挿入すべきではないと私は考える．<br>この議論に関して，マルウェアから検出されない仮想マシンモニタをtransparent sandbox（透明なサンドボックス？）といい，仮想マシンモニタの検出を試みるマルウェアをevasive malwareという．<br>ではどのような仮想マシンモニタがより「透明」に近いのか．</p>
<h1 id="仮想マシンモニタの歴史">仮想マシンモニタの歴史</h1><p>ここでPopekとGoldbergの仮想化要件に立ち返ると，ベアメタルな仮想マシンモニタは等価性(equivalence)，資源管理(resource control)，効率性(efficiency)の三原則を実現しており，なおかつユーザセンシティブ命令が特権命令でなければならない．センシティブ命令かつ特権命令でなければ，例外によって仮想マシンモニタに通知することができないためである．<br>だが，以前のx86アーキテクチャはこの要件を満たしていなかった．そこで，ニ種類の解決方法が編み出された．<br>一つ目はバイナリ変換(binary translation)による完全仮想化である．これはソフトウェアで命令をエミュレートする手法で，QEMUやVMwareが該当する．QEMUは全ての命令を中間コードに変換するのに対し，VMwareはPopekとGoldbergの仮想化要件を満たさない命令をライブラリ呼び出しに変換する．<br>二つ目は準仮想化である．これはPopekとGoldbergの仮想化要件を満たさない命令に差し掛かると仮想マシンモニタに通知されるようゲストOSのカーネルを修正する手法で，Xenが該当する．<br>ではバイナリ変換による完全仮想化とカーネル書き換えによる準仮想化のどちらがより「透明」に近いのか．<br>その前にIntel VT-xについて考えなければならない．Intel VT-xはCPUのモード切り替えによってセンシティブ命令かつ特権命令でない命令のトラップを実現する拡張機能である．すなわちPopekとGoldbergの仮想化要件を満たすハードウェア側からのアプローチである．これにより準仮想化カーネルの必要はなくなった．エージェントの挿入が「透明」性に関わるのと同様，カーネルの書き換えは仮想マシンモニタを検出する手掛かりとなる．<br>そのためマルウェア解析においては，バイナリ変換による完全仮想化か，Intel VT-xによる完全仮想化が前提となる．なおKVMはIntel Vt-xを前提としているが，部分的にQEMUを用いている．<br>ではどちらの手法がより「透明」に近いのか．</p>
<h1 id="バイナリ変換とIntel_VT-x">バイナリ変換とIntel VT-x</h1><p>Christopher KruegelはWineのようなシステムコール単位のエミュレーションあるいはフックは情報量として不十分であり，またIntel VT-xによる完全仮想化はRedPillのようなアプローチで検出可能であることから，バイナリ変換による完全仮想化すなわちQEMUを支持している．<br>システムコール単位の監視は<code>IsDebuggerPresent</code>のようなカーネルモードに遷移せず構造体を参照するだけの処理を見逃してしまう．システムコールのフックを用いた研究や製品は多数存在するが，それらは不完全である．この点で私は氏と意見を一にするが，バイナリ変換がより「透明」に近いかどうかは検討の余地があるだろう．寧ろ氏は実行パスの拡張がより容易に行えるがゆえにバイナリ変換を支持しているのだろうということは読み取れるが，氏がチーフサイエンティストを務めるLastlineの製品がQEMUをベースとしていることもあり，些かポジショントークのようにも感じられる．<br>このような論調でバイナリ変換とIntel VT-xを二項対立の図式に落とし込んでいる論文が数多く見られる．しかし，どちらがより「透明」に近いのかという議論はナンセンスであろう．<br>ゲスト内部にエージェントを挿入することで，果たして本当にマルウェアから検出されやすくなるのかと言うと，それは飽くまで可能性でしかない．だがゲスト内部にエージェントを挿入しないという選択で，その問題は検討項目から外すことができる．一方で，バイナリ変換であるという理由でIntel VT-xを用いた仮想マシンモニタよりも検出されにくいといったことはない．逆もまた然りである．<br>そしてそもそも，ネットワーク経由で仮想マシンモニタを検出するという手法がある以上，完全に「透明」なサンドボックスは実現不可能であるとされる．<br>ゆえにそれぞれのアプローチについて「透明」性の他にもメリット・デメリットを検討し，なおかつ両者を接合するようなシステムこそが望ましい．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Tal Garfinkel, Mendel Rosenblu,<br>“<a href="http://suif.stanford.edu/papers/vmi-ndss03.pdf" target="_blank" rel="external">A Virtual Machine Introspection Based Architecture for Intrusion Detection[PDF]</a>,”<br>Proceedings of the 10th Annual Network and Distributed System Security Symposium, pp. 191–206, SD, USA, 2003.</li>
<li>Gerald J. Popek, Robert P. Goldberg,<br>“<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.141.4815&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Formal Requirements for Virtualizable Third Generation Architectures[PDF]</a>,”<br>Communications of the ACM CACM Homepage archive, Vol. 17, Issue. 7, pp. 412-421, NY, USA, 1974.</li>
<li>John Scott Robin, Cynthia E. Irvine,<br>“<a href="http://www.cse.psu.edu/~bhuvan/teaching/spring06/papers/analysis-pentium.pdf" target="_blank" rel="external">Analysis of the Intel Pentium’s Ability to Support a Secure Virtual Machine Monitor[PDF]</a>,”<br>Proceedings of the 9th conference on USENIX Security Symposium, Vol. 9, pp. 10-10, CA, USA, 2000.</li>
<li>Christopher Kruegel,<br>“<a href="https://www.blackhat.com/docs/us-14/materials/us-14-Kruegel-Full-System-Emulation-Achieving-Successful-Automated-Dynamic-Analysis-Of-Evasive-Malware-WP.pdf" target="_blank" rel="external">Full System Emulation: Achieving Successful Automated Dynamic Analysis of Evasive Malware[PDF]</a>,”<br>Black Hat USA, 2014.</li>
<li>Tal Garfinkel, Keith Adams, Andrew Warfield and Jason Franklin,<br>“<a href="http://www.cs.cmu.edu/~jfrankli/hotos07/vmm_detection_hotos07.pdf" target="_blank" rel="external">Compatibility is Not Transparency: VMM Detection Myths and Realities[PDF]</a>,”<br>Proceedings of the 11th USENIX workshop on Hot topics in operating systems, No. 6, CA, USA, 2007.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/01/23/sandbox-transparency/" data-id="cipa8jbnu0010xsosxx0ipzll" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-v2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/09/v2e/">マルウェア解析におけるRecord and Replayの設計</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-09T09:00:00.000Z" itemprop="datePublished">12-09-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>“という論文を通して，Record and Replayを用いた解析環境の設計を学ぶ．</p>
<h1 id="著者">著者</h1><p>この論文のラストオーサーであるYinはSyracuse Universityの助教である．彼はテイント解析の第一人者として知られ，現在は<a href="https://code.google.com/p/decaf-platform/" target="_blank" rel="external">DECAF</a>の開発を主導している．またBitBlaze ProjectのDawn Songや，マルウェア解析の大御所であるChristopher Kruegelと過去に共著を出している．<br>ファーストオーサーのYanは提案手法をAndroidに適用し，2013年に博士論文を著している．Android向けの拡張にあたっては，DECAFのサブプロジェクトであるDroidScopeを用いているようだ．</p>
<h1 id="Record_and_Replay">Record and Replay</h1><p>あるいはLogging and Replay, Lockstep, 順序再演法，最小情報トレースなどと呼ばれるこれらは，仮想マシンモニタ上のイベントを記録し，再生するための技術である．乱暴に言うとhistoryからdockerfileやvagrantfileを作成し，deployするようなものだ．<br>一般にステートマシンにおける命令の出力は，内部状態から一意に与えられる．そこで，ある環境の初期状態と入力のみを記録(Record)し，同じ環境を別の環境の上に再生(Raplay)するといった試みがなされてきた．実マシンにおいては，時刻や割り込みなどの非決定性とその記録の困難性からRecord and Replayは不可能であるとされる．だが，仮想マシンモニタの世界ではこれらの問題をある程度無視できる．実際，VMware Workstationなどにこの機能は実装されている．<br>本論文では，マルウェア解析に求められるサンドボックスの特性を加味したRecord and Replayについて論じられている．かつて大居さん(<a href="https://twitter.com/a4lg" target="_blank" rel="external">@a4lg</a>)が研究されていた内容に近い．</p>
<h1 id="背景">背景</h1><p>マルウェアを解析するためのサンドボックスは検出不可能(transparent)であり，なおかつ拡張可能であるべきだ．<br>いかに仮想マシンモニタの存在を隠蔽しようと，Timing Attackなどが成り立つ以上，transparentなサンドボックスを実現することは不可能である．しかし，Intel VTなどハードウェア仮想化技術を用いることで，ほぼtransparentな環境を作り出すことは可能である．例えば，<a href="http://ether.gtisc.gatech.edu/" target="_blank" rel="external">Ether</a>は命令・システムコール単位の解析機能を備えているが，Xenをベースに高いtransparent性を実現している．<br>だが，ハードウェア仮想化技術に依存した解析環境には拡張性の点で問題がある．特に，instrumentationによる詳細な解析が不可能であるという点は，大きな痛手である．<br>他方，QEMUなどのソフトウェアエミュレーションは動的バイナリ変換を用いることでDBI(dynamic binary instrumentation)と解析効率の向上を実現している．しかし，transparentなサンドボックスには至れない．<br>QEMUの動的バイナリ変換はバイナリをコードブロック単位で変換し，softmmuからTLBを参照してアドレス変換を行うというものだ．<br>そしてその性質から，以下のような自己書き換えコードによって検出されうる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm&#123;&#10;&#9;xor eax, eax&#10;&#9;mov edi, target&#10;&#9;mov esi, copy_insn&#10;&#9;mov ecx, 3&#10;&#10;target:&#10;&#9;rep movsw&#9;&#9;// f3 66 a5&#10;&#9;jmp qemu_found&#9;&#9;// eb XX&#10;&#9;nop&#9;&#9;&#9;// 90&#10;&#10;non_qemu:&#10;&#9;...&#10;&#10;qemu_found:&#10;&#9;...&#10;&#10;copy_insn:&#10;&#9;_emit 0xeb&#9;&#9;// eb&#10;&#9;_emit 0x01&#9;&#9;// 01&#10;&#9;_emit 0x90&#9;&#9;// 90&#10;&#9;_emit 0xeb&#10;&#9;_emit 0x01&#10;&#9;_emit 0x90&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>実マシンでは，<code>ecx*word=6</code>バイトが1回で書き換わるが，QEMUの動的バイナリ変換では2バイトずつ3回で書き換わる．そのため，1回目の書き換えで<code>0xeb 0x01 0xa5</code>すなわち<code>jmp +01</code>になってしまい，<code>qemu_found</code>にジャンプしてしまう．<br>その他には，ページ境界を越えてブロックの変換が行われた場合にページフォルトが発生してしまうことも考えられるし，ブロック境界でのみ割り込みが行われる，CPUサイクルの消費が著しいといった実マシンとの相違点もある．<br>さらに問題なのが，フラグの遅延評価だ．例えば，<code>cmp</code>と<code>jz</code>の組み合わせなどの条件分岐は，EFLAGSを更新する．だが，QEMUにおいては<code>cmp</code>が実行される段階でEFLAGSの計算は行われない．実際に計算されるのは<code>jz</code>の実行時，それも分岐を決定するためのZFのみが計算される．この設計はエミュレーションの高速化に寄与しているが，もちろん検出に用いることが可能だ．<br>当然ながら命令のエミュレーション自体にも限界がある．SIMDさえ厳しいのだ，システム管理モードやIntel TXTなんてものは考えたくないだろう．<br>このように，QEMUによるエミュレーションが検出される余地は枚挙に暇がない．<br>なお，解析環境検出をテーマとした最近の研究では，第2回システム系論文輪読会で<a href="http://ntddk.github.io/barecloud/">紹介した</a>BareCloudや忠鉢さん(<a href="https://twitter.com/yuzuhara" target="_blank" rel="external">@yuzuhara</a>)のTENTACLEなどがある．</p>
<h1 id="研究目的">研究目的</h1><p>ハードウェア仮想化技術を用いる解析環境とソフトウェアエミュレーションを用いる解析環境にはそれぞれ問題がある．そこで，ハードウェア仮想化技術を用いる解析環境でRecordを行い，ソフトウェアエミュレーションを用いる解析環境でReplayを行うことで，検出不可能性と拡張可能性という二つの目的について達成したのが，今回紹介するV2Eである．</p>
<h1 id="形式的定義">形式的定義</h1><p>本論文におけるRecord and Replayの設計はどのようなものか．<br>Recorderにおける遷移関数<code>f</code>について，毎時<sub><code>i</code></sub>におけるプログラムの状態を<code>S</code><sub><code>i</code></sub>とし，入力を<code>I</code><sub><code>i</code></sub>とする．すなわち<code>f</code>は<code>S</code><sub><code>i</code></sub><code>= f(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と表される．<br>次にReplayerにおける遷移関数<code>f&#39;</code>についてプログラムの初期状態を<code>S</code><sub><code>0</code></sub>とし，全ての入力を<code>I</code>としたとき，<code>f = f&#39;</code>と言えないだろうか．<br>これは二つのチューリング機械の同値性が解決可能であるかという問題に相当する．だが<code>EQ</code><sub><code>TM</code></sub><code>= {(M</code><sub><code>1</code></sub><code>, M</code><sub><code>2</code></sub>)<code>|M</code><sub><code>1</code></sub><code>とM</code><sub><code>2</code></sub><code>はTMであり，L(M</code><sub><code>1</code></sub><code>) = L(M</code><sub><code>2</code></sub><code>)}</code>は判定不可能とされ（『計算理論の基礎』における定理5.4），実装上でもハードウェアの割り込みなどの要因から<code>f != f&#39;</code>となってしまう．<br>そこでV2Eは，プログラムの初期状態と全ての入力を保存することに加え，<code>S</code><sub><code>j</code></sub><code>= S&#39;</code><sub><code>j</code></sub>となるような<sub><code>j</code></sub>について状態の変化を保存することにした．これは<code>⊿</code><sub><code>j</code></sub><code>= S</code><sub><code>j</code></sub><code>- S</code><sub><code>j-1</code></sub>と表される．<br>ここで，新たな遷移関数<code>f&#39;</code><sub><code>r</code></sub>を<code>S&#39;</code><sub><code>i</code></sub><code>= f&#39;</code><sub><code>r</code></sub><code>(S&#39;</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>, ⊿</code><sub><code>i</code></sub><code>)</code>として定義する．これは，<code>⊿</code><sub><code>i</code></sub><code>!= null</code>のとき<code>S&#39;</code><sub><code>i-1</code></sub><code>+ ⊿</code><sub><code>i</code></sub>と同値であり，それ以外について<code>f&#39;(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と同値をとる．<br>なお，<code>S</code><sub><code>0</code></sub>, <code>I</code>, <code>⊿</code>および<code>f&#39;</code><sub><code>r</code></sub>, <code>S&#39;</code><sub><code>i</code></sub><code>= S</code><sub><code>i</code></sub>は<code>i ∈ [0, n]</code>について恒真である．<br>これを実装に起こすと，特定の命令やイベントが正しくエミュレート可能な場合は単にそれらをエミュレートし，そうでなければ状態の変化を記録し，Replayにあたって変更を適用するというアプローチになる．</p>
<h1 id="理論と実際">理論と実際</h1><p>プログラムの大部分を占める<code>mov</code>, <code>push</code>, <code>pop</code>などのデータ転送命令，<code>call</code>, <code>ret</code>, <code>jz</code>, <code>jmp</code>などの制御転送命令，<code>add</code>, <code>shl</code>などの整数演算命令におけるエミュレーションは失敗しないものと見做せる．これらはそのままRecorderでエミュレートされる．<br>一方で，割り込み，MMIO, Port IO, DMA, TSCについては，V2Eは既存研究を踏襲し，監視領域においてのみこれらをRecordするようになっている．<br>では，例外，モデル固有レジスタ，<code>cpuid</code>はどうすべきだろうか．既存手法は，これらのエミュレーションは困難であるという理由から，そもそも入力として扱わない戦略を採っていたようだ．V2Eではこれらを<code>⊿</code>, すなわちエミュレートが困難な状態の変化としてRecordすることで，Replayの正確性を高めている．<br>次に問題となるのが浮動小数点演算とSIMDの扱いだ．MMXやSSEを正確にエミュレートするのは難しい．だが，<code>⊿</code>として命令の結果を記録する設計は大幅なパフォーマンスの低下を招く．そこでV2EはReplayにあたってこれらの命令をパススルーする．もちろん，ReplayerはSIMDをサポートしているマシンで実行されることが前提にある．</p>
<h1 id="Transparent_Recorder">Transparent Recorder</h1><p>RecorderはKVMを用いて実装されている．<br>V2EはRecord対象の領域とそれ以外のシステムを分割するため，TDP(two dimensional paging)を用いている．何のことかと思ったら，Intel EPTやAMD NPTの総称らしい．<br><img src="/image/tdp.jpg"><br>要するに，TDPとは仮想マシンと物理マシン間のページテーブルのことだ．通常のページングでは，メモリアクセスに応じてMMUによってページテーブルが参照され，仮想アドレスが物理アドレスへと変換される．TDPでは，ゲストマシンからの仮想メモリ空間へのアクセスに応じてCR3にセットされたページテーブルが参照され，ゲスト物理アドレスがホスト物理アドレスへと変換される．<br>この仕組を用いたV2Eは，<strong>監視対象用のTDPテーブルと，それ以外用のTDPテーブルを別々に作成する</strong>．マルウェアに属するページはCR3の監視に基づき監視対象用のTDPテーブルに書き込まれる．マルウェアとそれ以外の部分のインタラクションはTDPページフォルトや<code>VMExit</code>によって媒介される．共有されるデータは読み取り専用として双方に与えられる．なお，TDPページフォルトに応じてCPUの状態が入力<code>I</code><sub><code>i</code></sub>として保存される．</p>
<h1 id="Precise_Replayer">Precise Replayer</h1><p>ReplayerはTEMUを用いて実装されている．バイナリ変換器に中間表現がなく，単純に古いQEMU 0.9.1をベースとしているのが玉に瑕だが，TEMUは動的テイント解析に求められる機能をほぼ網羅している．<br>TEMUはプラグインを共有ライブラリとしてロードし，コールバック関数からテイント解析の機能を呼び出すプラットフォームとなっている．V2EのReplayerは既存のプラグインであるtracecap, unpackerを用いる．だがRecordされたログには監視対象の情報のみが記述されているため，<br><code>return ((*TEMU_cpu_hflags &amp; HF_CPL_MASK) != 3)</code>といった，現在実行しているコードが解析対象のものかどうか判定するコードは除去されているようだ．TEMUのプラグインについては，こうした僅かな変更しか施されていない．<br>一方でその下で動くQEMUには結構手が加えられている．フラグの遅延評価は廃止され，ページフォルト以外の例外は除去されており，SIMDについては独自のヘルパー関数が追加されたようだ．QEMUのdyngenに手を加えるのはなかなか骨の折れる作業だと思う．<br>さて，Replayを行うためには，ReplayerはRecorderと同様のページングの仕組みをエミュレーションによって再現しなければならない．そこで，V2Eは物理ページコンテナという仕組みを用いている．これは，物理ページがログからロードされていることを示すものである．通常，物理ページコンテナは監視対象用のTDPテーブルを複製する．Replayされたプログラムが物理ページコンテナに存在しないページにアクセスした場合，Replayerは適切なタイミングでログからCPUの状態を復元し，ロードするようになっている．<br>V2Eにおけるテイント解析はおそらく，マルウェアのメモリ領域を正確に把握するためのものではない．それは，Recorderの段階でTDPテーブルの分割というアプローチによって実現されるべきものだからだ．TEMUのプラグインを使いたかったのだろうが，論文中からはあまりテイント解析を導入することのメリットが読み取れなかった．ここでのテイント解析は解析環境検出の対策に先立つものとして設定されているのだろうか．</p>
<h1 id="評価">評価</h1><p>解析環境検出については問題なし．<code>cpuid</code>, <code>rdtsc</code>, <code>cmpxch8b</code>, <code>icbp</code>, <code>rep stosb</code>, <code>fnstcw</code>といった命令や，一般保護例外などについてテストされている．なお，<code>rdtsc</code>については<code>VMRESUME</code>前にホストのTSCを参照することで対応している．<br>in-the-wildのマルウェアについても実験が行われており，アンパッカーとして期待できるパフォーマンスを見せている．<br>Recordにおける速度だが，コンテキストスイッチが頻繁に発生するカーネルモードルートキットで17倍，Internet Explorerで5倍と高速だ．KVMのシングルステップモードには3000倍のオーバーヘッドがあると言うのに．<br>全体的にpositiveな結果で，かなり良い．</p>
<h1 id="おわりに">おわりに</h1><p>マルウェアによる解析環境検出に対して，復数の環境を組み合わせたRecord and Replayを用いる研究について紹介した．何より，監視対象とそれ以外で別個にTDPテーブルを作るというアプローチが素晴らしい．自分も研究でテイント解析を扱っているが，この流れを包摂していきたい．<br>ただ，これはサンドボックス全般に言えることなのだが，感染ホストにおけるユーザーのブラウザ操作が条件分岐に影響するMITBマルウェアについて，どう対処すべきなのだろうか．正常系のユーザーのブラウザ操作をデータセットとしてRecorderに与えたいところだが，果たしてどうなるのか．<br>このエントリは<a href="http://www.adventar.org/calendars/440" target="_blank" rel="external">システム系論文紹介 Advent Calendar 2014</a>の9日目として書かれた．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Lok-Kwong Yan, Manjukumar Jayachandra, Mu Zhang and Heng Yin,<br>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>,”<br>Proceedings of the 8th ACM SIGPLAN/SIGOPS conference on Virtual Execution Environments, pp. 227-238, NY, USA, 2012.</li>
<li>George W. Dunlap, Samuel T. King, Sukru Cinar, Murtaza A. Basrai and Peter M. Chen,<br>“<a href="http://web.engr.illinois.edu/~kingst/Research_files/dunlap02.pdf" target="_blank" rel="external">ReVirt: Enabling Intrusion Analysis through Virtual-Machine Logging and Replay[PDF]</a>,”<br>Proceedings of the 2002 Symposium on Operating Systems Design and Implementation, pp. 211-224, NY, USA, 2002.</li>
<li>A. Dinaburg, P. Royal, M. Sharif and W. Lee.<br>“<a href="http://ether.gtisc.gatech.edu/ether_ccs_2008.pdf" target="_blank" rel="external">Ether: malware analysis via hardware virtualization extensions[PDF]</a>,”<br>Proceedings of the 15th ACM Conference on Computer and Communications Security, pp. 51–62, NY, USA, 2008.</li>
<li>大居司,<br>“<a href="http://www.slideshare.net/a4lg/a-new-tracer-for-reverse-engineering" target="_blank" rel="external">リバースエンジニアリングのための新しいトレース手法</a>,”<br>PacSec 2010, 東京, 日本, 2010.</li>
<li>Dhilung Kirat, Giovanni Vigna, and Christopher Kruegel,<br>“<a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kirat.pdf" target="_blank" rel="external">BareCloud: Bare-metal Analysis-based Evasive Malware Detection[PDF]</a>,”<br>Proceedings of the 23rd USENIX conference on Security Symposium, pp. 287-301, CA, USA, 2014.</li>
<li>忠鉢洋輔, 愛甲健二,<br>“<a href="https://pacsec.jp/psj14/PSJ2014_chubachi_final_ja.pdf" target="_blank" rel="external">TENTACLE: Environment-Sensitive Malware Palpation[PDF]</a>,”<br>PacSec Tokyo 2014, 東京, 日本, 2014.</li>
<li>M. Siper,<br>“<a href="http://www.cs.virginia.edu/~robins/Sipser_2006_Second_Edition_Problems.pdf" target="_blank" rel="external">Introduction to the Theory of Computation. International</a>,”<br>Thomson Publishing, 1996.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/09/v2e/" data-id="cipa8jbn5000jxsoss8i49phs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-symexec-s2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/03/symexec-s2e/">選択的シンボリック実行ツールS2E</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-03T14:00:00.000Z" itemprop="datePublished">12-03-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>選択的シンボリック実行について紹介する．</p>
<h1 id="シンボリック実行">シンボリック実行</h1><p>シンボリック実行とは，プログラムに含まれる変数に具体値を入力せず，その代わりとして値を代表するシンボルの操作を通じてプログラムを模擬的に実行し，結果を評価する技術である．シンボリック実行の目的は，コードカバレッジの拡大にある．シンボリック実行は全てのケースに対してforkする，あるいは，条件分岐の制約をもとにテストケースを生成するといった形態でソフトウェアテストに用いられている．<br>ひとまず，以前書いた<a href="http://ntddk.github.io/2014/09/12/symexec-intro/">シンボリック実行に入門しようとした</a>をご覧頂きたい．</p>
<h1 id="選択的シンボリック実行">選択的シンボリック実行</h1><p>選択的シンボリック実行(selective symbolic execution)は，シンボリック実行の弱点を改善すべく<a href="https://github.com/dslab-epfl/s2e" target="_blank" rel="external">S2E</a>にて提案，実装された．<br>シンボリック実行には実行パスにおける計算爆発(path explosion)の問題があった．プログラム中の全ての実行パスを通るための制約はあまりにも多い．そして，<strong>全ての実行パスというのは解析対象の実行パスだけではない</strong>．考えてもみよう，実システムでプログラムを実行した際，プログラムは自身以外の様々なものを呼び出す．呼び出されるlibcなどのライブラリ，そしてカーネルやデバイスドライバ，さらにそのファームウェアは，一体どこまで解析対象における実行パスの分岐に影響を与えるのか．<br>この頭が痛い問題に対応するべく編み出されたのが選択的シンボリック実行，すなわちシンボリック実行を行う範囲の限定である．S2Eはシンボリック実行を行いたい部分以外に具体値(concrete value)を用いることで，解析対象のプログラムだけにシンボリック実行を適用する(concolic testing)．具体的には，S2Eは指定した変数が使用されている部分のみシンボリック実行を適用している．</p>
<h1 id="S2E">S2E</h1><h2 id="動的バイナリ変換">動的バイナリ変換</h2><p>S2Eは，QEMUをベースに開発された．QEMUはエミュレーションを実現するべく，以下のような流れで動的バイナリ変換を行う．</p>
<p>1.ゲストコードの逆アセンブル<br>2.マイクロオペレーションに変換<br>3.コード辞書を参照してホストコードに変換</p>
<p>S2Eはこのコード辞書をLLVM bitcodeに差し替えることで，x86のバイナリをLLVM bitcodeに変換する．そして，変換後のLLVM bitcodeをKLEEに渡すことで，シンボリック実行を行う．<br>このとき，<strong>解析対象の全部分がLLVM bitcodeに変換されるわけではない</strong>．<br><img src="/image/symexec-s2e_01.jpg"><br>指定した変数が使用されている部分のみシンボリック実行を適用すると書いたように，S2Eはシンボル化したデータにアクセスしているか否かによって，解析対象の実行方式を切り替えている．実行方式は以下の二通りだ．</p>
<ol>
<li>具体値にアクセスしている場合，通常通り実行</li>
<li>シンボルにアクセスしている場合，LLVM bitcodeに変換してKLEE上で実行</li>
</ol>
<p>これは，解析対象を多数のコードブロックに分割するというQEMUのバイナリ変換方式に極めて依存している．</p>
<h2 id="S2E_opcodes">S2E opcodes</h2><p>S2Eは独自の拡張命令S2E opcodesを用いてシンボリック実行のための機能をinstrumentする．S2E opcodesは以下のような機能を提供する．</p>
<ul>
<li><code>S2SYM</code>: データのシンボル化</li>
<li><code>S2ENA</code>: 複数パスの実行を有効化</li>
<li><code>S2DIS</code>: 複数パスの実行を無効化</li>
<li><code>S2OUT</code>: デバッグ情報の出力</li>
</ul>
<p>この中身は<code>s2e-x86.h</code>や<code>s2e.h</code>に記述されている．例として<code>S2SYM</code>の実装を見てみよう．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define S2E_INSTRUCTION_COMPLEX(val1, val2)             \&#10;    &#34;.byte 0x0F, 0x3F\n&#34;                                \&#10;    &#34;.byte 0x00, 0x&#34; #val1 &#34;, 0x&#34; #val2 &#34;, 0x00\n&#34;      \&#10;    &#34;.byte 0x00, 0x00, 0x00, 0x00\n&#34;&#10;&#10;#define S2E_INSTRUCTION_SIMPLE(val)                     \&#10;    S2E_INSTRUCTION_COMPLEX(val, 00)&#10;&#10;~ &#30053; ~&#10;&#10;static inline void s2e_make_symbolic(void *buf, int size, const char *name)&#10;&#123;&#10;    __s2e_touch_string(name);&#10;    __s2e_touch_buffer(buf, size);&#10;&#10;    __asm__ __volatile__(&#10;        S2E_INSTRUCTION_SIMPLE(03)&#10;        : : &#34;a&#34; (buf), &#34;d&#34; (size), &#34;c&#34; (name) : &#34;memory&#34;&#10;    );&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>例えば，解析対象のソースコード上で<code>s2e_make_symbolic()</code>の引数にシンボル化したい変数を渡すことで，この関数を利用することができる．</p>
<h2 id="Windowsデバイスドライバに対する選択的シンボリック実行">Windowsデバイスドライバに対する選択的シンボリック実行</h2><p><a href="https://dslabredmine.epfl.ch/embedded/s2e/Windows/DriverTutorial.html" target="_blank" rel="external">Analyzing Windows Drivers: Step-by-Step Tutorial</a>という公式チュートリアルでは，プラグインを用いてWindowsデバイスドライバにアノテーションを付加する方法が紹介されている．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function annotation_example(state, plg)&#10;   -- Write custom Lua code here (e.g., to inject symbolic values)&#10;end&#10;&#10;pluginsConfig.Annotation =&#10;&#123;&#10;    init1 = &#123;&#10;        active=true,&#10;        module=&#34;pcntpci5_sys_1&#34;,&#10;        address=0x169c9,&#10;        instructionAnnotation=&#34;annotation_example&#34;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>チュートリアルの例ではpcntpci5.sysというドライバが0x169c9というアドレスを呼び出す際に<code>annotation_example()</code>が実行される．BSoDもフックできるので，NotMyFaultドライバで遊ぼう．</p>
<h2 id="オーバーヘッド">オーバーヘッド</h2><p>いつだって問題となるのは実行速度だ．論文によると，S2Eは具体値による実行時(concrete mode)にQEMUの6倍，シンボリック実行時にQEMUの78倍のオーバーヘッドが生ずるとされている．注意したいのは，実機の78倍ではなくQEMUの78倍である点だ．</p>
<h1 id="おわりに">おわりに</h1><p>S2Eについて紹介した．<br>このエントリは<a href="http://connpass.com/event/9500/" target="_blank" rel="external">ソフトウェアテストあどべんとかれんだー2014</a>の3日目として書かれた．</p>
<h1 id="参考文献">参考文献</h1><p>より詳しくは以下の論文を参照されたい．これも全てVitaly Chipounovって奴の仕業なんだ．</p>
<ul>
<li>Vitaly Chipounov, George Candea,<br>“<a href="http://infoscience.epfl.ch/record/149975/files/x86-llvm-translator-chipounov_2.pdf" target="_blank" rel="external">Dynamically Translating x86 to LLVM using QEMU[PDF]</a>,”<br>Technical Report EPFL-TR-149975, Ecole Polytechnique Fédérale de Lausanne, Switzerland, March 2010.</li>
<li>Volodymyr Kuznetsov, Vitaly Chipounov, George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/ddt.pdf" target="_blank" rel="external">Testing Closed-Source Binary Device Drivers with DDT[PDF]</a>,”<br>Proceedings of the 2010 USENIX conference on USENIX annual technical conference, pp.12-12, Boston, MA, June 2010.</li>
<li>Vitaly Chipounov, Volodymyr Kuznetsov, George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/s2e.pdf" target="_blank" rel="external">S2E: a platform for in-vivo multi-path analysis of software systems[PDF]</a>,”<br>Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems, pp.265-278, Newport Beach, CA, March 2011.</li>
<li>Vitaly Chipounov, Volodymyr Kuznetsov George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/s2e-tocs.pdf" target="_blank" rel="external">The S2E Platform: Design, Implementation, and Applications[PDF]</a>,”<br>ACM Transactions on Computer Systems, Volume 30, Issue 1, Article No. 2, February 2012.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/03/symexec-s2e/" data-id="cipa8jbna000oxsoshyjamxxn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vine-howto" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/28/vine-howto/">Vineを動かす</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-27T20:56:08.000Z" itemprop="datePublished">09-28-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>ここでは，<a href="http://bitblaze.cs.berkeley.edu/" target="_blank" rel="external">BitBlaze</a>のうち，静的解析に特化したコンポーネントであるVineを動かしてみる．</p>
<h1 id="BitBlaze">BitBlaze</h1><p>BitBlazeはDawn Songらによるバイナリ解析プラットフォームで，2008年に<a href="http://bitblaze.cs.berkeley.edu/papers/bitblaze_iciss08.pdf" target="_blank" rel="external">BitBlaze: A New Approach to Computer Security via Binary Analysis [PDF]</a>が発表されて以来，数多くの研究に用いられてきた．BitBlazeは，動的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/temu.html" target="_blank" rel="external">TEMU</a>，静的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/vine.html" target="_blank" rel="external">Vine</a>，動的シンボリック実行コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/rudder.html" target="_blank" rel="external">Rudder</a>から構成される．このうち，TEMUとVineのソースコードが公開されている．</p>
<h2 id="TEMU:_The_BitBlaze_Dynamic_Analysis_Component">TEMU: The BitBlaze Dynamic Analysis Component</h2><p>TEMUはQEMUをベースとしたエミュレータで，テイント解析(taint analysis)の機能を備えている．テイント解析とは，タグを設定したデータの伝搬を追跡することで，データ同士の依存関係を解析する技術である．TEMUはtracecapというプラグインを用いて，ゲストOS上で動作するアプリケーションのトレースログを取得することができる．</p>
<h2 id="Vine:_The_BitBlaze_Static_Analysis_Component">Vine: The BitBlaze Static Analysis Component</h2><p>Vineは，逆アセンブリやTEMUのトレースファイルから，中間表現VineILや最弱事前条件，STP formulaなどを出力する．公開されているVineには，TEMU/tracecapのトレースファイルとしてfive.traceが同梱されている．これを例にVineの機能を見てみよう．</p>
<h1 id="Vineのインストール">Vineのインストール</h1><p><a href="http://bitblaze.cs.berkeley.edu/release/vine-1.0/howto.html" target="_blank" rel="external">Vine installation and user manual</a>の通り．OCamlで記述されているため，関連のパッケージを導入する必要がある．また，32bit環境での動作を前提としている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ ocaml ocaml-findlib libgdome2-ocaml-dev camlidl \ &#10;                     libextlib-ocaml-dev ocaml-native-compilers \ &#10;                     libocamlgraph-ocaml-dev binutils-dev texlive \ &#10;                     texlive-latex-extra transfig hevea</span><br></pre></td></tr></table></figure>
<h1 id="trace_reader">trace_reader</h1><p>TEMU/tracecapが出力するトレースファイルはhuman-readableではなく，閲覧はVineのtrace_readerを介して行う必要がある．five.traceでは，T1がタグの識別子となっており，T0はデータに設定されたタグが存在しないことを意味する．なお，ここではキーボードからの入力にタグが設定されている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../trace_utils/trace_reader -trace five.trace | grep T1 | head -n 20&#10;42075911:&#9;movzbl (%eax),%eax&#9;R@eax[0x40014000][4]&#9;T0&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077e0c:&#9;cmp    $0xffffffff,%eax&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077e14:&#9;movzbl (%edx),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205abc5:&#9;mov    %eax,-0xac(%ebp)&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff69c[0x00000000][4]&#9;T0&#10;4205abce:&#9;mov    -0xa8(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff6a0[0x00000000][4]&#9;T0&#10;4205abd5:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205abf5:&#9;mov    -0xac(%ebp),%edx&#9;R@edx[0x40014001][4]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac0b:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac14:&#9;movzbl -0xac(%ebp),%eax&#9;R@eax[0x42130b80][4]&#9;T0&#9;M@0xbffff69c[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac24:&#9;push   %eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff604[0x4213030c][4]&#9;T0&#10;4205ac25:&#9;mov    0x8(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff750[0x4212d980][4]&#9;T0&#10;4207793a:&#9;mov    0xc(%ebp),%edx&#9;R@edx[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff604[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077945:&#9;cmp    %dl,-0x1(%eax)&#9;R@dl[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077974:&#9;movzbl %dl,%eax&#9;R@dl[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;R@eax[0x40014000][4]&#9;T0&#10;42077960:&#9;cmp    $0xffffffff,%eax&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac39:&#9;movzbl -0x9d(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff6ab[0x00000064][1]&#9;T0&#10;4205c550:&#9;mov    $0xa,%edx&#9;I@0x00000000[0x0000000a][4]&#9;T0&#9;R@edx[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205c566:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205dcd1:&#9;movzbl (%eax),%edi&#9;R@edi[0x00000000][4]&#9;T0&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205dcd8:&#9;mov    %edi,-0xac(%ebp)&#9;R@edi[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;</span><br></pre></td></tr></table></figure>
<h1 id="VineIL">VineIL</h1><p>Vineが生成するVineILは静的単一代入形式の中間表現であり，CFGの情報が損なわれることはない．中間表現の生成をinstruction liftingという．なお，VineILはValgrindの中間表現を扱うライブラリVEXをもとに生成される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -ir-out five.ir&#10;~/vine/examples$ cat five.ir | awk &#39;NR==1000,NR==1020&#39;&#10;R_CC_OP_16:reg32_t = 0xd:reg32_t;&#10;T_32t9_1114:reg32_t = cast(T_8t3_1108:reg8_t)U:reg32_t;&#10;R_CC_DEP1_17:reg32_t = T_32t9_1114:reg32_t;&#10;R_CC_DEP2_18:reg32_t = 0:reg32_t;&#10;R_CC_NDEP_19:reg32_t = 0:reg32_t;&#10;/*eflags thunk: logic*/&#10;&#10;R_CF_10:reg1_t = false;&#10;T_7_1115:reg8_t = cast(T_32t9_1114:reg32_t)L:reg8_t;&#10;R_PF_11:reg1_t =&#10;!cast(&#10;      ((T_7_1115:reg8_t &#62;&#62; 7:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 6:reg32_t)&#10;         ^ (T_7_1115:reg8_t &#62;&#62; 5:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 4:reg32_t))&#10;       ^ &#10;         ((T_7_1115:reg8_t &#62;&#62; 3:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 2:reg32_t)&#10;            ^ (T_7_1115:reg8_t &#62;&#62; 1:reg32_t ^ T_7_1115:reg8_t))&#10;         )L:reg1_t;&#10;R_AF_12:reg1_t = false;&#10;R_ZF_13:reg1_t = T_32t9_1114:reg32_t == 0:reg32_t;&#10;R_SF_14:reg1_t = 1:reg32_t == (1:reg32_t &#38; T_32t9_1114:reg32_t &#62;&#62; 7:reg32_t);&#10;R_OF_15:reg1_t = false;</span><br></pre></td></tr></table></figure>
<p>出力している行の番号は適当．</p>
<h1 id="最弱事前条件">最弱事前条件</h1><p>最弱事前条件(weakest precondition)はDijkstraによる述語変換意味論の基礎を成す概念である．Sを条件，式をRとした際，最弱事前条件WP(S, R)は，Rを実行する前にS’が成り立っていればSの実行後にSが成り立つ最も弱い条件S’を表す．単純な例だと，以下のように表現される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WP(S, x=e) = S[e/x]&#10;WP(new == org,  new = new+taint) &#10;=  new+taint == org</span><br></pre></td></tr></table></figure>
<p>Vineにおける最弱事前条件の出力は，以下のようになる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -wp-out five.wp&#10;~/vine/examples$ grep let five.wp | head -n 20&#10;let post_1681:reg1_t = true in&#10;let R_EAX_1682:reg32_t = 0x40014000:reg32_t in&#10;let idx_1683:reg32_t = 0x40014000:reg32_t in&#10;let val_1684:reg8_t = INPUT_1001_0000_61:reg8_t in&#10;let temp_1685:reg8_t = val_1684:reg8_t &#38; 0xff:reg8_t in&#10;let temp_1686:reg8_t = temp_1685:reg8_t &#62;&#62; 0:reg8_t in&#10;let towrite_1688:reg8_t = cast(temp_1686:reg8_t)L:reg8_t in&#10;let mem_arr_1687:reg8_t[4294967296] =&#10;    let mem_arr_57[0x40014000:reg32_t]:reg8_t = towrite_1688:reg8_t in&#10;    mem_arr_57:reg8_t[4294967296]&#10;in&#10;let R_EAX_1689:reg32_t = 0x40014000:reg32_t in&#10;let R_GDT_1690:reg32_t = 0xc02dbd80:reg32_t in&#10;let R_LDT_1691:reg32_t = 0xc02dcc58:reg32_t in&#10;let R_DFLAG_1692:reg32_t = 1:reg32_t in&#10;let T_32t0_1693:reg32_t = R_EAX_1689:reg32_t in&#10;let T_8t2_1694:reg8_t = mem_arr_1687[0x40014000:reg32_t]:reg8_t in&#10;let T_32t1_1695:reg32_t = cast(T_8t2_1694:reg8_t)U:reg32_t in&#10;let R_EAX_1696:reg32_t = T_32t1_1695:reg32_t in&#10;let temp_1697:reg32_t = R_EAX_1696:reg32_t &#38; 0xffff00ff:reg32_t in&#10;let temp_1698:reg32_t = cast(0:reg8_t)U:reg32_t in&#10;let temp_1699:reg32_t = temp_1698:reg32_t &#60;&#60; 8:reg8_t in</span><br></pre></td></tr></table></figure>
<p>このような手法でソースコードの存在しないバイナリから最弱事前条件を抽出し，仕様書を復元する試みがあるらしい．ゾッとする．</p>
<h1 id="STP_formula">STP formula</h1><p>Vineは，TEMUのトレースファイルからSTP formulaを出力する．STP formulaとはSMTソルバであるSTP用のフォーマットである．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -stp-out five.stp&#10;~/vine/examples$ head -n 20 five.stp&#10;% free variables: &#10;mem_arr_57 : ARRAY BITVECTOR(64) OF BITVECTOR(8);&#10;INPUT_1001_0000_61 : BITVECTOR(8);&#10;% end free variables.&#10; &#10; &#10;ASSERT( 0bin1 =&#10;(LET post_1681 =&#10;    0bin1&#10;IN&#10;(LET R_EAX_1682 =&#10;    0hex40014000&#10;IN&#10;(LET idx_1683 =&#10;    0hex40014000&#10;IN&#10;(LET val_1684 =&#10;    INPUT_1001_0000_61&#10;IN&#10;(LET temp_1685 =</span><br></pre></td></tr></table></figure>
<p>SMTソルバは充足可能性問題を解く．では，ここで与えられる命題とは何か．それは，任意の初期値がトレースファイルの結果と一致するというものだ．STPは命題が充足可能か解こうとし，充足不能であった場合は反例を出力する．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ cat &#62;&#62;five.stp&#10;QUERY(FALSE);&#10;COUNTEREXAMPLE;</span><br></pre></td></tr></table></figure>
<p>ここで出力される反例は，実行経路に影響を与えた入力値となるようだ．five.traceでは，0x35(ASCIIで5)という入力値が分岐に影響を与えている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../stp/stp five.stp&#10;Invalid.&#10;ASSERT( INPUT_1001_0_61  = 0hex35  );</span><br></pre></td></tr></table></figure>
<p>これはトレースファイルに対する静的なシンボリック実行だと言える．シンボリック実行とは，記号によって表現したプログラムの変数を操作することで，実行経路に影響する制約を抽出する静的解析の手法である．シンボリック実行は到達定義の解析などモデルベーステストの領域で発展してきたが，マルウェアの挙動解析に役立てられないだろうか．</p>
<h1 id="BAP">BAP</h1><p><a href="http://bap.ece.cmu.edu" target="_blank" rel="external">BAP</a>はDavid BrumleyらによるVineの再実装である．彼らはCMUに所属しており，PPPのメンバーでもある．彼らは脆弱性解析の自動化をmotivationとしてBitBlazeを扱ってきた．BAPはVineをより発展させたプロジェクトであり，逆アセンブリやTEMUのトレースファイルから中間表現BILを生成するほか，CFGのみならずCDG(control dependence graphs)やDDG(data dependence graphs)の出力をサポートしているようだ．</p>
<h1 id="おわりに">おわりに</h1><p>TEMUのトレースファイルについて，ざっくりVineによる静的解析を行った．とりあえず動かしてみただけなので，コードを噛み砕く必要がある．気になるのはやはり中間表現のフォーマットだ．一度，QEMU，Valgrind，DynamoRIO，LLVM，Vine，BAPなどの中間表現について，対応を整理したほうが良いかもしれない．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/28/vine-howto/" data-id="cipa8jbn2000cxsoskv1vhf89" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-symexec-intro" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/12/symexec-intro/">シンボリック実行に入門しようとした</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-11T17:50:52.000Z" itemprop="datePublished">09-12-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>シンボリック実行(symbolic execution)という用語をセキュリティ系の論文でよく見かけるようになった．ここでは，シンボリック実行の基礎となる理論を辿る．筆者はソフトウェアテストの研究には疎く，おそらく本稿には若干以上の誤謬と誤解が含まれているだろう．ぜひ識者の教示を乞いたい．</p>
<h1 id="発祥">発祥</h1><p>シンボリック実行は主にソフトウェアテストの領域で古くから研究されてきたトピックである．シンボリック実行という用語の初出は遡ること38年前，James C. Kingらによる<a href="https://courses.engr.illinois.edu/cs477/sp2011/king76symbolicexecution.pdf" target="_blank" rel="external">Symbolic Execution and Program Testing [PDF]</a>という論文だ．Dijkstraがgoto文の濫用による大域脱出を批判したのが1968年であり，Guarded Command Languageを提案したのが1975年のことである．この論文が発表された1976年当時はまさに構造化プログラミングというパラダイムがコンピュータサイエンスの世界を席捲していた時代であった．私が生まれる20年以上前のことで，当時の問題意識を肌身で感じることができないのが少し残念に思える．感覚としては白亜紀のようなもので，主要な登場人物もDijkstraやらKnuthやら，恐竜かよ．<br>さて，シンボリック実行とはどのような提案だったか．まず，シンボリック実行の目的は「どの入力値でどの実行経路を通るか特定する」ことである．そのためにはどうすればよいだろうか？シンボリック実行はその名の通り，プログラムの変数をシンボル(記号)として表現する．論文中のスニペットはあまりにも古めかしいので，<a href="http://en.wikipedia.org/wiki/Symbolic_execution" target="_blank" rel="external">Symbolic execution - Wikipedia, the free encyclopedia</a>を例に考えよう．残念ながら日本語記事はないものの，原理は単純明快．</p>
<pre><code>y = read<span class="list">()</span>
y = <span class="number">2</span> * y
if <span class="list">(<span class="keyword">y</span> == <span class="number">12</span>)</span>
    fail<span class="list">()</span>
print<span class="list">(<span class="string">"OK"</span>)</span>
</code></pre><p>シンボリック実行では入力に具体値を与えない．例えば，変数yに割り当てられる入力値をsというシンボルで表現する．見ての通り，このルーチンはif文で2つの実行経路に分岐するが，この分岐の条件を制約と呼ぶ．ここでの制約は<code>2 * s == 12</code>となる．実行経路を分岐させる条件となる入力値は，式を解けば分かる．言うまでもなく<code>6</code>だ．おっと，これは充足可能性問題というやつじゃないか？その通り，シンボリック実行では制約を解くにあたって制約充足ソルバ(constraint solver)を用いる．ここでは，<code>2 * s == 12</code>という制約が<code>¬s1 ∧ ¬s2 ∧ ¬s3 ∧ ¬s4 ∧ s5 ∧ s6 ∧ ¬s7 ∧ ¬0</code>という連言標準形で表される．<code>2 * s</code>は<code>s1s2s3s4s5s6s70</code>に，<code>12</code>は<code>00001100</code>となる．<br>このように，具体値を与えないまま，必ず1つの実行経路を通る制約(path constraints)を求め，条件分岐に影響する入力値の制約を特定する手法がシンボリック実行である．シンボリック「実行」と銘打っていても，実際にプログラムを実行しているわけではない．飽くまでシンボルの操作を通して，擬似的にプログラムを実行しているのだ．</p>
<h1 id="Concolic_Testing/Dynamic_Symbolic_Execution">Concolic Testing/Dynamic Symbolic Execution</h1><p>では，シンボリック実行は銀の弾丸たりえるか？そんなわけがない．真っ先に以下の課題に直面してしまう．</p>
<ul>
<li>計算爆発</li>
<li>制約充足ソルバで解くことができない制約</li>
<li>入力値が一意に定まらない</li>
</ul>
<p>そこで，<a href="http://mir.cs.illinois.edu/marinov/publications/SenETAL05CUTE.pdf" target="_blank" rel="external">CUTE: A Concolic Unit Testing Engine for C [PDF]</a>において，concolic testingという手法が提案された．concolicとは耳慣れない言葉だが，どういった意味だろうか？これは，symbolic(シンボル)とconcrete(具体値)からなる造語で，concolic testingとはシンボリック実行に具体値(concrete value)を持ち込んだ手法である．またの名を動的シンボリック実行．<br>具体値を持ち込むとはどういうことか？動的シンボリック実行では，制約充足ソルバが不得手とする非線形な制約に到達した場合，その箇所だけ実際に実行(concrete execution)することで，具体値を代入する．これによって，コードカバレッジを拡大するというのが狙いである．現在「シンボリック実行」と呼ばれているのは概ね動的シンボリック実行である．</p>
<h1 id="KLEE">KLEE</h1><p><a href="http://klee.github.io/klee/" target="_blank" rel="external">KLEE</a>はシンボリック実行にLLVM bitcodeを導入したプロジェクトである．チュートリアルは<a href="http://feliam.wordpress.com/2010/10/07/the-symbolic-maze/" target="_blank" rel="external">The Symbolic Maze! - Feliam’s Blog</a>が秀逸．<br>使い方は簡単で，解析対象のソースコードに<code>#include &lt;klee/klee.h&gt;</code>と<code>klee_make_symbolic()</code>とを追加するだけで準備は完了する．<code>klee_make_symbolic()</code>にはシンボリック実行を適用したい変数のアドレスとサイズ，名前を引数として与える．</p>
<pre><code><span class="tag">llvm-gcc</span> <span class="tag">--emit-llvm</span> <span class="tag">-c</span> <span class="tag">-g</span> <span class="attr_selector">[file]</span><span class="class">.c</span>
<span class="tag">klee</span> <span class="attr_selector">[file]</span><span class="class">.o</span>
</code></pre><p>LLVM bitcodeとしてコンパイルし，KLEEに与えて実行すると，ktestという形式のテストケースが生成される．</p>
<pre><code>ktest-tool --<span class="keyword">write</span>-ints klee-<span class="keyword">last</span>/[<span class="keyword">file</span>].ktest 
</code></pre><p>ktest-toolを実行すると，入力値が出力される．</p>
<pre><code>ktest <span class="string">file :</span> ‘klee-last/test000001.ktest’
<span class="string">args :</span> [<span class="string">'[file].o'</span>]
num <span class="string">objects:</span> <span class="number">1</span>
object <span class="number">0</span>: <span class="string">name:</span> ‘hoge’
object <span class="number">0</span>: <span class="string">size:</span> <span class="number">4</span>
object <span class="number">0</span>: <span class="string">data:</span> ‘fuga′
</code></pre><p>これによって，KLEEは90%以上のコードカバレッジを実現する．論文の評価実験では，Coreutilsについて，15年に渡って作成されてきたテストスイートよりも高いカバレッジをたったの89時間で達成している．<br>KLEEは多くの研究者に利用されており，シンボリック実行に関する研究のstate-of-the-artはKLEEを分散化した<a href="https://code.comsys.rwth-aachen.de/redmine/projects/kleenet-public" target="_blank" rel="external">KleeNet</a>だと聞いている．<br>しかし，もちろんKLEEは万能ではない．特にループ文の解釈がうまくいかないことが多く，これはシンボリック実行が抱える永年の課題である．</p>
<h1 id="STP">STP</h1><p>KLEEは<a href="https://sites.google.com/site/stpfastprover/" target="_blank" rel="external">STP Constraint Solver</a>という制約充足ソルバを用いている．STPは制約充足ソルバの中でもSMT(Satisfiable Modulo Theories)ソルバと呼ばれるものに相当する．SAT(SATisfiability problem)ソルバはブール式のみを扱うが，SMTソルバはこれに加えて配列やビットベクトル，加減算大小比較など様々な背景理論を用いることができる．STPではAND，OR，NOT，XORといった演算についてもサポートされ，式の最適化についても工夫されているようだ．</p>
<h1 id="S2E">S2E</h1><p>少しばかり，リバースエンジニアリングにも目を向けてみよう．解析対象のソースコードが存在しない場合，どうやってシンボリック実行を適用すればよいだろうか？解決策のひとつとして挙げられるのが<a href="https://github.com/dslab-epfl/s2e" target="_blank" rel="external">S2E</a>である．<br>S2EはQEMUの動的バイナリ変換(dynamic binary translation)を用いる．QEMUの動的バイナリ変換機能をTCG(Tiny Code Generator)といい，これによって例えばARM向けにビルドされたバイナリをx86の計算機で動かすといった機能が実現される．<br>まず，QEMUは対象のバイナリを逆アセンブルし，複数のブロックに分割する．このブロックをTB(translation block)といい，定義は<code>translate-all.h</code>に記述されている．TBは分岐命令やページの境界によって区切られる．そして，ブロック単位で逆アセンブルしたコードを<code>gen_intermediate_code()</code>という関数で中間コードに変換し，<code>tcg_gen_code()</code>という関数で他のアーキテクチャの命令とマッピングする．これらは<code>target-[arch]/translate.c</code>および<code>tcg/tgc.c</code>に記述されている．こうして変換されたコードは，TB単位でキャッシュされる．実行にあたっては，変換されたTBをchainとして繋いでいく．この処理は，<code>main()</code>から<code>cpu_exec()</code>を経由して呼ばれる<code>tb_find_fast()</code>や<code>tb_find_slow()</code>に記述されている．こうして，QEMUは異なるアーキテクチャ向けバイナリの実行を可能にしている．<br>S2Eは，QEMUのTCGを用いてPEファイルをLLVM bitcodeに変換し，KLEEに受け渡す．TCGは，中間コードを変換するにあたって，変換先のアーキテクチャの命令が記述された辞書を参照する．S2Eはこの辞書にLLVM bitcodeを登録することで，実行ファイルをLLVM bitcodeに「逆アセンブル」するのだ．<br>このようにして，S2Eはシンボリック実行を実現しているが，そもそもLLVM bitcodeに変換する必要はあるのだろうか？KLEEは確かに優れたツールだが，バイナリに直接シンボリック実行を適用すれば良いのではないか？<br>これには理由がある．QEMUの中間コードも，LLVM bitcodeもレジスタが無限個存在するSSA(Static Single Assignment form，静的単一代入)形式をとっている．一方で，x86アーキテクチャはSSA形式ではない．x86における逆アセンブルコードにシンボリック実行を適用する例を考えよう．</p>
<pre><code><span class="keyword">mov</span> <span class="literal">esi</span>, <span class="number">0x09</span>
<span class="keyword">mov</span> <span class="number">edx</span>, <span class="number">0x2014</span>
</code></pre><p>この場合，制約は<code>(esi == 0x09) and (edx == 0x2014)</code>となる．これなら問題はないが，以下の例はどうだろう．</p>
<pre><code><span class="keyword">mov</span> <span class="literal">esi</span>, <span class="number">0x09</span>
...
<span class="keyword">mov</span> <span class="literal">esi</span>, <span class="number">0x2014</span>
</code></pre><p>同じレジスタに違う値が代入されている．この場合，制約は<code>(esi == 0x09) and (esi == 0x2014)</code>となってしまう．こうした理由から，シンボリック実行にはSSA形式への変換が必要となるようだ．</p>
<h1 id="おわりに">おわりに</h1><p>シンボリック実行の基礎を学んだつもりになった．この技術が情報セキュリティの分野でどう活きてくるのかについては，また改めて．進捗だめです．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li><a href="http://debugeng.com/concolic%20testing.pdf" target="_blank" rel="external">Concolic testingと背景技術 ~テスト技法の新動向~ [PDF]</a></li>
<li><a href="http://blog.livedoor.jp/prjmng/archives/52297951.html" target="_blank" rel="external">テスト入力値の自動生成と、concolic testing - ソフトウェアの品質を学びまくる</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/12/symexec-intro/" data-id="cipa8jbng000rxsoslczzma0w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 ntddk<br>
      <a href="https://github.com/ntddk/hexo-theme-jathena" target="_blank">JAthena</a> by <a href="http://ntddk.github.io" target="_blank">ntddk</a> | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>