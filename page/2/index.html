<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>一生あとで読んでろ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="一生あとで読んでろ">
<meta property="og:url" content="http://ntddk.github.io/page/2/index.html">
<meta property="og:site_name" content="一生あとで読んでろ">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一生あとで読んでろ">
<meta name="twitter:description">
<meta name="twitter:creator" content="@ntddk">
  
    <link rel="alternative" href="/atom.xml" title="一生あとで読んでろ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一生あとで読んでろ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技術ブログ</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-sandbox-transparency-in-the-wild" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/03/14/sandbox-transparency-in-the-wild/">続・サンドボックスの透明性</a>
  

      </header>
    
    <time class="article-date" datetime="2015-03-14T12:00:00.000Z" itemprop="datePublished">03-14-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="耐解析機能の分類">耐解析機能の分類</h1><p><a href="https://twitter.com/gabrielnb" target="_blank" rel="external">Gabriel N. Barbosa</a>と<a href="https://twitter.com/BSDaemon" target="_blank" rel="external">Rodrigo R. Branco</a>は，マルウェアの耐解析機能を<strong>Anti-Debugging, Anti-Disassembly, Obfuscation, Anti-VM</strong>の四種類に分類した．彼らはIntelのセキュリティ研究者であり，マルウェアに備わった耐解析機能の統計を過去二回に渡って発信してきた．<br>気になるのは，サンドボックスの実装にあたって問題となるAnti-VMだ．8,103,167もの検体を用いた調査によると，その内訳は以下のようになっている．</p>
<p><img src="/image/anti-vm.jpg" title="" prevalent="" characteristics="" in="" modern="" malware"より"=""></p>
<p>これらはいずれもVMware社製品を検出するための手法である．残念ながら他の仮想マシンモニタについての情報は掲載されて<strong>いない</strong>．</p>
<h1 id="仮想マシンモニタの分類">仮想マシンモニタの分類</h1><p><a href="http://ntddk.github.io/2015/01/23/sandbox-transparency/">以前にも少しばかり述べた</a>，サンドボックスの透明性(transparency)に関する話を蒸し返そう．<br>サンドボックスにOut-of-the-boxなVMIを採用すれば，少なくともAnti-Debuggingについては無視できる．<br>では，サンドボックスにXenを用いれば，QEMUより検出されにくくなるだろうか．あるいは，その逆はどうだろうか．<br>多くの研究者が好き勝手なことを言っているが，仮想マシンモニタの実現手法をもってサンドボックスの透明性を語るのは些か性急だろう．なぜなら，サンドボックスの透明性はその設計ではなくマルウェアの実装によって左右されるからだ．<strong>Out-of-the-box VMIは設計の話だが，Anti-VMは実装の話だ</strong>（と思う）．<br>ところで私は，仮想マシンモニタの実現手法を「プロセッサ拡張によるもの」と「バイナリ変換によるもの」に分類していたが，別の分類方法を見つけた．</p>
<p><img src="/image/vm-class.png" title="" a="" survey="" of="" security="" issues="" in="" hardware="" virtualization"より"=""></p>
<p>命令セットアーキテクチャを基準に分類することで，より分かりやすくなっている．今後はこの図に準拠したい．<br>話を戻そう．<br>何が言いたいのかというと，in-the-wildなマルウェアに備わったAnti-VMの内訳が分からないことには，サンドボックスの透明性について云々することはできないということだ．</p>
<h1 id="検体">検体</h1><p>誰もやっていないようなので，調べてみることにした．<br>やや恣意的（誤用？）な選択だが，今回は<a href="http://virusshare.com/" target="_blank" rel="external">VirusShare.com</a>からCitadelのバリアント479検体や，Mandiantの<a href="http://intelreport.mandiant.com/Mandiant_APT1_Report.pdf" target="_blank" rel="external">APT1レポート</a>にて報告された中国軍総参謀部第三部第二局こと61398部隊<strong>と思しき</strong>グループ製の874検体を含む<strong>総計33,260検体</strong>を用いた．</p>
<h1 id="Anti-VMの実態">Anti-VMの実態</h1><p><a href="http://plusvic.github.io/yara/" target="_blank" rel="external">YARA</a>を用いてAnti-VMの実態を調べた．<br>ルールには公式の<a href="http://yararules.com/rules/antidebug.yar" target="_blank" rel="external">antidebug.yar</a>を用いた．なお，このルールにはAnti-VMのみならずAnti-Debuggerについても記載されている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># awk &#39;&#123; print $1&#125;&#39; yara.log | sort | uniq -c | sort -r&#10;  20340 DebuggerPattern__RDTSC&#10;  18966 DebuggerPattern__CPUID&#10;   9292 DebuggerTiming__Ticks&#10;   7371 DebuggerPattern__SEH_Inits&#10;   6955 DebuggerException__UnhandledFilter&#10;   5715 DebuggerTiming__PerformanceCounter&#10;   4377 DebuggerPattern__SEH_Saves&#10;   2949 DebuggerCheck__API&#10;   2631 DebuggerCheck__QueryInfo&#10;   2182 SEH__vba&#10;   1315 DebuggerOutput__String&#10;    887 ThreadControl__Context&#10;    604 vmdetect&#10;    303 DebuggerException__SetConsoleCtrl&#10;    186 SEH__vectored&#10;     83 DebuggerHiding__Thread&#10;     80 DebuggerHiding__Active&#10;     52 DebuggerException__ConsoleCtrl&#10;     10 Check_Dlls&#10;      5 DebuggerCheck__RemoteAPI&#10;      2 DebuggerCheck__GlobalFlags&#10;      1 &#9618;&#9618;DebuggerPattern__RDTSC&#10;      1 Debuggeattern__SEH_Inits&#10;      1 Check_VBox_VideoDrivers&#10;      1 Check_VBox_Description</span><br></pre></td></tr></table></figure>
<p>マルウェアの開発者がよりgenericな手法を好むことは，<code>RDTSC</code>命令を用いる検体が61.15%, <code>CPUID</code>命令を用いる検体が57.02%含まれていることからも明らかだ．たった2バイトを基準に検出しているため，false positiveだらけなのだろうとはいえ．<br>一方でvmdetectとして計上された検体は全体の1.18%に過ぎない．これはVMware, Virtual PC, Xen, Virtual Boxに関する文字列が含まれる検体を抽出するルールであり，コードは以下のようになっている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule vmdetect&#10;&#123;&#10;    meta:&#10;        author = &#34;nex&#34;&#10;        description = &#34;Possibly employs anti-virtualization techniques&#34;&#10;&#10;    strings:&#10;        // Binary tricks&#10;        $vmware = &#123;56 4D 58 68&#125;&#10;        $virtualpc = &#123;0F 3F 07 0B&#125;&#10;        $ssexy = &#123;66 0F 70 ?? ?? 66 0F DB ?? ?? ?? ?? ?? 66 0F DB ?? ?? ?? ?? ?? 66 0F EF&#125;&#10;        $vmcheckdll = &#123;45 C7 00 01&#125;&#10;        $redpill = &#123;0F 01 0D 00 00 00 00 C3&#125;&#10;&#10;        // Random strings&#10;        $vmware1 = &#34;VMXh&#34;&#10;        $vmware2 = &#34;Ven_VMware_&#34; nocase&#10;        $vmware3 = &#34;Prod_VMware_Virtual_&#34; nocase&#10;        $vmware4 = &#34;hgfs.sys&#34; nocase&#10;        $vmware5 = &#34;mhgfs.sys&#34; nocase&#10;        $vmware6 = &#34;prleth.sys&#34; nocase&#10;        $vmware7 = &#34;prlfs.sys&#34; nocase&#10;        $vmware8 = &#34;prlmouse.sys&#34; nocase&#10;        $vmware9 = &#34;prlvideo.sys&#34; nocase&#10;        $vmware10 = &#34;prl_pv32.sys&#34; nocase&#10;        $vmware11 = &#34;vpc-s3.sys&#34; nocase&#10;        $vmware12 = &#34;vmsrvc.sys&#34; nocase&#10;        $vmware13 = &#34;vmx86.sys&#34; nocase&#10;        $vmware14 = &#34;vmnet.sys&#34; nocase&#10;        $vmware15 = &#34;vmicheartbeat&#34; nocase&#10;        $vmware16 = &#34;vmicvss&#34; nocase&#10;        $vmware17 = &#34;vmicshutdown&#34; nocase&#10;        $vmware18 = &#34;vmicexchange&#34; nocase&#10;        $vmware19 = &#34;vmdebug&#34; nocase&#10;        $vmware20 = &#34;vmmouse&#34; nocase&#10;        $vmware21 = &#34;vmtools&#34; nocase&#10;        $vmware22 = &#34;VMMEMCTL&#34; nocase&#10;        $vmware23 = &#34;vmx86&#34; nocase&#10;        $vmware24 = &#34;vmware&#34; nocase&#10;        $virtualpc1 = &#34;vpcbus&#34; nocase&#10;        $virtualpc2 = &#34;vpc-s3&#34; nocase&#10;        $virtualpc3 = &#34;vpcuhub&#34; nocase&#10;        $virtualpc4 = &#34;msvmmouf&#34; nocase&#10;        $xen1 = &#34;xenevtchn&#34; nocase&#10;        $xen2 = &#34;xennet&#34; nocase&#10;        $xen3 = &#34;xennet6&#34; nocase&#10;        $xen4 = &#34;xensvc&#34; nocase&#10;        $xen5 = &#34;xenvdb&#34; nocase&#10;        $xen6 = &#34;XenVMM&#34; nocase&#10;        $virtualbox1 = &#34;VBoxHook.dll&#34; nocase&#10;        $virtualbox2 = &#34;VBoxService&#34; nocase&#10;        $virtualbox3 = &#34;VBoxTray&#34; nocase&#10;        $virtualbox4 = &#34;VBoxMouse&#34; nocase&#10;        $virtualbox5 = &#34;VBoxGuest&#34; nocase&#10;        $virtualbox6 = &#34;VBoxSF&#34; nocase&#10;        $virtualbox7 = &#34;VBoxGuestAdditions&#34; nocase&#10;        $virtualbox8 = &#34;VBOX HARDDISK&#34;  nocase&#10;&#10;        // MAC addresses&#10;        $vmware_mac_1a = &#34;00-05-69&#34;&#10;        $vmware_mac_1b = &#34;00:05:69&#34;&#10;        $vmware_mac_1c = &#34;000569&#34;&#10;        $vmware_mac_2a = &#34;00-50-56&#34;&#10;        $vmware_mac_2b = &#34;00:50:56&#34;&#10;        $vmware_mac_2c = &#34;005056&#34;&#10;        $vmware_mac_3a = &#34;00-0C-29&#34; nocase&#10;        $vmware_mac_3b = &#34;00:0C:29&#34; nocase&#10;        $vmware_mac_3c = &#34;000C29&#34; nocase&#10;        $vmware_mac_4a = &#34;00-1C-14&#34; nocase&#10;        $vmware_mac_4b = &#34;00:1C:14&#34; nocase&#10;        $vmware_mac_4c = &#34;001C14&#34; nocase&#10;        $virtualbox_mac_1a = &#34;08-00-27&#34;&#10;        $virtualbox_mac_1b = &#34;08:00:27&#34;&#10;        $virtualbox_mac_1c = &#34;080027&#34;&#10;&#10;    condition:&#10;        any of them&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>見ての通りQEMUに関する記述が存在しない．<br>そこで，vmdetectに以下の様なコードを追加し，再度スキャンしてみた．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule vmdetect&#10;&#123;&#10;    ~ &#30053; ~&#10;&#10;    strings:&#10;        $QEMU1 = &#34;Bochs&#34; nocase&#10;        $QEMU3 = &#34;QEMU_AUDIO_DRV&#34; nocase&#10;        $QEMU4 = &#34;QEMU VVFAT&#34; nocase&#10;        $QEMU5 = &#34;QEMU ADB Mouse&#34; nocase&#10;        $QEMU6 = &#34;QEMU ADS7846-driven Touchscreen&#34; nocase&#10;        $QEMU7 = &#34;QEMU HARDDISK&#34; nocase&#10;        $QEMU8 = &#34;QEMU CD-ROM&#34; nocase&#10;        $QEMU9 = &#34;QEMU MICRODRIVE&#34; nocase&#10;        $QEMU10 = &#34;QEMU-MEMORY&#34; nocase&#10;        $QEMU11 = &#34;QEMU_BIOS&#34; nocase&#10;        $QEMU12 = &#34;QEMU PS/2 Mouse&#34; nocase&#10;        $QEMU13 = &#34;QEMU Sun Mouse&#34; nocase&#10;        $QEMU14 = &#34;QEMU TSC2102-driven Touchscreen&#34; nocase&#10;        $QEMU15 = &#34;QEMU USB Mouse&#34; nocase&#10;        $QEMU16 = &#34;QEMU USB Tablet&#34; nocase&#10;        $QEMU17 = &#34;QEMU_VERSION&#34; nocase&#10;        $QEMU18 = &#34;QEMU USB Keyboard&#34; nocase&#10;        $QEMU19 = &#34;QEMU USB Hub&#34; nocase&#10;        $QEMU20 = &#34;QEMU USB MSD&#34; nocase&#10;        $QEMU21 = &#34;QEMU PenPartner tablet&#34; nocase&#10;        $QEMU22 = &#34;QEMUware SVGA&#34; nocase&#10;&#10;    condition:&#10;        any of them&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>結果は608検体．QEMUを検出するのは4検体だけという結果になった．<br>自分がマルウェアを開発する立場だったらこうした文字列をそのまま埋め込むことはしないし，このルールは表層的なものでしかなく，例えばQEMUの動的バイナリ変換のスケジューリングに着目したAnti-VMを検出することはできない．<br>とはいえ，おかげで現状を大雑把に把握することはできた．</p>
<h1 id="パッカーの実態">パッカーの実態</h1><p>ついでに，<a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml" target="_blank" rel="external">PEiD</a>を用いてパッカーの利用状況を調べた．<br>UserDBには<a href="https://code.google.com/p/reverse-engineering-scripts/downloads/detail?name=UserDB.TXT" target="_blank" rel="external">Bob / Team PEiD signatures</a>を用いた．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># awk &#39;&#123;&#123;for(i=3;i&#60;NF;i++)printf(&#34;%s &#34;,$i) &#125;print($NF)&#125;&#39; peid.log | sort | uniq -c | sort -r&#10;  21159 Nothing found *&#10;   3065 Nothing found [Overlay] *&#10;   1412 Microsoft Visual Basic 5.0 / 6.0&#10;    916 Microsoft Visual C++ 8.0 DLL Method2&#10;    747 Microsoft Visual C++ 6.0&#10;    685 Microsoft Visual Basic 5.0 - 6.0&#10;    405 Borland Delphi 6.0 - 7.0 [Overlay]&#10;    351 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo&#10;    333 Microsoft Visual C++ 7.0 [Overlay]&#10;    320 UPX 2.93 - 3.00 [LZMA] -&#62; Markus Oberhumer, Laszlo Molnar &#38; John Reiser [Overlay] *&#10;    239 Borland Delphi 6.0 - 7.0&#10;    201 Microsoft Visual C++ 6.0 [Overlay]&#10;    185 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo [Overlay]&#10;    167 Nullsoft PiMP Stub [Nullsoft PiMP SFX] *&#10;     99 Microsoft Visual C++ 6.0 DLL&#10;     83 Microsoft Visual C++ 7.0 [Debug] [Overlay]&#10;     82 Nothing found [Debug] *&#10;     79 UPX 0.89.6 - 1.02 / 1.05 - 2.90 (Delphi) stub -&#62; Markus &#38; Laszlo [Overlay]&#10;     63 Microsoft Visual C++ 7.0&#10;     62 Microsoft Visual C# / Basic .NET&#10;     61 Microsoft Visual Basic 5.0 / 6.0 [Overlay]&#10;     42 Themida 1.8.x.x - 1.9.x.x -&#62; Oreans Technologies&#10;     42 ASPack 2.12 -&#62; Alexey Solodovnikov [Overlay]&#10;     38 ASProtect 1.2x - 1.3x [Registered] -&#62; Alexey Solodovnikov&#10;     32 ASPack 2.12 -&#62; Alexey Solodovnikov&#10;     31 PE Win32 DLL (0 EntryPoint)&#10;     31 Nothing found [RAR SFX] *&#10;     31 Microsoft Visual C++ 6.0 DLL [Overlay]&#10;     28 Borland C++&#10;     26 PECompact 2.x -&#62; Jeremy Collake [Overlay]&#10;     24 Morphine 1.2 - 1.3 -&#62; rootkit&#10;     23 MinGW GCC 3.x [Overlay] *&#10;     22 UPX 0.89.6 - 1.02 / 1.05 - 2.90 (Delphi) stub -&#62; Markus &#38; Laszlo&#10;     22 Microsoft Visual C# / Basic .NET [Overlay]&#10;     19 Nothing found [ZIP SFX] *&#10;     18 PECompact 2.x -&#62; Jeremy Collake&#10;     18 Microsoft Visual C++ 7.0 [Debug]&#10;     15 Borland C++ [Overlay]&#10;     14 Borland Delphi 4.0 - 5.0&#10;     14 ASProtect 1.33 - 2.1 Registered -&#62; Alexey Solodovnikov *&#10;     13 UPX 2.93 - 3.00 [LZMA] -&#62; Markus Oberhumer, Laszlo Molnar &#38; John Reiser *&#10;     13 Microsoft Visual C++ 6.0 [Debug]&#10;     13 Microsoft Visual C++ 5.0&#10;     12 UPX 0.80 - 1.24 DLL -&#62; Markus &#38; Laszlo&#10;     12 BobSoft Mini Delphi -&#62; BoB / BobSoft [Overlay] *&#10;     11 Themida 1.8.x.x -&#62; Oreans Technologies *&#10;     11 Microsoft Visual C++ Private Version 1&#10;     11 Borland Delphi 6.0&#10;     11 Borland Delphi 2.0 [Overlay]&#10;     10 BobSoft Mini Delphi -&#62; BoB / BobSoft *&#10;      9 NsPack 2.9 -&#62; North Star *&#10;      9 Microsoft Visual C++ 5.0 [Debug]&#10;      8 Microsoft Visual C++ 7.1 DLL&#10;      8 Microsoft Visual C++ 7.0 Method2&#10;      7 Xtreme-Protector v1.05 *&#10;      7 Microsoft Visual C++ 8.0 DLL Method2 [Overlay]&#10;      6 Xtreme-Protector v1.05 [Overlay] *&#10;      6 Microsoft Visual C++ 8.0 [Debug] [Debug]&#10;      6 ASProtect 1.2x - 1.3x [Registered] -&#62; Alexey Solodovnikov [Overlay]&#10;      5 nSPack 3.7 -&#62; North Star/Liu Xing Ping&#10;      5 Wise Installer Stub [Overlay] *&#10;      5 WinZip 32-bit SFX 8.x module&#10;      5 Thinstall 2.4x - 2.5x -&#62; Jitit Software [Overlay] *&#10;      5 PureBasic 4.x -&#62; Neil Hodgson *&#10;      5 PE Win32 DLL (0 EntryPoint) [Overlay]&#10;      5 Microsoft Visual C++ 7.1 DLL [Overlay]&#10;      4 tElock 0.98b1 -&#62; tE!&#10;      4 Themida 1.8.x.x - 1.9.x.x -&#62; Oreans Technologies [Overlay]&#10;      4 PureBasic 4.x -&#62; Neil Hodgson [Overlay] *&#10;      4 PC-Guard 5.0 -&#62; Blagoje Ceklic [Overlay]&#10;      4 MoleBox v2.0 *&#10;      4 Microsoft Visual C++ 8.0 [Debug]&#10;      4 Microsoft Visual C++ 5.0 [Overlay]&#10;      4 Borland Delphi 4.0 - 5.0 [Overlay]&#10;      4 Borland C++ 1999 [Overlay]&#10;      4 Borland C++ 1999&#10;      4 Armadillo 3.78 - 4.xx -&#62; Silicon Realms Toolworks&#10;      4 Armadillo 1.xx - 2.xx -&#62; Silicon Realms Toolworks&#10;      4 ASProtect 2.1x SKE -&#62; Alexey Solodovnikov&#10;      3 nSPack 3.7 -&#62; North Star/Liu Xing Ping [Overlay]&#10;      3 Upack 0.39 beta -&#62; Dwing&#10;      3 UPX 0.80 - 1.24 DLL -&#62; Markus &#38; Laszlo [Overlay]&#10;      3 Themida 1.2.0.1 (compressed) -&#62; Oreans Technologies [Overlay]&#10;      3 Themida 1.2.0.1 (compressed) -&#62; Oreans Technologies&#10;      3 NsPack 3.4 -&#62; North Star *&#10;      3 NakedPacker 1.0 - by BigBoote *&#10;      3 MinGW GCC 3.x [ZIP SFX] *&#10;      3 Microsoft Visual C++ [Overlay]&#10;      3 Microsoft Visual C++ 6.0 SPx Method 1&#10;      3 Microsoft Visual Basic 5.0 - 6.0 [Overlay]&#10;      3 Inno Setup Module Heuristic Mode [Overlay]&#10;      3 ASProtect 2.1x SKE -&#62; Alexey Solodovnikov [Overlay]&#10;      2 tElock 0.90 -&#62; tE! [Overlay]&#10;      2 Upack 0.28 - 0.399 (relocated image base) - Delphi, .NET, DLL -&#62; Dwing&#10;      2 Upack 0.24 - 0.29 beta -&#62; Dwing&#10;      2 UltraProtect 1.x -&#62; RISCO Software Inc. [Overlay]&#10;      2 UltraProtect 1.x -&#62; RISCO Software Inc.&#10;      2 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo [RAR SFX]&#10;      2 SVKP 1.3x -&#62; Pavol Cerven&#10;      2 PureBasic DLL -&#62; Neil Hodgson *&#10;      2 PEtite 2.x [Level 0] -&#62; Ian Luck&#10;      2 PE-Armor V0.7X -&#62; hying *&#10;      2 PC-Guard 5.0 -&#62; Blagoje Ceklic&#10;      2 Nullsoft Install System 2.1x [Nullsoft PiMP SFX]&#10;      2 NsPack 1.4 -&#62; Liuxingping *&#10;      2 NTKrnl Security Suite -&#62; NTKrnl Team&#10;      2 Morphine 1.4 - 2.7 -&#62; Holy_Father &#38; Ratter/29A&#10;      2 MinGW GCC 3.x *&#10;      2 Microsoft Visual C++ Private Version 1 [Overlay]&#10;      2 Microsoft Visual C++ DLL Method 1&#10;      2 Microsoft Visual C++ 7.0 Method2 [Debug] [Overlay]&#10;      2 Microsoft Visual C++ 7.0 DLL Method 3&#10;      2 Microsoft Visual C++&#10;      2 Microsoft Visual Basic 5.0 / 6.0 [Debug]&#10;      2 MASM32 / TASM32&#10;      2 EXECryptor 2.2.4 -&#62; Strongbit/SoftComplete Development (h1) *&#10;      2 EXECryptor 1.x.x -&#62; SoftComplete Developement&#10;      2 Borland Delphi DLL&#10;      2 Borland Delphi 6.0 [Overlay]&#10;      2 Borland Delphi 3.0&#10;      2 Borland C++ DLL Method 2 [Overlay]&#10;      1 yoda&#39;s Protector 1.3 -&#62; Ashkbiz Danehkar&#10;      1 yoda&#39;s Protector 1.03.3 -&#62; Ashkbiz Danehkar&#10;      1 yoda&#39;s Protector 1.03.2 -&#62; Ashkbiz Danehkar&#10;      1 tElock v0.90 [Overlay] *&#10;      1 tElock v0.90 *&#10;      1 tElock 1.0 (private) -&#62; tE!&#10;      1 tElock 0.61 -&#62; tE!&#10;      1 nSpack V2.3 -&#62; LiuXingPing *&#10;      1 eXPressor 1.3.0 -&#62; CGSoftLabs&#10;      1 Winkript 1.0 -&#62; Mr. Crimson/WKT&#10;      1 WinRAR 32-bit SFX Module [RAR SFX] *&#10;      1 WWPack32 1.x -&#62; Piotr Warezak&#10;      1 Upack 0.28 - 0.399 (relocated image base) - Delphi, .NET, DLL -&#62; Dwing [Overlay]&#10;      1 Upack 0.24 - 0.29 beta -&#62; Dwing [Overlay]&#10;      1 UPX 1.03 - 1.04 -&#62; Markus &#38; Laszlo [Overlay]&#10;      1 UPX 1.03 - 1.04 -&#62; Markus &#38; Laszlo&#10;      1 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo [Nullsoft PiMP SFX]&#10;      1 Themida 1.8.x.x -&#62; Oreans Technologies [Overlay] *&#10;      1 Themida -&#62; Oreans Technologies 2004 *&#10;      1 SafeDisc 2.05.030 -&#62; Macrovision [Overlay]&#10;      1 RLPack V1.11 -&#62; ap0x [Overlay] *&#10;      1 RLPack 1.20 Basic Edition [aPLib] -&#62; Ap0x *&#10;      1 RCryptor v1.6d --&#62; Vaska *&#10;      1 Pelles C 3.00, 4.00, 4.50 EXE (X86 CRT-LIB) [Overlay]&#10;      1 PKLITE32 v1.1 *&#10;      1 PEtite 2.x [Level 1/9] -&#62; Ian Luck [Overlay]&#10;      1 PEtite 2.x [Level 1/9] -&#62; Ian Luck&#10;      1 PEncrypt 4.0 Gamma / 4.0 Phi -&#62; junkcode&#10;      1 PESpin 0.3x - 1.xx -&#62; cyberbob&#10;      1 PECompact 2.xx --&#62; BitSum Technologies [Overlay] *&#10;      1 PECompact 2.xx --&#62; BitSum Technologies *&#10;      1 PECompact 1.40 - 1.45 -&#62; Jeremy Collake [Overlay]&#10;      1 PEBundle 2.0x - 2.4x-&#62; Jeremy Collake&#10;      1 PEBundle 0.2 - 3.x -&#62; Jeremy Collake&#10;      1 PE Pack 1.0 -&#62; ANAKiN [Overlay]&#10;      1 PE Pack 1.0 -&#62; ANAKiN&#10;      1 PE Crypt 1.02 -&#62; random, killa &#38; acpizer&#10;      1 Obsidium 1.3.0.4 -&#62; Obsidium Software [Overlay]&#10;      1 Nullsoft PiMP stub [Nullsoft PiMP SFX]&#10;      1 Nullsoft Install System 2.x [Nullsoft PiMP SFX]&#10;      1 NsPack 2.9 -&#62; North Star [Overlay] *&#10;      1 Nothing found [CAB SFX] *&#10;      1 NSPack 3.x -&#62; Liu Xing Ping *&#10;      1 Morphine 1.4 - 2.7 -&#62; Holy_Father &#38; Ratter/29A [Overlay]&#10;      1 MoleBox v2.0 [Overlay] *&#10;      1 Microsoft Visual C++ 8.0 [Debug] [Overlay]&#10;      1 Microsoft Visual C++ 7.0 Method2 [Overlay]&#10;      1 Microsoft Visual C++ 7.0 DLL Method 3 [Overlay]&#10;      1 Microsoft Visual C++ 6.0 [ZIP SFX]&#10;      1 Microsoft Visual C++ 6.0 SPx Method 1 [Overlay]&#10;      1 Microsoft Visual C++ 6.0 DLL [Debug]&#10;      1 Microsoft Visual C++ 4.x [Overlay]&#10;      1 Microsoft Visual C++ 4.x [Debug]&#10;      1 Microsoft Visual Basic 6.0 DLL [Overlay]&#10;      1 Microsoft CAB SFX module&#10;      1 LCC Win32 1.x -&#62; Jacob Navia&#10;      1 KByS V0.28 -&#62; shoooo [Overlay] *&#10;      1 KByS V0.22 -&#62; shoooo *&#10;      1 InstallShield AFW [Overlay]&#10;      1 Install Stub 32-bit -&#62; InstallShield [Overlay]&#10;      1 Inno Installer 4.0.5 [Inno SFX]&#10;      1 FSG 2.0 -&#62; bart/xt&#10;      1 EZIP 1.0 -&#62; Jonathan Clark [Overlay]&#10;      1 EXECryptor 1.x.x -&#62; SoftComplete Developement [Overlay]&#10;      1 CD-Cops II -&#62; Link Data Security [Overlay]&#10;      1 Borland Delphi DLL [Overlay]&#10;      1 Borland Delphi 5.0 KOL/MCK [Overlay]&#10;      1 Borland Delphi 5.0 KOL [Overlay]&#10;      1 Borland Delphi 3.0 [Overlay]&#10;      1 Borland Delphi 2.0 [Inno SFX]&#10;      1 Borland Delphi 2.0&#10;      1 Borland Component&#10;      1 Armadillo v1.71 [Overlay] *&#10;      1 Armadillo 3.78 - 4.xx -&#62; Silicon Realms Toolworks [Overlay]&#10;      1 Armadillo 2.01 -&#62; Silicon Realms Toolworks [Overlay]&#10;      1 ASProtect SKE 2.1x (exe) -&#62; Alexey Solodovnikov [Overlay] *&#10;      1 ASProtect 2.0x Registered -&#62; Alexey Solodovnikov [Overlay]&#10;      1 ASProtect 2.0x Registered -&#62; Alexey Solodovnikov&#10;      1 ASProtect 1.33 - 2.1 Registered -&#62; Alexey Solodovnikov [Overlay] *&#10;      1 ASProtect 1.2 / 1.2c-&#62; Alexey Solodovnikov&#10;      1 ASPack 2.12b -&#62; Alexey Solodovnikov&#10;      1 ASPack 1.08.03 -&#62; Alexey Solodovnikov [Overlay]&#10;      1 ASPack 1.06b / 1.061b -&#62; Alexey Solodovnikov [Overlay]&#10;      1 AHTeam EP Protector 0.3 (fake Microsoft Visual C++ 7.0) -&#62; FEUERRADER *&#10;      1 ACProtect V2.0 -&#62; risco *&#10;      1 ACProtect 2.00 - RISCO Software Inc. [Overlay]&#10;      1 ACProtect 1.40 - 1.41 - RISCO Software Inc.&#10;      1 .BJFNT 1.1b -&#62; :MARQUiS:&#10;      1 * PseudoSigner 0.2 [Microsoft Visual Basic 5.0 - 6.0] --&#62; Anorganix [Overlay] *&#10;      1 * PseudoSigner 0.2 [Microsoft Visual Basic 5.0 - 6.0] --&#62; Anorganix *</span><br></pre></td></tr></table></figure>
<p>ほとんど検出できていないのが残念．ひときわ面倒なThemidaは11検体だった．</p>
<h1 id="サンドボックスの実態">サンドボックスの実態</h1><p>サンドボックスの透明性が研究されている一方で，実際のマルウェアはあまり凝ったAnti-VMを備えていなかった．<br>一方で，現実のサンドボックスはどうだろうか．いくら論文で優れた手法が編み出されようが，役立てられていなければ意味がない．<br>そこで，一般に公開されているサンドボックスに対してシステム情報を取得するプログラムを挿入し，仮想マシンモニタの種類を判別できるかどうか試してみたのだが，実態はあまりにもお粗末だった．<br>詳細は言うまい．<br>だが，systeminfoコマンドとNtQuerySystemInformationだけで露見する代物ばかりだった．<br>マルウェアの解析ではなく検出を目的としたサービス，言ってしまえばVirusTotalをサンドボックスのフロントエンドとしたことが，この一因として挙げられる．<br>凝ったAnti-VMを備えたマルウェアがあまり多くないことも考えると，現状のサンドボックスで十分だということなのだろうか．</p>
<h1 id="感想">感想</h1><p>研究をしているうちに袋小路に突入してしまい，サンドボックスの透明性やAnti Anti-VMあくまでマルウェア解析の一側面に過ぎないことを私は忘れかけていた．<br>本質は別のところにある．</p>
<h1 id="TEQUILABOOMBOOM">TEQUILABOOMBOOM</h1><p>公開されているサンドボックスの中にTEQUILABOOMBOOMというホスト名のものがあった．<br><a href="http://www.virusradar.com/en/Win32 Kasidet.AA/description" target="_blank" rel="external">Trojan.Win32.Inject.uljv</a>や<a href="http://securitykitten.github.io/vm-checking-and-detecting/" target="_blank" rel="external">Backdoor.Win32.Agent.dkbp</a>など一部のマルウェアは，このホスト名に基づいてサンドボックスを検出することが知られている．調べてみると，<a href="http://webcache.googleusercontent.com/search?q=cache:hackforums.net/printthread.php?tid=3733605" target="_blank" rel="external">Question about keylogged PC - Printable Version</a>や<a href="http://webcache.googleusercontent.com/search?q=cache:wrb-hdtEFFkJ:www.hackforums.net/showthread.php%3Ftid%3D4522377%26page%3D16+&amp;cd=9&amp;hl=ja&amp;ct=clnk&amp;gl=jp" target="_blank" rel="external">[FUD][FREE] Agent Tesla [Keylogger] [ClipboardLogger] [On-Screen Keyboard Logger] - Page 16</a>など，2013年の時点で情報が攻撃者の間で共有されている．</p>
<blockquote>
<p>So I managed to crypt a keylogger and have my victim download it through dropbox (I think). I haven’t received any logs yet but it shows that I’m connected to a computer from france which is janettedoe@TEQUILABOOMBOOM. I’m not sure how this is possible, or if it’s some sort of error. Does anybody know what this is? My keylogger hasn’t been sent anywhere other than to my targets email. </p>
</blockquote>
<p>どうやらこれはGoogleが動かしているCuckoo Sandboxが用いるホスト名らしく，攻撃者によるサンドボックスの実態調査が進んでいることを伺わせる．<br>サンドボックスの透明性について拘りすぎる必要はないにせよ，その情報が攻撃者の手に渡ることを前提としたサービスについては検討の余地がある．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Gabriel Negreira Barbosa, Rodrigo Rubira Branco,<br>“<a href="https://www.blackhat.com/docs/us-14/materials/us-14-Branco-Prevalent-Characteristics-In-Modern-Malware.pdf" target="_blank" rel="external">Prevalent Characteristics in Modern Malware[PDF]</a>,”<br>Black Hat USA 2014.</li>
<li>Gábor Pék, Levente Buttyán, Boldizsár Bencsáth,<br>“<a href="http://www.profsandhu.com/cs6393_s14/csur_hw_virt_2013.pdf" target="_blank" rel="external">A Survey of Security Issues in Hardware Virtualization[PDF]</a>,”<br>ACM Computing Surveys, vol. 45, issue. 3, 2013.</li>
<li>“VirusShare.com,” <a href="http://virusshare.com/" target="_blank" rel="external">http://virusshare.com/</a></li>
<li><a href="http://intelreport.mandiant.com/Mandiant_APT1_Report.pdf" target="_blank" rel="external">http://intelreport.mandiant.com/Mandiant_APT1_Report.pdf[PDF]</a></li>
<li>“YARA - The pattern matching swiss knife for malware researchers,” <a href="http://plusvic.github.io/yara/" target="_blank" rel="external">http://plusvic.github.io/yara/</a></li>
<li>“PEiD Download - Softpedia,” <a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml" target="_blank" rel="external">http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml</a></li>
<li>“Win32/Kasidet.AA | ESET Virusradar,” <a href="http://www.virusradar.com/en/Win32 Kasidet.AA/description" target="_blank" rel="external">http://www.virusradar.com/en/Win32 Kasidet.AA/description</a></li>
<li>“VM Checking and Detecting Adventures in Security,” <a href="http://securitykitten.github.io/vm-checking-and-detecting/" target="_blank" rel="external">http://securitykitten.github.io/vm-checking-and-detecting/</a></li>
<li>“Question about keylogged PC - Printable Version,” <a href="http://webcache.googleusercontent.com/search?q=cache:hackforums.net/printthread.php?tid=3733605" target="_blank" rel="external">http://webcache.googleusercontent.com/search?q=cache:hackforums.net/printthread.php?tid=3733605</a></li>
<li>“[FUD][FREE] Agent Tesla [Keylogger] [ClipboardLogger] [On-Screen Keyboard Logger] - Page 16],” <a href="http://webcache.googleusercontent.com/search?q=cache:wrb-hdtEFFkJ:www.hackforums.net/showthread.php%3Ftid%3D4522377%26page%3D16+&amp;cd=9&amp;hl=ja&amp;ct=clnk&amp;gl=jp" target="_blank" rel="external">http://webcache.googleusercontent.com/search?q=cache:wrb-hdtEFFkJ:www.hackforums.net/showthread.php%3Ftid%3D4522377%26page%3D16+&amp;cd=9&amp;hl=ja&amp;ct=clnk&amp;gl=jp</a></li>
<li>Katsunari Yoshioka, Yoshihiko Hosobuchi, Tatsunori Orii, Tsutomu Matsumoto,<br>“<a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=5598065&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5598065" target="_blank" rel="external">Vulnerability in Public Malware Sandbox Analysis Systems</a>,”<br>IEEE/IPSJ 12th International Symposium on Applications and the Internet, pp. 265-268, 2010.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/03/14/sandbox-transparency-in-the-wild/" data-id="cilaj6h1600139sos0jihyhze" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-before-c-constructor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/02/24/before-c-constructor/">__attribute__((constructor))が呼ばれる前に</a>
  

      </header>
    
    <time class="article-date" datetime="2015-02-24T13:46:08.000Z" itemprop="datePublished">02-24-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="__attribute__((constructor))"><code>__attribute__((constructor))</code></h1><p><code>main()</code>が呼ばれる前に関数を呼ぶ方法として，一般にgcc拡張である<code>__attribute__((constructor))</code>が利用されている．<br>例えば次のコードでは，<code>main()</code>の前に<code>constructor()</code>が呼び出される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdio.h&#62;&#10;&#10;__attribute__((constructor)) void constructor()&#123;&#10;  printf(&#34;constructor\n&#34;);&#10;&#125;&#10;&#10;int main()&#123;&#10;  printf(&#34;main\n&#34;);&#10;  return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="__libc_start_main()"><code>__libc_start_main()</code></h1><p>gccが内部で呼び出すldは，glibcの初期化を行うためにcrt*.oを静的リンクする．これによって，<code>_start()</code>などのシンボルがバイナリに埋め込まれることになる．<br>ここで埋め込まれるシンボルには未定義なものが存在する．その一つとして，crt1.oに含まれる<code>__libc_start_main()</code>が挙げられる．<br>これは<code>main()</code>より先んじて呼び出される関数であり，暗黙的にcrt1.oがリンクの対象となる．しかし未定義であるがゆえに，先にソースコードに<code>__libc_start_main()</code>が宣言されていた場合，ldはこちらをシンボルとして採用してしまう．</p>
<h1 id="どちらが先か">どちらが先か</h1><p>上記を踏まえて，次のコードではどちらの関数が先に呼び出されるだろうか．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdio.h&#62;&#10;&#10;__attribute__((constructor)) void constructor()&#123;&#10;  printf(&#34;constructor\n&#34;);&#10;&#125;&#10;&#10;int __libc_start_main()&#123;&#10;  printf(&#34;__libc_start_main\n&#34;);&#10;  return 0;&#10;&#125;&#10;&#10;int main()&#123;&#10;  printf(&#34;main\n&#34;);&#10;  return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>正解は<code>__libc_start_main()</code>だ．私は実行するまで分からなかった．</p>
<h1 id="__do_global_ctors_aux()"><code>__do_global_ctors_aux()</code></h1><p>なぜ<code>__libc_start_main()</code>が<code>__attribute__((constructor))</code>よりも先に呼び出されるのか．それは<code>__attribute__((constructor))</code>が，<code>__do_global_ctors_aux()</code>によって実現されているからだ．<br><code>__do_global_ctors_aux()</code>は<code>_start()</code>, <code>__libc_start_main()</code>, <code>__libc_csu_init()</code>, <code>_init()</code>を通ってようやく呼び出される．そのため，<code>__libc_start_main()</code>の方がより先んじて呼び出されるのだ．</p>
<h1 id="__libc_csu_init()"><code>__libc_csu_init()</code></h1><p>Sigreturn-oriented Programmingでにわかに脚光を浴びている<code>__libc_csu_init()</code>は<code>__libc_start_main()</code>の引数にセットされるコンストラクタだが，シンボルを上書きして<code>__libc_start_main()</code>の代わりにこちらを<code>main()</code>ないし<code>__attribute__((constructor))</code>の先に呼び出すこともできる．<br>当初私は<code>__attribute__((constructor))</code>はこの辺りから呼び出されるものだと誤解していた．</p>
<h1 id="Windowsでは">Windowsでは</h1><p>今回は触れないが，<code>.CRT$X??</code>のセクションや<code>Thread Local Storage</code>のコールバックによって同様の機能を実現できる．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>高林哲, 鵜飼文敏, 佐藤祐介, 浜地慎一郎, 首藤 一幸,<br>“Binary Hacks - ハッカー秘伝のテクニック100選,”<br>オライリー・ジャパン, 2006.</li>
<li>“Linux x86 Program Start Up,”<br><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html" target="_blank" rel="external">http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/02/24/before-c-constructor/" data-id="cilaj6h1y001t9sos1ss279u0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploiting/">exploiting</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-xen-libvmi" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/01/31/xen-libvmi/">XenとLibVMI</a>
  

      </header>
    
    <time class="article-date" datetime="2015-01-31T14:39:37.000Z" itemprop="datePublished">01-31-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p><a href="https://github.com/libvmi/libvmi" target="_blank" rel="external">LibVMI</a>はXenならびにKVMを対象としたVMIライブラリである．ここでは，その基盤と応用についてまとめる．</p>
<h1 id="libxc">libxc</h1><p>そもそもXenにおけるVMIの研究ではかねてより，各ドメインの制御機能ないしハイパーコールを提供するlibxcというライブラリが用いられてきた．libxcという名称はthe Xen Control libraryの略称であり，Xenによって公式に提供されている(<code>tools/libxc/</code>)．なお，libxcとして提供されている関数は<code>xc_</code>というprefixを備えている．<br>このうち，VMIと密接に関連があるのは<code>xenctrl.h</code>と<code>xenguest.h</code>である．なかでも<code>xenctrl.h</code>はlibxenctrlとも呼ばれ，PFNの参照やハイパーコールの追加などの機能が提供されている．<br>LibVMIのソースコードにgrepを掛けると，libxcに由来する構造体と関数が多く用いられていることが分かる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% grep -rhoe &#34;xc_[a-zA-z]*_[a-zA-z]*&#34; . | grep -v &#34;]&#34; | sort | uniq&#10;xc_domain_debug_control&#10;xc_domain_decrease_reservation_exact&#10;xc_domain_getinfo&#10;xc_domain_getinfolist&#10;xc_domain_hvm_getcontext&#10;xc_domain_hvm_getcontext_partial&#10;xc_domain_hvm_setcontext&#10;xc_domain_maximum_gpfn&#10;xc_domain_pause&#10;xc_domain_populate_physmap_exact&#10;xc_domain_set_access_required&#10;xc_domain_unpause&#10;xc_domaininfo_t&#10;xc_dominfo_t&#10;xc_evtchn_bind_interdomain&#10;xc_evtchn_close&#10;xc_evtchn_fd&#10;xc_evtchn_notify&#10;xc_evtchn_open&#10;xc_evtchn_pending&#10;xc_evtchn_t&#10;xc_evtchn_unbind&#10;xc_evtchn_unmask&#10;xc_get_hvm_param&#10;xc_hvm_get_mem_access&#10;xc_hvm_inject_trap&#10;xc_hvm_set_mem_access&#10;xc_interface_close&#10;xc_interface_open&#10;xc_map_foreign_batch&#10;xc_map_foreign_range&#10;xc_mem_access_disable&#10;xc_mem_access_enable&#10;xc_mem_access_resume&#10;xc_mem_event_disable&#10;xc_mem_event_enable&#10;xc_memory_op&#10;xc_set_hvm_param&#10;xc_set_mem_access&#10;xc_vcpu_getcontext&#10;xc_vcpu_setcontext</span><br></pre></td></tr></table></figure>
<p>とりわけVMIにおいて重要なのは<code>xc_map_foreign_range()</code>という関数である．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *xc_map_foreign_ranges(xc_interface *xch, uint32_t dom,&#10;                            size_t size, int prot, size_t chunksize,&#10;                            privcmd_mmap_entry_t entries[], int nentries);</span><br></pre></td></tr></table></figure>
<p>Xenの各ドメインにはドメインや仮想CPUの構造体(<code>xen/include/xen/sched.h</code>)のほか，マシンメモリ（物理メモリ）と擬似物理メモリが割り当てられる．ドメインにおけるページングは，このマシンフレーム番号(MFN)と疑似物理フレーム番号(PFN)とを対応付けるP2Mテーブルによって実現されている．つまり，ドメインの仮想アドレスは擬似物理メモリフレーム番号に対応し，その疑似物理フレーム番号はさらにマシンフレーム番号に対応する．なお，Intel EPTが有効な環境においてはP2MはEPTによって代替される(<code>ept-p2m.c</code>)．<br><code>xc_map_foreign_range()</code>はこうした仕組みに基づき，ページテーブルを辿ってDom0のメモリ空間にDomUのマシンフレームを割り当てる．<br>VMIに求められるデータ構造の解釈はXenにおいて，この関数があることから成り立つものである．また，これによるフォールトインジェクションに関してもかつて研究が行われていたようだ．</p>
<h1 id="libxenstore">libxenstore</h1><p>Xenではxenstore-lsやxenstore-readなどのコマンドからxenstoredというデーモンを経由して各ドメインの情報を読み出すことができる．この仕組みをXenStoreといい，関連してlibxenstoreというライブラリが提供されている．(<code>tools/xenstore/</code>)．libxsと呼ばれることもある．<br>XenStoreは名の通りKVSとしてドメインのUUIDやドメイン名，メモリのコミット状況などを格納している．<br>LibVMIにおいても，xenstordへのアクセスのため用いられている(<code>xen_private.h</code>)．</p>
<h1 id="libxenlight">libxenlight</h1><p>libxenlightはlibxcとlibxenstoreのラッパとして公式に開発されているライブラリである(<code>tools/libxl/</code>)．<br>LibVMIでは用いられていないものの，Xen Projectの本流ではこちらが推進されているように見受けられる．</p>
<h1 id="XenAccess">XenAccess</h1><p><a href="https://code.google.com/p/xenaccess/" target="_blank" rel="external">XenAccess</a>はlibxcのラッパであり，LibVMIの前身にあたる．<br>目的としてセマンティックギャップの解決が掲げられており，任意のPIDに対応するEPROCESS構造体を取得することができる．<br>EPROCESS構造体はWindowsの各プロセスに割り当てられる構造体であり，Windowsのプロセスリストはこの構造体のActiveProcessLinksメンバからなる双方向リンクリストによって成り立っている．タスクマネージャが参照するのはこの構造体である．<br>XenAccessはこの構造体を手掛かりにカーネルのベースアドレスを取得する．<br>まず，メモリ空間をPEヘッダの先頭すなわちMZという文字列で検索する．そして，発見したアドレスについてシステムプロセス固有のPsInitialSystemProcessのオフセットを加算し，EPROCESS構造体の先頭メンバである_EPROCESS.Pcb.headerにあたるシグネチャと比較する．一致した場合，発見したアドレスがベースアドレスということになる(<code>windows_memory.c</code>, <code>windows_core.c</code>, <code>windows_process.c</code>)．<br>これによって，プロセスリストと任意のプロセスの情報を取得することができるようになった．</p>
<h1 id="LibVMI">LibVMI</h1><p>LibVMIはXenAccessの後継であり，かつてvmitoolsとも呼ばれていた．<br>先述したようなカーネル空間の解析機能をLibVMIはフォレンジックツールに委譲した．フォレンジックツールを導入するメリットとして，より詳細な構造体の解析を低い実装コストで実現できるという点が挙げられる．<br>さて，LibVMIは<a href="https://github.com/volatilityfoundation/volatility" target="_blank" rel="external">Volatility</a>と<a href="https://github.com/google/rekall" target="_blank" rel="external">Rekall</a>という二種類のフォレンジックツールに対応している．RekallはGoogleによるVolatilityの拡張であり，かつてはLibVMIのサポート外だったものの，<a href="https://github.com/libvmi/libvmi/commit/a4f065a31b986562dc39c9a10d9dff080792f3f4" target="_blank" rel="external">commit a4f065a31b986562dc39c9a10d9dff080792f3f4</a>にて導入された．<br>では，両者の差異はどこにあるのか．</p>
<h1 id="Kernel_Debugger_Block">Kernel Debugger Block</h1><p>XenAccessが行っていたようなEPROCESS構造体のスキャンについて考えてみよう．<br>VolatilityとRekallはいずれも，まずリンクリストの先頭であるPsActiveProcessHeadを特定しようとする．<br>x86において，このPsActiveProcessHeadは，KPCR(Kernel Processor Control Region)構造体のKdVersionBlockメンバが示すKDDEBUGGER_DATA32構造体から取得することができる．<br>このKPCR構造体だが，x86ではFSレジスタ，x86_64ではGSレジスタが先頭アドレスを保持しており，Windows XPでは0xFFDFF000というマジックナンバーを用いて検索することができる．<br>では，KdVersionBlockはどうか．なんと，Windows 7の64-bit版からこのメンバは空になってしまっている．ゆえに，x86_64ではKDDEBUGGER_DATA64構造体をKdVersionBlockに頼らず検索する必要が生ずる．<br>ここで，VolatilityはKDDEBUGGER_DATA64構造体のヘッダに存在するKDBGシグネチャをスキャンするのに対し(<code>kdbgscan.py</code>)，Rekallはカーネルのバージョンに対応したプロファイル情報を用いて構造体にアクセスする．</p>
<h1 id="DRAKVUF">DRAKVUF</h1><p><a href="https://github.com/tklengyel/drakvuf" target="_blank" rel="external">DRAKVUF</a>はTamas K Lengyelによって開発されたサンドボックスであり，論文のオーサーにはXenAccessとLibVMIの開発者であるBryan D. Payneも名を連ねている．<br>LibVMIにRekallのサポートを追加したのがほかでもないTamas K Lengyelその人である．<br>Volatilityは前述の通りメモリからKDBG構造体を検索する．だが，ゲストOSのメモリはマルウェアによって改竄されてしまうおそれがあることに加え，Windows 8の64-bit版ではKDBG構造体が難読化されているという問題点がある．<br>一方で，Rekallのプロファイルはゲストから不可視であり，改竄の影響を受けないため，この問題を解決することができる．<br>DRAKVUFはマルウェア解析を目的としてLibVMIを拡張しており，当然プログラムの実行をトラップする機能を備えている．<br>特筆すべきは，Intel EPTを用いたメモリアクセスの監視である(<code>vmi.c</code>)．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Now we can set the EPT permissions&#10;if (!container-&#62;guard) &#123;&#10;    container-&#62;guard = g_malloc0(sizeof(vmi_event_t));&#10;    SETUP_MEM_EVENT(container-&#62;guard, container-&#62;pa, VMI_MEMEVENT_PAGE,&#10;            VMI_MEMACCESS_RW, trap_guard);&#10;    if (VMI_FAILURE == vmi_register_event(vmi, container-&#62;guard)) &#123;&#10;        printf(&#34;*** FAILED TO REGISTER MEMORY GUARD @ PAGE %lu ***\n&#34;,&#10;                pa &#62;&#62; 12);&#10;        free(container-&#62;guard);&#10;        free(container);&#10;        continue;&#10;    &#125;&#10;    container-&#62;guard-&#62;data = g_hash_table_new(g_int64_hash,&#10;            g_int64_equal);&#10;    printf(&#34;\t\tNew memory event trap set on page %lu\n&#34;, pa &#62;&#62; 12);&#10;&#125; else &#123;&#10;    printf(&#34;\t\tMemory event trap already set on page %lu\n&#34;, pa &#62;&#62; 12);&#10;&#125;&#10;&#10;struct memevent *test = g_hash_table_lookup(container-&#62;guard-&#62;data,&#10;        &#38;container-&#62;pa);&#10;if (!test) &#123;&#10;    g_hash_table_insert(container-&#62;guard-&#62;data, &#38;container-&#62;pa,&#10;            container);&#10;&#125; else if (test-&#62;sID == SYMBOLWRAP) &#123;&#10;    printf(&#34;Address is already guarded\n&#34;);&#10;&#125; else &#123;&#10;    printf(&#34;Address is trapped by another feature! ERROR/TODO!\n&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>このアイデア自体はKVMをベースとして開発されたCXPInspectorを下敷きにしている．<br>かつては任意のアドレスについてNX bitを設定し，ページフォルトハンドラをブレークポイントとする手法が一般的であった．これがカーネル空間から可視であるのに対し，EPTは不可視であるためよりカーネルルートキットの解析に適している．</p>
<h1 id="おわりに">おわりに</h1><p>LibVMIの登場と洗練によってもはや，セマンティックギャップは過去の問題になりつつある．XenにおけるVMIにおいて，これを用いない手はないだろう．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>“Where to start with Xen? - Stack Overflow,”<br><a href="http://stackoverflow.com/questions/11575299/where-to-start-with-xen" target="_blank" rel="external">http://stackoverflow.com/questions/11575299/where-to-start-with-xen</a></li>
<li>Linux Technical Sales, IBM Japan,<br>“Xen ハイパーバイザー準仮想化モードの内部構造入門,”<br><a href="http://www-06.ibm.com/jp/linux/tech/doc/attachments/00393cd9_xen_pv_internal_v1_0.pdf" target="_blank" rel="external">http://www-06.ibm.com/jp/linux/tech/doc/attachments/00393cd9_xen_pv_internal_v1_0.pdf[PDF]</a></li>
<li>Kenichi Kourai and Shigeru Chiba,<br>“<a href="http://dl.acm.org/citation.cfm?id=1065006&amp;dl=ACM&amp;coll=DL&amp;CFID=595394357&amp;CFTOKEN=42837423" target="_blank" rel="external">HyperSpector: Virtual Distributed Monitoring Environments for Secure Intrusion Detection</a>,”<br>Proceedings of the 1st ACM/USENIX International Conference on Virtual Execution Environments, pp. 197-207, NY, USA, 2005.</li>
<li>新井 昇鎬, 千葉 滋,<br>“<a href="http://www.csg.ci.i.u-tokyo.ac.jp/paper/tadokoro-master2009.pdf" target="_blank" rel="external">複数OSに対応した仮想マシン間プロセススケジューリング[PDF]</a>,”<br>学士論文, 東京工業大学, 2009.</li>
<li>安積 武志, 千葉 滋,<br>“<a href="http://www.csg.ci.i.u-tokyo.ac.jp/paper/azumi-master2011.pdf" target="_blank" rel="external">踏み台攻撃だけを抑制できるVMMレベルパケット・フィルタ[PDF]</a>,”<br>修士論文, 東京工業大学, 2011.</li>
<li>Bryan D. Payne, Martim D. P. de A. Carbone, and Wenke Lee,<br>“<a href="http://www.acsac.org/2007/papers/138.pdf" target="_blank" rel="external">Secure and Flexible Monitoring of Virtual Machines[PDF]</a>“,<br>Proceedings of the 23rd Annual Computer Security Applications Conference, pp. 385-397, Miami Beach, FL, 2007.</li>
<li>Bryan D. Payne,<br>“<a href="http://prod.sandia.gov/techlib/access-control.cgi/2012/127818.pdf" target="_blank" rel="external">Simplifying Virtual Machine Introspection Using LibVMI[PDF]</a>,”<br>SANDIA REPORT, 2012.</li>
<li>“Do we need the Kernel Debugging Block? - Rekall Memory Forensic Flamework,”<br><a href="http://www.rekall-forensic.com/posts/2014-02-21-do-we-need-kdbg.html" target="_blank" rel="external">http://www.rekall-forensic.com/posts/2014-02-21-do-we-need-kdbg.html</a></li>
<li>Amit Vasudevan, Ramesh Yerraballi,<br>“<a href="https://www.acsac.org/2005/papers/72.pdf" target="_blank" rel="external">Stealth Breakpoints[PDF]</a>,”<br>Proceedings of the 21st Annual Computer Security Applications Conference, pp. 381-392, AZ, USA, 2005.</li>
<li>Carsten Willems, Ralf Hund, and Thorsten Holz,<br>“<a href="https://www.hgi.rub.de/media/emma/veroeffentlichungen/2012/11/26/TR-HGI-2012-002.pdf" target="_blank" rel="external">CXPInspector: Hypervisor-Based, Hardware-Assisted System Monitoring[PDF]</a>,”<br>Technical Report TR-HGI-2012-002, Ruhr-Uni­ver­si­tät Bo­chum, Horst Görtz Institut für IT-Sicherheit(HGI), 2012.</li>
<li>Tamas K. Lengyel, Steve Maresca, Bryan D. Payne, George D. Webster, Sebastian Vogl, and Aggelos Kiayias,<br>“<a href="https://www.sec.in.tum.de/assets/Uploads/scalability-fidelity-stealth.pdf" target="_blank" rel="external">Scalability, Fidelity and Stealth in the DRAKVUF Dynamic Malware Analysis System[PDF]</a>,”<br>Proceedings of the 30th Annual Computer Security Applications Conference, pp. 386-395, NY, USA, 2014.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/01/31/xen-libvmi/" data-id="cilaj6h0b00059sos4xg5zo8d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/forensics/">forensics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sandbox-transparency" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/01/23/sandbox-transparency/">サンドボックスの透明性</a>
  

      </header>
    
    <time class="article-date" datetime="2015-01-23T14:45:59.000Z" itemprop="datePublished">01-23-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="VMI">VMI</h1><p>仮想マシンモニタからゲストのリソースを監視・制御する技術をVMI(Virtual Machine Introspection)という．<br>その発祥は2003年に遡る．当時はハニーポットの研究が盛んな時期であり，VMIは仮想マシンにおける侵入検知を実現する手法として提案された．これはマルウェア解析の自動化に応用されており，仮想マシンモニタによるサンドボックスを構築し，VMIによってマルウェアの挙動を監視するというアプローチが一般的となっている．<br>さて，VMIにおける問題点にセマンティックギャップというものがある．原義は高級言語とハードウェアとの乖離であるが，OSと同じ粒度で情報を取得することのできるゲスト内部(in-the-box)とハードウェアの粒度で情報を取得することしかできないゲスト外部(out-of-the-box)の乖離という意味でも援用される．</p>
<h1 id="Transparent_Sandbox">Transparent Sandbox</h1><p>セマンティックギャップを解決する方法として，ゲスト内部にエージェントを挿入し，仮想マシンモニタに情報を送信するというアプローチが考えられる．<br>だがマルウェア解析において，ゲスト内部にエージェントを挿入することは，自らの姿を曝け出していることにほかならない．ファイルやサービス名，フックによって変化するAPIの挙動といったものは，マルウェアがエージェントと同じ権限で動作する限り避けられない．そもそも仮想マシンモニタは特権を有していたところで<code>RDTSC</code>や<code>ICEBP</code>などの命令，あるいはハードウェア名やIDTといった要素から検出される可能性を孕んでいる．そのため，ゲスト内部にエージェントを挿入することは，仮想マシンモニタがマルウェアから検出される可能性を高めることに繋がる．フォレンジックにおける完全性(integrity)のためにも，ゲスト内部にエージェントを挿入すべきではないと私は考える．<br>この議論に関して，マルウェアから検出されない仮想マシンモニタをtransparent sandbox（透明なサンドボックス？）といい，仮想マシンモニタの検出を試みるマルウェアをevasive malwareという．<br>ではどのような仮想マシンモニタがより「透明」に近いのか．</p>
<h1 id="仮想マシンモニタの歴史">仮想マシンモニタの歴史</h1><p>ここでPopekとGoldbergの仮想化要件に立ち返ると，ベアメタルな仮想マシンモニタは等価性(equivalence)，資源管理(resource control)，効率性(efficiency)の三原則を実現しており，なおかつユーザセンシティブ命令が特権命令でなければならない．センシティブ命令かつ特権命令でなければ，例外によって仮想マシンモニタに通知することができないためである．<br>だが，以前のx86アーキテクチャはこの要件を満たしていなかった．そこで，ニ種類の解決方法が編み出された．<br>一つ目はバイナリ変換(binary translation)による完全仮想化である．これはソフトウェアで命令をエミュレートする手法で，QEMUやVMwareが該当する．QEMUは全ての命令を中間コードに変換するのに対し，VMwareはPopekとGoldbergの仮想化要件を満たさない命令をライブラリ呼び出しに変換する．<br>二つ目は準仮想化である．これはPopekとGoldbergの仮想化要件を満たさない命令に差し掛かると仮想マシンモニタに通知されるようゲストOSのカーネルを修正する手法で，Xenが該当する．<br>ではバイナリ変換による完全仮想化とカーネル書き換えによる準仮想化のどちらがより「透明」に近いのか．<br>その前にIntel VT-xについて考えなければならない．Intel VT-xはCPUのモード切り替えによってセンシティブ命令かつ特権命令でない命令のトラップを実現する拡張機能である．すなわちPopekとGoldbergの仮想化要件を満たすハードウェア側からのアプローチである．これにより準仮想化カーネルの必要はなくなった．エージェントの挿入が「透明」性に関わるのと同様，カーネルの書き換えは仮想マシンモニタを検出する手掛かりとなる．<br>そのためマルウェア解析においては，バイナリ変換による完全仮想化か，Intel VT-xによる完全仮想化が前提となる．なおKVMはIntel Vt-xを前提としているが，部分的にQEMUを用いている．<br>ではどちらの手法がより「透明」に近いのか．</p>
<h1 id="バイナリ変換とIntel_VT-x">バイナリ変換とIntel VT-x</h1><p>Christopher KruegelはWineのようなシステムコール単位のエミュレーションあるいはフックは情報量として不十分であり，またIntel VT-xによる完全仮想化はRedPillのようなアプローチで検出可能であることから，バイナリ変換による完全仮想化すなわちQEMUを支持している．<br>システムコール単位の監視は<code>IsDebuggerPresent</code>のようなカーネルモードに遷移せず構造体を参照するだけの処理を見逃してしまう．システムコールのフックを用いた研究や製品は多数存在するが，それらは不完全である．この点で私は氏と意見を一にするが，バイナリ変換がより「透明」に近いかどうかは検討の余地があるだろう．寧ろ氏は実行パスの拡張がより容易に行えるがゆえにバイナリ変換を支持しているのだろうということは読み取れるが，氏がチーフサイエンティストを務めるLastlineの製品がQEMUをベースとしていることもあり，些かポジショントークのようにも感じられる．<br>このような論調でバイナリ変換とIntel VT-xを二項対立の図式に落とし込んでいる論文が数多く見られる．しかし，どちらがより「透明」に近いのかという議論はナンセンスであろう．<br>ゲスト内部にエージェントを挿入することで，果たして本当にマルウェアから検出されやすくなるのかと言うと，それは飽くまで可能性でしかない．だがゲスト内部にエージェントを挿入しないという選択で，その問題は検討項目から外すことができる．一方で，バイナリ変換であるという理由でIntel VT-xを用いた仮想マシンモニタよりも検出されにくいといったことはない．逆もまた然りである．<br>そしてそもそも，ネットワーク経由で仮想マシンモニタを検出するという手法がある以上，完全に「透明」なサンドボックスは実現不可能であるとされる．<br>ゆえにそれぞれのアプローチについて「透明」性の他にもメリット・デメリットを検討し，なおかつ両者を接合するようなシステムこそが望ましい．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Tal Garfinkel, Mendel Rosenblu,<br>“<a href="http://suif.stanford.edu/papers/vmi-ndss03.pdf" target="_blank" rel="external">A Virtual Machine Introspection Based Architecture for Intrusion Detection[PDF]</a>,”<br>Proceedings of the 10th Annual Network and Distributed System Security Symposium, pp. 191–206, SD, USA, 2003.</li>
<li>Gerald J. Popek, Robert P. Goldberg,<br>“<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.141.4815&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Formal Requirements for Virtualizable Third Generation Architectures[PDF]</a>,”<br>Communications of the ACM CACM Homepage archive, Vol. 17, Issue. 7, pp. 412-421, NY, USA, 1974.</li>
<li>John Scott Robin, Cynthia E. Irvine,<br>“<a href="http://www.cse.psu.edu/~bhuvan/teaching/spring06/papers/analysis-pentium.pdf" target="_blank" rel="external">Analysis of the Intel Pentium’s Ability to Support a Secure Virtual Machine Monitor[PDF]</a>,”<br>Proceedings of the 9th conference on USENIX Security Symposium, Vol. 9, pp. 10-10, CA, USA, 2000.</li>
<li>Christopher Kruegel,<br>“<a href="https://www.blackhat.com/docs/us-14/materials/us-14-Kruegel-Full-System-Emulation-Achieving-Successful-Automated-Dynamic-Analysis-Of-Evasive-Malware-WP.pdf" target="_blank" rel="external">Full System Emulation: Achieving Successful Automated Dynamic Analysis of Evasive Malware[PDF]</a>,”<br>Black Hat USA, 2014.</li>
<li>Tal Garfinkel, Keith Adams, Andrew Warfield and Jason Franklin,<br>“<a href="http://www.cs.cmu.edu/~jfrankli/hotos07/vmm_detection_hotos07.pdf" target="_blank" rel="external">Compatibility is Not Transparency: VMM Detection Myths and Realities[PDF]</a>,”<br>Proceedings of the 11th USENIX workshop on Hot topics in operating systems, No. 6, CA, USA, 2007.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/01/23/sandbox-transparency/" data-id="cilaj6h1400109sosblgau11c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pintool-nx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/11/pintool-nx/">Intel PinにおけるNXの扱い</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-11T09:00:00.000Z" itemprop="datePublished">12-11-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>2014.12.07~08にわたって開催されたSECCON CTF 2014の予選（英語版）にて，ROP: Impossibleというpwn問題が出題された．タイトルの通り，この問題ではROPが制限されている．<br>ここでは，その実現手法として用いられていたIntel Pin(pintool)について，またこの問題にあった欠陥について述べる．<br>したがって，このエントリはROP: Impossibleの<strong>ネタバレ</strong>を兼ねている．注意されたし．</p>
<h1 id="問題の概要">問題の概要</h1><p>問題文は以下の通り．Pinによって保護された脆弱なバイナリからフラグを読み出せというものだ．</p>
<blockquote>
<p>ropi.pwn.seccon.jp:10000<br>read <code>/flag</code> and write the content to stdout, such as the following pseudo code.<br><code>open(&quot;/flag&quot;, 0);</code><br><code>read(3, buf, 32);</code><br><code>write(1, buf, 32);</code><br>Notice that the <code>vuln</code> executable is protected by an Intel Pin tool, the source code of which is <code>norop.cpp</code>.</p>
</blockquote>
<p>パッと見，バイナリは良心的な構成であるように思われる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.6.26, BuildID[sha1]=0xcb671b1dc0409082c3f3962818d366fcb8771ead, not stripped</span><br></pre></td></tr></table></figure></p>
<p>有効になっているのはNXだけだ．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE&#10;No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   vuln</span><br></pre></td></tr></table></figure></p>
<p>だからといって，解法が自明であるわけではない．この問題の肝は，いかにしてPinによる保護をかい潜るかにある．</p>
<h1 id="Pin">Pin</h1><p>Pinは，Intelによって開発されたDBI(dynamic binary instrumentation)フレームワークである．<br>DBIとは，プログラムにコードを挿入することで実行時の情報を取得・操作する技術であり，プログラムのパフォーマンス測定やエラー検出，CPUキャッシュの分析や未定義命令のエミュレーションなど，多方面で応用されている．<br>さて，ROP: Impossibleは以下のコードによって保護されている．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdlib.h&#62;&#10;#include &#34;pin.H&#34;&#10;&#10;ADDRINT&#9;shadow_stack[4096];&#10;int&#9;&#9;shadow_sp = -1;&#10;&#10;VOID push_retaddr(ADDRINT esp, ADDRINT eip)&#10;&#123;&#10;&#9;if(shadow_sp &#62;= (int)sizeof(shadow_stack) - 1)&#123;&#10;&#9;&#9;// cannot push retaddr to shadow stack&#10;&#9;&#9;exit(-1);&#10;&#9;&#125;&#10;&#9;PIN_SafeCopy(&#38;shadow_stack[++shadow_sp], (VOID*)esp, sizeof(ADDRINT));&#10;&#125;&#10;&#10;VOID pop_retaddr(ADDRINT esp, ADDRINT eip)&#10;&#123;&#10;&#9;ADDRINT&#9;&#9;retaddr;&#10;&#10;&#9;PIN_SafeCopy(&#38;retaddr, (VOID*)esp, sizeof(ADDRINT));&#10;&#10;&#9;while(shadow_sp &#62;= 0 &#38;&#38; shadow_stack[shadow_sp--] != retaddr);&#10;&#9;if(shadow_sp &#60; 0)&#123;&#10;&#9;&#9;exit(-1);&#10;&#9;&#125;&#10;&#125;&#10;&#10;VOID check_syscall(ADDRINT eax)&#10;&#123;&#10;&#9;switch(eax)&#123;&#10;&#9;// syscalls for exploit&#10;&#9;case 3:&#9;&#9;// sys_read&#10;&#9;case 4:&#9;&#9;// sys_write&#10;&#9;case 5:&#9;&#9;// sys_open&#10;&#9;case 6:&#9;&#9;// sys_close&#10;&#10;&#9;// syscalls executed until entry point&#10;&#9;case 45:&#9;// sys_brk&#10;&#9;case 122:&#9;// sys_newuname&#10;&#9;case 192:&#9;// sys_mmap2&#10;&#9;case 197:&#9;// sys_fstatfs64&#10;&#9;case 243:&#9;// sys_set_thread_area&#10;&#9;&#9;break;&#10;&#10;&#9;// invalid syscalls&#10;&#9;default:&#10;&#9;&#9;exit(-1);&#10;&#9;&#125;&#10;&#125;&#10;&#10;VOID insert_hooks(INS ins, VOID *val)&#10;&#123;&#10;&#9;if(INS_IsCall(ins))&#123;&#10;&#9;&#9;// push retaddr to shadow stack&#10;&#9;&#9;if(XED_ICLASS_CALL_FAR == INS_Opcode(ins))&#123;&#10;&#9;&#9;&#9;exit(-1);&#10;&#9;&#9;&#125;&#10;&#9;&#9;INS_InsertCall(ins, IPOINT_TAKEN_BRANCH,(AFUNPTR)push_retaddr,&#10;&#9;&#9;&#9;IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);&#10;&#9;&#125;else if(INS_IsRet(ins))&#123;&#10;&#9;&#9;// pop retaddr from shadow stack, and then check it&#10;&#9;&#9;if(XED_ICLASS_RET_FAR == INS_Opcode(ins))&#123;&#10;&#9;&#9;&#9;exit(-1);&#10;&#9;&#9;&#125;else&#123;&#10;&#9;&#9;&#9;INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)pop_retaddr,&#10;&#9;&#9;&#9;&#9;IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);&#10;&#9;&#9;&#125;&#10;&#9;&#125;else if(INS_IsSyscall(ins))&#123;&#10;&#9;&#9;// check syscall&#10;&#9;&#9;INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)check_syscall,&#10;&#9;&#9;&#9;IARG_REG_VALUE, REG_EAX, IARG_END);&#10;&#9;&#125;&#10;&#125;&#10;&#10;int main(int argc, char *argv[])&#10;&#123;&#10;&#9;PIN_Init(argc, argv);&#10;&#9;INS_AddInstrumentFunction(insert_hooks, NULL);&#10;    PIN_StartProgram();&#10;    &#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>このプログラムが，vulnの共有ライブラリとして噛まされている．<code>INS_*</code>は命令単位のinstumentationのために提供されているPinのAPIである．<br>要するに，リターンアドレスの検証によって，ROPが制限されているのだ．</p>
<h1 id="JOP">JOP</h1><p>ROPができない環境ならば，どうすればよいのか．<br>そもそも，ROPに用いられる<code>ret</code>は，スタックの最上位アドレスに対する<code>pop</code>と<code>jmp</code>と等価であると見做せる．ゆえに<code>jmp</code>によってchainを構築すれば，<code>ret</code>を用いること無くROPと同様なコードを作成することができる．これをJOP(Jump-oriented programming)という．<br>さらに，スタックに対するアドレスの<code>push</code>と<code>jmp</code>は，<code>call</code>と等価であると見做せる．ゆえに<code>call</code>と<code>pop</code>によってROPを代替することができる．<br>つまり，ROP: Impossibleは<code>ret</code>制限下の環境を前提に<code>jmp</code>と<code>call</code>でchainを構築しろというストイックな問題だった．<br>Pinに起因する欠陥がなければ．</p>
<h1 id="writeup">writeup</h1><p>この問題を最初に解いたのは，TOEFL BEGINNERという謎のチームだった．続いてbinja, PPPと続いている．<br>優勝チームであるPPPメンバーのRicky Zhouが公開しているwriteupを見てみよう．</p>
<ul>
<li><a href="https://rzhou.org/~ricky/seccon2014/rop_impossible/" target="_blank" rel="external">Index of /~ricky/seccon2014/rop_impossible/</a></li>
</ul>
<p>明らかにおかしい．bssセグメントにシェルコードを置いて実行しているだけではないか．<br>だが，このバイナリはNXが有効だったはずだ．ローカルでこのコードを実行しても，SIGSEGVが発生する．<br>これは一体どうしたことだろう．</p>
<h1 id="JITコンパイルの弊害">JITコンパイルの弊害</h1><p>結論から言うと，Pinの制御下にあるバイナリのNXは無効化されるようになっている．<br>/proc/pid/mapsを確認すると，一見nonexecであるように見える．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bf984000-bf9a5000 rw-p 00000000 00:00 0          [stack]</span><br></pre></td></tr></table></figure></p>
<p>だが，実際はそうではない．<br>PinはJITコンパイルによってinstrumentationを実現している．そのため，バイナリはPinによってmmapされ，execされる．このとき，Pinは元来バイナリに付与されていた実行権限を無視してしまう．<br>つまり，ROPを制限するためのPinが，NXを無効化してしまっていたのだ．<br>そもそも，LinuxにおいてNXの状態をmaps以外から取得するのは難しい．強いて挙げるならば，checksecのように<code>readelf -W -l file | grep &#39;GNU_STACK&#39;</code>を叩くといったところだろうか．だが，これだけではmmapやmprotectに追随することができない．WindowsのVirtualQueryに相当する機能はないのだろうか．</p>
<h1 id="おわりに">おわりに</h1><p>XSS Bonsaiも同様だが，CTFについてもテストは重要であるということを気付かされた．<br>運営の穴を突くのもCTFの醍醐味のひとつなのだろうが，しかし厄介な問題である．<br>最近はPinやDynamoRioによるマルウェア解析が流行っているように見受けられるが，やがてはDBIツールのデメリットについても検討を加えなければならなくなるだろう．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/11/pintool-nx/" data-id="cilaj6h1g00179sos6xjzj6oi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploiting/">exploiting</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-v2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/09/v2e/">マルウェア解析におけるRecord and Replayの設計</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-09T09:00:00.000Z" itemprop="datePublished">12-09-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>“という論文を通して，Record and Replayを用いた解析環境の設計を学ぶ．</p>
<h1 id="著者">著者</h1><p>この論文のラストオーサーであるYinはSyracuse Universityの助教である．彼はテイント解析の第一人者として知られ，現在は<a href="https://code.google.com/p/decaf-platform/" target="_blank" rel="external">DECAF</a>の開発を主導している．またBitBlaze ProjectのDawn Songや，マルウェア解析の大御所であるChristopher Kruegelと過去に共著を出している．<br>ファーストオーサーのYanは提案手法をAndroidに適用し，2013年に博士論文を著している．Android向けの拡張にあたっては，DECAFのサブプロジェクトであるDroidScopeを用いているようだ．</p>
<h1 id="Record_and_Replay">Record and Replay</h1><p>あるいはLogging and Replay, Lockstep, 順序再演法，最小情報トレースなどと呼ばれるこれらは，仮想マシンモニタ上のイベントを記録し，再生するための技術である．乱暴に言うとhistoryからdockerfileやvagrantfileを作成し，deployするようなものだ．<br>一般にステートマシンにおける命令の出力は，内部状態から一意に与えられる．そこで，ある環境の初期状態と入力のみを記録(Record)し，同じ環境を別の環境の上に再生(Raplay)するといった試みがなされてきた．実マシンにおいては，時刻や割り込みなどの非決定性とその記録の困難性からRecord and Replayは不可能であるとされる．だが，仮想マシンモニタの世界ではこれらの問題をある程度無視できる．実際，VMware Workstationなどにこの機能は実装されている．<br>本論文では，マルウェア解析に求められるサンドボックスの特性を加味したRecord and Replayについて論じられている．かつて大居さん(<a href="https://twitter.com/a4lg" target="_blank" rel="external">@a4lg</a>)が研究されていた内容に近い．</p>
<h1 id="背景">背景</h1><p>マルウェアを解析するためのサンドボックスは検出不可能(transparent)であり，なおかつ拡張可能であるべきだ．<br>いかに仮想マシンモニタの存在を隠蔽しようと，Timing Attackなどが成り立つ以上，transparentなサンドボックスを実現することは不可能である．しかし，Intel VTなどハードウェア仮想化技術を用いることで，ほぼtransparentな環境を作り出すことは可能である．例えば，<a href="http://ether.gtisc.gatech.edu/" target="_blank" rel="external">Ether</a>は命令・システムコール単位の解析機能を備えているが，Xenをベースに高いtransparent性を実現している．<br>だが，ハードウェア仮想化技術に依存した解析環境には拡張性の点で問題がある．特に，instrumentationによる詳細な解析が不可能であるという点は，大きな痛手である．<br>他方，QEMUなどのソフトウェアエミュレーションは動的バイナリ変換を用いることでDBI(dynamic binary instrumentation)と解析効率の向上を実現している．しかし，transparentなサンドボックスには至れない．<br>QEMUの動的バイナリ変換はバイナリをコードブロック単位で変換し，softmmuからTLBを参照してアドレス変換を行うというものだ．<br>そしてその性質から，以下のような自己書き換えコードによって検出されうる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm&#123;&#10;&#9;xor eax, eax&#10;&#9;mov edi, target&#10;&#9;mov esi, copy_insn&#10;&#9;mov ecx, 3&#10;&#10;target:&#10;&#9;rep movsw&#9;&#9;// f3 66 a5&#10;&#9;jmp qemu_found&#9;&#9;// eb XX&#10;&#9;nop&#9;&#9;&#9;// 90&#10;&#10;non_qemu:&#10;&#9;...&#10;&#10;qemu_found:&#10;&#9;...&#10;&#10;copy_insn:&#10;&#9;_emit 0xeb&#9;&#9;// eb&#10;&#9;_emit 0x01&#9;&#9;// 01&#10;&#9;_emit 0x90&#9;&#9;// 90&#10;&#9;_emit 0xeb&#10;&#9;_emit 0x01&#10;&#9;_emit 0x90&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>実マシンでは，<code>ecx*word=6</code>バイトが1回で書き換わるが，QEMUの動的バイナリ変換では2バイトずつ3回で書き換わる．そのため，1回目の書き換えで<code>0xeb 0x01 0xa5</code>すなわち<code>jmp +01</code>になってしまい，<code>qemu_found</code>にジャンプしてしまう．<br>その他には，ページ境界を越えてブロックの変換が行われた場合にページフォルトが発生してしまうことも考えられるし，ブロック境界でのみ割り込みが行われる，CPUサイクルの消費が著しいといった実マシンとの相違点もある．<br>さらに問題なのが，フラグの遅延評価だ．例えば，<code>cmp</code>と<code>jz</code>の組み合わせなどの条件分岐は，EFLAGSを更新する．だが，QEMUにおいては<code>cmp</code>が実行される段階でEFLAGSの計算は行われない．実際に計算されるのは<code>jz</code>の実行時，それも分岐を決定するためのZFのみが計算される．この設計はエミュレーションの高速化に寄与しているが，もちろん検出に用いることが可能だ．<br>当然ながら命令のエミュレーション自体にも限界がある．SIMDさえ厳しいのだ，システム管理モードやIntel TXTなんてものは考えたくないだろう．<br>このように，QEMUによるエミュレーションが検出される余地は枚挙に暇がない．<br>なお，解析環境検出をテーマとした最近の研究では，第2回システム系論文輪読会で<a href="http://ntddk.github.io/barecloud/">紹介した</a>BareCloudや忠鉢さん(<a href="https://twitter.com/yuzuhara" target="_blank" rel="external">@yuzuhara</a>)のTENTACLEなどがある．</p>
<h1 id="研究目的">研究目的</h1><p>ハードウェア仮想化技術を用いる解析環境とソフトウェアエミュレーションを用いる解析環境にはそれぞれ問題がある．そこで，ハードウェア仮想化技術を用いる解析環境でRecordを行い，ソフトウェアエミュレーションを用いる解析環境でReplayを行うことで，検出不可能性と拡張可能性という二つの目的について達成したのが，今回紹介するV2Eである．</p>
<h1 id="形式的定義">形式的定義</h1><p>本論文におけるRecord and Replayの設計はどのようなものか．<br>Recorderにおける遷移関数<code>f</code>について，毎時<sub><code>i</code></sub>におけるプログラムの状態を<code>S</code><sub><code>i</code></sub>とし，入力を<code>I</code><sub><code>i</code></sub>とする．すなわち<code>f</code>は<code>S</code><sub><code>i</code></sub><code>= f(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と表される．<br>次にReplayerにおける遷移関数<code>f&#39;</code>についてプログラムの初期状態を<code>S</code><sub><code>0</code></sub>とし，全ての入力を<code>I</code>としたとき，<code>f = f&#39;</code>と言えないだろうか．<br>これは二つのチューリング機械の同値性が解決可能であるかという問題に相当する．だが<code>EQ</code><sub><code>TM</code></sub><code>= {(M</code><sub><code>1</code></sub><code>, M</code><sub><code>2</code></sub>)<code>|M</code><sub><code>1</code></sub><code>とM</code><sub><code>2</code></sub><code>はTMであり，L(M</code><sub><code>1</code></sub><code>) = L(M</code><sub><code>2</code></sub><code>)}</code>は判定不可能とされ（『計算理論の基礎』における定理5.4），実装上でもハードウェアの割り込みなどの要因から<code>f != f&#39;</code>となってしまう．<br>そこでV2Eは，プログラムの初期状態と全ての入力を保存することに加え，<code>S</code><sub><code>j</code></sub><code>= S&#39;</code><sub><code>j</code></sub>となるような<sub><code>j</code></sub>について状態の変化を保存することにした．これは<code>⊿</code><sub><code>j</code></sub><code>= S</code><sub><code>j</code></sub><code>- S</code><sub><code>j-1</code></sub>と表される．<br>ここで，新たな遷移関数<code>f&#39;</code><sub><code>r</code></sub>を<code>S&#39;</code><sub><code>i</code></sub><code>= f&#39;</code><sub><code>r</code></sub><code>(S&#39;</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>, ⊿</code><sub><code>i</code></sub><code>)</code>として定義する．これは，<code>⊿</code><sub><code>i</code></sub><code>!= null</code>のとき<code>S&#39;</code><sub><code>i-1</code></sub><code>+ ⊿</code><sub><code>i</code></sub>と同値であり，それ以外について<code>f&#39;(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と同値をとる．<br>なお，<code>S</code><sub><code>0</code></sub>, <code>I</code>, <code>⊿</code>および<code>f&#39;</code><sub><code>r</code></sub>, <code>S&#39;</code><sub><code>i</code></sub><code>= S</code><sub><code>i</code></sub>は<code>i ∈ [0, n]</code>について恒真である．<br>これを実装に起こすと，特定の命令やイベントが正しくエミュレート可能な場合は単にそれらをエミュレートし，そうでなければ状態の変化を記録し，Replayにあたって変更を適用するというアプローチになる．</p>
<h1 id="理論と実際">理論と実際</h1><p>プログラムの大部分を占める<code>mov</code>, <code>push</code>, <code>pop</code>などのデータ転送命令，<code>call</code>, <code>ret</code>, <code>jz</code>, <code>jmp</code>などの制御転送命令，<code>add</code>, <code>shl</code>などの整数演算命令におけるエミュレーションは失敗しないものと見做せる．これらはそのままRecorderでエミュレートされる．<br>一方で，割り込み，MMIO, Port IO, DMA, TSCについては，V2Eは既存研究を踏襲し，監視領域においてのみこれらをRecordするようになっている．<br>では，例外，モデル固有レジスタ，<code>cpuid</code>はどうすべきだろうか．既存手法は，これらのエミュレーションは困難であるという理由から，そもそも入力として扱わない戦略を採っていたようだ．V2Eではこれらを<code>⊿</code>, すなわちエミュレートが困難な状態の変化としてRecordすることで，Replayの正確性を高めている．<br>次に問題となるのが浮動小数点演算とSIMDの扱いだ．MMXやSSEを正確にエミュレートするのは難しい．だが，<code>⊿</code>として命令の結果を記録する設計は大幅なパフォーマンスの低下を招く．そこでV2EはReplayにあたってこれらの命令をパススルーする．もちろん，ReplayerはSIMDをサポートしているマシンで実行されることが前提にある．</p>
<h1 id="Transparent_Recorder">Transparent Recorder</h1><p>RecorderはKVMを用いて実装されている．<br>V2EはRecord対象の領域とそれ以外のシステムを分割するため，TDP(two dimensional paging)を用いている．何のことかと思ったら，Intel EPTやAMD NPTの総称らしい．<br><img src="/image/tdp.jpg"><br>要するに，TDPとは仮想マシンと物理マシン間のページテーブルのことだ．通常のページングでは，メモリアクセスに応じてMMUによってページテーブルが参照され，仮想アドレスが物理アドレスへと変換される．TDPでは，ゲストマシンからの仮想メモリ空間へのアクセスに応じてCR3にセットされたページテーブルが参照され，ゲスト物理アドレスがホスト物理アドレスへと変換される．<br>この仕組を用いたV2Eは，<strong>監視対象用のTDPテーブルと，それ以外用のTDPテーブルを別々に作成する</strong>．マルウェアに属するページはCR3の監視に基づき監視対象用のTDPテーブルに書き込まれる．マルウェアとそれ以外の部分のインタラクションはTDPページフォルトや<code>VMExit</code>によって媒介される．共有されるデータは読み取り専用として双方に与えられる．なお，TDPページフォルトに応じてCPUの状態が入力<code>I</code><sub><code>i</code></sub>として保存される．</p>
<h1 id="Precise_Replayer">Precise Replayer</h1><p>ReplayerはTEMUを用いて実装されている．バイナリ変換器に中間表現がなく，単純に古いQEMU 0.9.1をベースとしているのが玉に瑕だが，TEMUは動的テイント解析に求められる機能をほぼ網羅している．<br>TEMUはプラグインを共有ライブラリとしてロードし，コールバック関数からテイント解析の機能を呼び出すプラットフォームとなっている．V2EのReplayerは既存のプラグインであるtracecap, unpackerを用いる．だがRecordされたログには監視対象の情報のみが記述されているため，<br><code>return ((*TEMU_cpu_hflags &amp; HF_CPL_MASK) != 3)</code>といった，現在実行しているコードが解析対象のものかどうか判定するコードは除去されているようだ．TEMUのプラグインについては，こうした僅かな変更しか施されていない．<br>一方でその下で動くQEMUには結構手が加えられている．フラグの遅延評価は廃止され，ページフォルト以外の例外は除去されており，SIMDについては独自のヘルパー関数が追加されたようだ．QEMUのdyngenに手を加えるのはなかなか骨の折れる作業だと思う．<br>さて，Replayを行うためには，ReplayerはRecorderと同様のページングの仕組みをエミュレーションによって再現しなければならない．そこで，V2Eは物理ページコンテナという仕組みを用いている．これは，物理ページがログからロードされていることを示すものである．通常，物理ページコンテナは監視対象用のTDPテーブルを複製する．Replayされたプログラムが物理ページコンテナに存在しないページにアクセスした場合，Replayerは適切なタイミングでログからCPUの状態を復元し，ロードするようになっている．<br>V2Eにおけるテイント解析はおそらく，マルウェアのメモリ領域を正確に把握するためのものではない．それは，Recorderの段階でTDPテーブルの分割というアプローチによって実現されるべきものだからだ．TEMUのプラグインを使いたかったのだろうが，論文中からはあまりテイント解析を導入することのメリットが読み取れなかった．ここでのテイント解析は解析環境検出の対策に先立つものとして設定されているのだろうか．</p>
<h1 id="評価">評価</h1><p>解析環境検出については問題なし．<code>cpuid</code>, <code>rdtsc</code>, <code>cmpxch8b</code>, <code>icbp</code>, <code>rep stosb</code>, <code>fnstcw</code>といった命令や，一般保護例外などについてテストされている．なお，<code>rdtsc</code>については<code>VMRESUME</code>前にホストのTSCを参照することで対応している．<br>in-the-wildのマルウェアについても実験が行われており，アンパッカーとして期待できるパフォーマンスを見せている．<br>Recordにおける速度だが，コンテキストスイッチが頻繁に発生するカーネルモードルートキットで17倍，Internet Explorerで5倍と高速だ．KVMのシングルステップモードには3000倍のオーバーヘッドがあると言うのに．<br>全体的にpositiveな結果で，かなり良い．</p>
<h1 id="おわりに">おわりに</h1><p>マルウェアによる解析環境検出に対して，復数の環境を組み合わせたRecord and Replayを用いる研究について紹介した．何より，監視対象とそれ以外で別個にTDPテーブルを作るというアプローチが素晴らしい．自分も研究でテイント解析を扱っているが，この流れを包摂していきたい．<br>ただ，これはサンドボックス全般に言えることなのだが，感染ホストにおけるユーザーのブラウザ操作が条件分岐に影響するMITBマルウェアについて，どう対処すべきなのだろうか．正常系のユーザーのブラウザ操作をデータセットとしてRecorderに与えたいところだが，果たしてどうなるのか．<br>このエントリは<a href="http://www.adventar.org/calendars/440" target="_blank" rel="external">システム系論文紹介 Advent Calendar 2014</a>の9日目として書かれた．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Lok-Kwong Yan, Manjukumar Jayachandra, Mu Zhang and Heng Yin,<br>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>,”<br>Proceedings of the 8th ACM SIGPLAN/SIGOPS conference on Virtual Execution Environments, pp. 227-238, NY, USA, 2012.</li>
<li>George W. Dunlap, Samuel T. King, Sukru Cinar, Murtaza A. Basrai and Peter M. Chen,<br>“<a href="http://web.engr.illinois.edu/~kingst/Research_files/dunlap02.pdf" target="_blank" rel="external">ReVirt: Enabling Intrusion Analysis through Virtual-Machine Logging and Replay[PDF]</a>,”<br>Proceedings of the 2002 Symposium on Operating Systems Design and Implementation, pp. 211-224, NY, USA, 2002.</li>
<li>A. Dinaburg, P. Royal, M. Sharif and W. Lee.<br>“<a href="http://ether.gtisc.gatech.edu/ether_ccs_2008.pdf" target="_blank" rel="external">Ether: malware analysis via hardware virtualization extensions[PDF]</a>,”<br>Proceedings of the 15th ACM Conference on Computer and Communications Security, pp. 51–62, NY, USA, 2008.</li>
<li>大居司,<br>“<a href="http://www.slideshare.net/a4lg/a-new-tracer-for-reverse-engineering" target="_blank" rel="external">リバースエンジニアリングのための新しいトレース手法</a>,”<br>PacSec 2010, 東京, 日本, 2010.</li>
<li>Dhilung Kirat, Giovanni Vigna, and Christopher Kruegel,<br>“<a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kirat.pdf" target="_blank" rel="external">BareCloud: Bare-metal Analysis-based Evasive Malware Detection[PDF]</a>,”<br>Proceedings of the 23rd USENIX conference on Security Symposium, pp. 287-301, CA, USA, 2014.</li>
<li>忠鉢洋輔, 愛甲健二,<br>“<a href="https://pacsec.jp/psj14/PSJ2014_chubachi_final_ja.pdf" target="_blank" rel="external">TENTACLE: Environment-Sensitive Malware Palpation[PDF]</a>,”<br>PacSec Tokyo 2014, 東京, 日本, 2014.</li>
<li>M. Siper,<br>“<a href="http://www.cs.virginia.edu/~robins/Sipser_2006_Second_Edition_Problems.pdf" target="_blank" rel="external">Introduction to the Theory of Computation. International</a>,”<br>Thomson Publishing, 1996.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/09/v2e/" data-id="cilaj6h0j000j9sos0ee4y19p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmi/">vmi</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-symexec-s2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/03/symexec-s2e/">選択的シンボリック実行ツールS2E</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-03T14:00:00.000Z" itemprop="datePublished">12-03-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>選択的シンボリック実行について紹介する．</p>
<h1 id="シンボリック実行">シンボリック実行</h1><p>シンボリック実行とは，プログラムに含まれる変数に具体値を入力せず，その代わりとして値を代表するシンボルの操作を通じてプログラムを模擬的に実行し，結果を評価する技術である．シンボリック実行の目的は，コードカバレッジの拡大にある．シンボリック実行は全てのケースに対してforkする，あるいは，条件分岐の制約をもとにテストケースを生成するといった形態でソフトウェアテストに用いられている．<br>ひとまず，以前書いた<a href="http://ntddk.github.io/2014/09/12/symexec-intro/">シンボリック実行に入門しようとした</a>をご覧頂きたい．</p>
<h1 id="選択的シンボリック実行">選択的シンボリック実行</h1><p>選択的シンボリック実行(selective symbolic execution)は，シンボリック実行の弱点を改善すべく<a href="https://github.com/dslab-epfl/s2e" target="_blank" rel="external">S2E</a>にて提案，実装された．<br>シンボリック実行には実行パスにおける計算爆発(path explosion)の問題があった．プログラム中の全ての実行パスを通るための制約はあまりにも多い．そして，<strong>全ての実行パスというのは解析対象の実行パスだけではない</strong>．考えてもみよう，実システムでプログラムを実行した際，プログラムは自身以外の様々なものを呼び出す．呼び出されるlibcなどのライブラリ，そしてカーネルやデバイスドライバ，さらにそのファームウェアは，一体どこまで解析対象における実行パスの分岐に影響を与えるのか．<br>この頭が痛い問題に対応するべく編み出されたのが選択的シンボリック実行，すなわちシンボリック実行を行う範囲の限定である．S2Eはシンボリック実行を行いたい部分以外に具体値(concrete value)を用いることで，解析対象のプログラムだけにシンボリック実行を適用する(concolic testing)．具体的には，S2Eは指定した変数が使用されている部分のみシンボリック実行を適用している．</p>
<h1 id="S2E">S2E</h1><h2 id="動的バイナリ変換">動的バイナリ変換</h2><p>S2Eは，QEMUをベースに開発された．QEMUはエミュレーションを実現するべく，以下のような流れで動的バイナリ変換を行う．</p>
<p>1.ゲストコードの逆アセンブル<br>2.マイクロオペレーションに変換<br>3.コード辞書を参照してホストコードに変換</p>
<p>S2Eはこのコード辞書をLLVM bitcodeに差し替えることで，x86のバイナリをLLVM bitcodeに変換する．そして，変換後のLLVM bitcodeをKLEEに渡すことで，シンボリック実行を行う．<br>このとき，<strong>解析対象の全部分がLLVM bitcodeに変換されるわけではない</strong>．<br><img src="/image/symexec-s2e_01.jpg"><br>指定した変数が使用されている部分のみシンボリック実行を適用すると書いたように，S2Eはシンボル化したデータにアクセスしているか否かによって，解析対象の実行方式を切り替えている．実行方式は以下の二通りだ．</p>
<ol>
<li>具体値にアクセスしている場合，通常通り実行</li>
<li>シンボルにアクセスしている場合，LLVM bitcodeに変換してKLEE上で実行</li>
</ol>
<p>これは，解析対象を多数のコードブロックに分割するというQEMUのバイナリ変換方式に極めて依存している．</p>
<h2 id="S2E_opcodes">S2E opcodes</h2><p>S2Eは独自の拡張命令S2E opcodesを用いてシンボリック実行のための機能をinstrumentする．S2E opcodesは以下のような機能を提供する．</p>
<ul>
<li><code>S2SYM</code>: データのシンボル化</li>
<li><code>S2ENA</code>: 複数パスの実行を有効化</li>
<li><code>S2DIS</code>: 複数パスの実行を無効化</li>
<li><code>S2OUT</code>: デバッグ情報の出力</li>
</ul>
<p>この中身は<code>s2e-x86.h</code>や<code>s2e.h</code>に記述されている．例として<code>S2SYM</code>の実装を見てみよう．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define S2E_INSTRUCTION_COMPLEX(val1, val2)             \&#10;    &#34;.byte 0x0F, 0x3F\n&#34;                                \&#10;    &#34;.byte 0x00, 0x&#34; #val1 &#34;, 0x&#34; #val2 &#34;, 0x00\n&#34;      \&#10;    &#34;.byte 0x00, 0x00, 0x00, 0x00\n&#34;&#10;&#10;#define S2E_INSTRUCTION_SIMPLE(val)                     \&#10;    S2E_INSTRUCTION_COMPLEX(val, 00)&#10;&#10;~ &#30053; ~&#10;&#10;static inline void s2e_make_symbolic(void *buf, int size, const char *name)&#10;&#123;&#10;    __s2e_touch_string(name);&#10;    __s2e_touch_buffer(buf, size);&#10;&#10;    __asm__ __volatile__(&#10;        S2E_INSTRUCTION_SIMPLE(03)&#10;        : : &#34;a&#34; (buf), &#34;d&#34; (size), &#34;c&#34; (name) : &#34;memory&#34;&#10;    );&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>例えば，解析対象のソースコード上で<code>s2e_make_symbolic()</code>の引数にシンボル化したい変数を渡すことで，この関数を利用することができる．</p>
<h2 id="Windowsデバイスドライバに対する選択的シンボリック実行">Windowsデバイスドライバに対する選択的シンボリック実行</h2><p><a href="https://dslabredmine.epfl.ch/embedded/s2e/Windows/DriverTutorial.html" target="_blank" rel="external">Analyzing Windows Drivers: Step-by-Step Tutorial</a>という公式チュートリアルでは，プラグインを用いてWindowsデバイスドライバにアノテーションを付加する方法が紹介されている．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function annotation_example(state, plg)&#10;   -- Write custom Lua code here (e.g., to inject symbolic values)&#10;end&#10;&#10;pluginsConfig.Annotation =&#10;&#123;&#10;    init1 = &#123;&#10;        active=true,&#10;        module=&#34;pcntpci5_sys_1&#34;,&#10;        address=0x169c9,&#10;        instructionAnnotation=&#34;annotation_example&#34;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>チュートリアルの例ではpcntpci5.sysというドライバが0x169c9というアドレスを呼び出す際に<code>annotation_example()</code>が実行される．BSoDもフックできるので，NotMyFaultドライバで遊ぼう．</p>
<h2 id="オーバーヘッド">オーバーヘッド</h2><p>いつだって問題となるのは実行速度だ．論文によると，S2Eは具体値による実行時(concrete mode)にQEMUの6倍，シンボリック実行時にQEMUの78倍のオーバーヘッドが生ずるとされている．注意したいのは，実機の78倍ではなくQEMUの78倍である点だ．</p>
<h1 id="おわりに">おわりに</h1><p>S2Eについて紹介した．<br>このエントリは<a href="http://connpass.com/event/9500/" target="_blank" rel="external">ソフトウェアテストあどべんとかれんだー2014</a>の3日目として書かれた．</p>
<h1 id="参考文献">参考文献</h1><p>より詳しくは以下の論文を参照されたい．これも全てVitaly Chipounovって奴の仕業なんだ．</p>
<ul>
<li>Vitaly Chipounov, George Candea,<br>“<a href="http://infoscience.epfl.ch/record/149975/files/x86-llvm-translator-chipounov_2.pdf" target="_blank" rel="external">Dynamically Translating x86 to LLVM using QEMU[PDF]</a>,”<br>Technical Report EPFL-TR-149975, Ecole Polytechnique Fédérale de Lausanne, Switzerland, March 2010.</li>
<li>Volodymyr Kuznetsov, Vitaly Chipounov, George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/ddt.pdf" target="_blank" rel="external">Testing Closed-Source Binary Device Drivers with DDT[PDF]</a>,”<br>Proceedings of the 2010 USENIX conference on USENIX annual technical conference, pp.12-12, Boston, MA, June 2010.</li>
<li>Vitaly Chipounov, Volodymyr Kuznetsov, George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/s2e.pdf" target="_blank" rel="external">S2E: a platform for in-vivo multi-path analysis of software systems[PDF]</a>,”<br>Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems, pp.265-278, Newport Beach, CA, March 2011.</li>
<li>Vitaly Chipounov, Volodymyr Kuznetsov George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/s2e-tocs.pdf" target="_blank" rel="external">The S2E Platform: Design, Implementation, and Applications[PDF]</a>,”<br>ACM Transactions on Computer Systems, Volume 30, Issue 1, Article No. 2, February 2012.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/03/symexec-s2e/" data-id="cilaj6h0s000o9sos0cj5jf8l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vine-howto" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/28/vine-howto/">Vineを動かす</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-27T20:56:08.000Z" itemprop="datePublished">09-28-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>ここでは，<a href="http://bitblaze.cs.berkeley.edu/" target="_blank" rel="external">BitBlaze</a>のうち，静的解析に特化したコンポーネントであるVineを動かしてみる．</p>
<h1 id="BitBlaze">BitBlaze</h1><p>BitBlazeはDawn Songらによるバイナリ解析プラットフォームで，2008年に<a href="http://bitblaze.cs.berkeley.edu/papers/bitblaze_iciss08.pdf" target="_blank" rel="external">BitBlaze: A New Approach to Computer Security via Binary Analysis [PDF]</a>が発表されて以来，数多くの研究に用いられてきた．BitBlazeは，動的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/temu.html" target="_blank" rel="external">TEMU</a>，静的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/vine.html" target="_blank" rel="external">Vine</a>，動的シンボリック実行コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/rudder.html" target="_blank" rel="external">Rudder</a>から構成される．このうち，TEMUとVineのソースコードが公開されている．</p>
<h2 id="TEMU:_The_BitBlaze_Dynamic_Analysis_Component">TEMU: The BitBlaze Dynamic Analysis Component</h2><p>TEMUはQEMUをベースとしたエミュレータで，テイント解析(taint analysis)の機能を備えている．テイント解析とは，タグを設定したデータの伝搬を追跡することで，データ同士の依存関係を解析する技術である．TEMUはtracecapというプラグインを用いて，ゲストOS上で動作するアプリケーションのトレースログを取得することができる．</p>
<h2 id="Vine:_The_BitBlaze_Static_Analysis_Component">Vine: The BitBlaze Static Analysis Component</h2><p>Vineは，逆アセンブリやTEMUのトレースファイルから，中間表現VineILや最弱事前条件，STP formulaなどを出力する．公開されているVineには，TEMU/tracecapのトレースファイルとしてfive.traceが同梱されている．これを例にVineの機能を見てみよう．</p>
<h1 id="Vineのインストール">Vineのインストール</h1><p><a href="http://bitblaze.cs.berkeley.edu/release/vine-1.0/howto.html" target="_blank" rel="external">Vine installation and user manual</a>の通り．OCamlで記述されているため，関連のパッケージを導入する必要がある．また，32bit環境での動作を前提としている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ ocaml ocaml-findlib libgdome2-ocaml-dev camlidl \ &#10;                     libextlib-ocaml-dev ocaml-native-compilers \ &#10;                     libocamlgraph-ocaml-dev binutils-dev texlive \ &#10;                     texlive-latex-extra transfig hevea</span><br></pre></td></tr></table></figure>
<h1 id="trace_reader">trace_reader</h1><p>TEMU/tracecapが出力するトレースファイルはhuman-readableではなく，閲覧はVineのtrace_readerを介して行う必要がある．five.traceでは，T1がタグの識別子となっており，T0はデータに設定されたタグが存在しないことを意味する．なお，ここではキーボードからの入力にタグが設定されている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../trace_utils/trace_reader -trace five.trace | grep T1 | head -n 20&#10;42075911:&#9;movzbl (%eax),%eax&#9;R@eax[0x40014000][4]&#9;T0&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077e0c:&#9;cmp    $0xffffffff,%eax&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077e14:&#9;movzbl (%edx),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205abc5:&#9;mov    %eax,-0xac(%ebp)&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff69c[0x00000000][4]&#9;T0&#10;4205abce:&#9;mov    -0xa8(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff6a0[0x00000000][4]&#9;T0&#10;4205abd5:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205abf5:&#9;mov    -0xac(%ebp),%edx&#9;R@edx[0x40014001][4]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac0b:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac14:&#9;movzbl -0xac(%ebp),%eax&#9;R@eax[0x42130b80][4]&#9;T0&#9;M@0xbffff69c[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac24:&#9;push   %eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff604[0x4213030c][4]&#9;T0&#10;4205ac25:&#9;mov    0x8(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff750[0x4212d980][4]&#9;T0&#10;4207793a:&#9;mov    0xc(%ebp),%edx&#9;R@edx[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff604[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077945:&#9;cmp    %dl,-0x1(%eax)&#9;R@dl[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;42077974:&#9;movzbl %dl,%eax&#9;R@dl[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;R@eax[0x40014000][4]&#9;T0&#10;42077960:&#9;cmp    $0xffffffff,%eax&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205ac39:&#9;movzbl -0x9d(%ebp),%eax&#9;R@eax[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff6ab[0x00000064][1]&#9;T0&#10;4205c550:&#9;mov    $0xa,%edx&#9;I@0x00000000[0x0000000a][4]&#9;T0&#9;R@edx[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205c566:&#9;cmpl   $0xffffffff,-0xac(%ebp)&#9;I@0x00000000[0xffffffff][1]&#9;T0&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205dcd1:&#9;movzbl (%eax),%edi&#9;R@edi[0x00000000][4]&#9;T0&#9;M@0x40014000[0x00000035][1]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#10;4205dcd8:&#9;mov    %edi,-0xac(%ebp)&#9;R@edi[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;&#9;M@0xbffff69c[0x00000035][4]&#9;T1 &#123;1 (1001, 0) ()()()&#125;</span><br></pre></td></tr></table></figure>
<h1 id="VineIL">VineIL</h1><p>Vineが生成するVineILは静的単一代入形式の中間表現であり，CFGの情報が損なわれることはない．中間表現の生成をinstruction liftingという．なお，VineILはValgrindの中間表現を扱うライブラリVEXをもとに生成される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -ir-out five.ir&#10;~/vine/examples$ cat five.ir | awk &#39;NR==1000,NR==1020&#39;&#10;R_CC_OP_16:reg32_t = 0xd:reg32_t;&#10;T_32t9_1114:reg32_t = cast(T_8t3_1108:reg8_t)U:reg32_t;&#10;R_CC_DEP1_17:reg32_t = T_32t9_1114:reg32_t;&#10;R_CC_DEP2_18:reg32_t = 0:reg32_t;&#10;R_CC_NDEP_19:reg32_t = 0:reg32_t;&#10;/*eflags thunk: logic*/&#10;&#10;R_CF_10:reg1_t = false;&#10;T_7_1115:reg8_t = cast(T_32t9_1114:reg32_t)L:reg8_t;&#10;R_PF_11:reg1_t =&#10;!cast(&#10;      ((T_7_1115:reg8_t &#62;&#62; 7:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 6:reg32_t)&#10;         ^ (T_7_1115:reg8_t &#62;&#62; 5:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 4:reg32_t))&#10;       ^ &#10;         ((T_7_1115:reg8_t &#62;&#62; 3:reg32_t ^ T_7_1115:reg8_t &#62;&#62; 2:reg32_t)&#10;            ^ (T_7_1115:reg8_t &#62;&#62; 1:reg32_t ^ T_7_1115:reg8_t))&#10;         )L:reg1_t;&#10;R_AF_12:reg1_t = false;&#10;R_ZF_13:reg1_t = T_32t9_1114:reg32_t == 0:reg32_t;&#10;R_SF_14:reg1_t = 1:reg32_t == (1:reg32_t &#38; T_32t9_1114:reg32_t &#62;&#62; 7:reg32_t);&#10;R_OF_15:reg1_t = false;</span><br></pre></td></tr></table></figure>
<p>出力している行の番号は適当．</p>
<h1 id="最弱事前条件">最弱事前条件</h1><p>最弱事前条件(weakest precondition)はDijkstraによる述語変換意味論の基礎を成す概念である．Sを条件，式をRとした際，最弱事前条件WP(S, R)は，Rを実行する前にS’が成り立っていればSの実行後にSが成り立つ最も弱い条件S’を表す．単純な例だと，以下のように表現される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WP(S, x=e) = S[e/x]&#10;WP(new == org,  new = new+taint) &#10;=  new+taint == org</span><br></pre></td></tr></table></figure>
<p>Vineにおける最弱事前条件の出力は，以下のようになる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -wp-out five.wp&#10;~/vine/examples$ grep let five.wp | head -n 20&#10;let post_1681:reg1_t = true in&#10;let R_EAX_1682:reg32_t = 0x40014000:reg32_t in&#10;let idx_1683:reg32_t = 0x40014000:reg32_t in&#10;let val_1684:reg8_t = INPUT_1001_0000_61:reg8_t in&#10;let temp_1685:reg8_t = val_1684:reg8_t &#38; 0xff:reg8_t in&#10;let temp_1686:reg8_t = temp_1685:reg8_t &#62;&#62; 0:reg8_t in&#10;let towrite_1688:reg8_t = cast(temp_1686:reg8_t)L:reg8_t in&#10;let mem_arr_1687:reg8_t[4294967296] =&#10;    let mem_arr_57[0x40014000:reg32_t]:reg8_t = towrite_1688:reg8_t in&#10;    mem_arr_57:reg8_t[4294967296]&#10;in&#10;let R_EAX_1689:reg32_t = 0x40014000:reg32_t in&#10;let R_GDT_1690:reg32_t = 0xc02dbd80:reg32_t in&#10;let R_LDT_1691:reg32_t = 0xc02dcc58:reg32_t in&#10;let R_DFLAG_1692:reg32_t = 1:reg32_t in&#10;let T_32t0_1693:reg32_t = R_EAX_1689:reg32_t in&#10;let T_8t2_1694:reg8_t = mem_arr_1687[0x40014000:reg32_t]:reg8_t in&#10;let T_32t1_1695:reg32_t = cast(T_8t2_1694:reg8_t)U:reg32_t in&#10;let R_EAX_1696:reg32_t = T_32t1_1695:reg32_t in&#10;let temp_1697:reg32_t = R_EAX_1696:reg32_t &#38; 0xffff00ff:reg32_t in&#10;let temp_1698:reg32_t = cast(0:reg8_t)U:reg32_t in&#10;let temp_1699:reg32_t = temp_1698:reg32_t &#60;&#60; 8:reg8_t in</span><br></pre></td></tr></table></figure>
<p>このような手法でソースコードの存在しないバイナリから最弱事前条件を抽出し，仕様書を復元する試みがあるらしい．ゾッとする．</p>
<h1 id="STP_formula">STP formula</h1><p>Vineは，TEMUのトレースファイルからSTP formulaを出力する．STP formulaとはSMTソルバであるSTP用のフォーマットである．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -stp-out five.stp&#10;~/vine/examples$ head -n 20 five.stp&#10;% free variables: &#10;mem_arr_57 : ARRAY BITVECTOR(64) OF BITVECTOR(8);&#10;INPUT_1001_0000_61 : BITVECTOR(8);&#10;% end free variables.&#10; &#10; &#10;ASSERT( 0bin1 =&#10;(LET post_1681 =&#10;    0bin1&#10;IN&#10;(LET R_EAX_1682 =&#10;    0hex40014000&#10;IN&#10;(LET idx_1683 =&#10;    0hex40014000&#10;IN&#10;(LET val_1684 =&#10;    INPUT_1001_0000_61&#10;IN&#10;(LET temp_1685 =</span><br></pre></td></tr></table></figure>
<p>SMTソルバは充足可能性問題を解く．では，ここで与えられる命題とは何か．それは，任意の初期値がトレースファイルの結果と一致するというものだ．STPは命題が充足可能か解こうとし，充足不能であった場合は反例を出力する．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ cat &#62;&#62;five.stp&#10;QUERY(FALSE);&#10;COUNTEREXAMPLE;</span><br></pre></td></tr></table></figure>
<p>ここで出力される反例は，実行経路に影響を与えた入力値となるようだ．five.traceでは，0x35(ASCIIで5)という入力値が分岐に影響を与えている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/vine/examples$ ../stp/stp five.stp&#10;Invalid.&#10;ASSERT( INPUT_1001_0_61  = 0hex35  );</span><br></pre></td></tr></table></figure>
<p>これはトレースファイルに対する静的なシンボリック実行だと言える．シンボリック実行とは，記号によって表現したプログラムの変数を操作することで，実行経路に影響する制約を抽出する静的解析の手法である．シンボリック実行は到達定義の解析などモデルベーステストの領域で発展してきたが，マルウェアの挙動解析に役立てられないだろうか．</p>
<h1 id="BAP">BAP</h1><p><a href="http://bap.ece.cmu.edu" target="_blank" rel="external">BAP</a>はDavid BrumleyらによるVineの再実装である．彼らはCMUに所属しており，PPPのメンバーでもある．彼らは脆弱性解析の自動化をmotivationとしてBitBlazeを扱ってきた．BAPはVineをより発展させたプロジェクトであり，逆アセンブリやTEMUのトレースファイルから中間表現BILを生成するほか，CFGのみならずCDG(control dependence graphs)やDDG(data dependence graphs)の出力をサポートしているようだ．</p>
<h1 id="おわりに">おわりに</h1><p>TEMUのトレースファイルについて，ざっくりVineによる静的解析を行った．とりあえず動かしてみただけなので，コードを噛み砕く必要がある．気になるのはやはり中間表現のフォーマットだ．一度，QEMU，Valgrind，DynamoRIO，LLVM，Vine，BAPなどの中間表現について，対応を整理したほうが良いかもしれない．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/28/vine-howto/" data-id="cilaj6h0g000c9sosmxyiqxh4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-symexec-intro" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/12/symexec-intro/">シンボリック実行に入門しようとした</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-11T17:50:52.000Z" itemprop="datePublished">09-12-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>シンボリック実行(symbolic execution)という用語をセキュリティ系の論文でよく見かけるようになった．ここでは，シンボリック実行の基礎となる理論を辿る．筆者はソフトウェアテストの研究には疎く，おそらく本稿には若干以上の誤謬と誤解が含まれているだろう．ぜひ識者の教示を乞いたい．</p>
<h1 id="発祥">発祥</h1><p>シンボリック実行は主にソフトウェアテストの領域で古くから研究されてきたトピックである．シンボリック実行という用語の初出は遡ること38年前，James C. Kingらによる<a href="https://courses.engr.illinois.edu/cs477/sp2011/king76symbolicexecution.pdf" target="_blank" rel="external">Symbolic Execution and Program Testing [PDF]</a>という論文だ．Dijkstraがgoto文の濫用による大域脱出を批判したのが1968年であり，Guarded Command Languageを提案したのが1975年のことである．この論文が発表された1976年当時はまさに構造化プログラミングというパラダイムがコンピュータサイエンスの世界を席捲していた時代であった．私が生まれる20年以上前のことで，当時の問題意識を肌身で感じることができないのが少し残念に思える．感覚としては白亜紀のようなもので，主要な登場人物もDijkstraやらKnuthやら，恐竜かよ．<br>さて，シンボリック実行とはどのような提案だったか．まず，シンボリック実行の目的は「どの入力値でどの実行経路を通るか特定する」ことである．そのためにはどうすればよいだろうか？シンボリック実行はその名の通り，プログラムの変数をシンボル(記号)として表現する．論文中のスニペットはあまりにも古めかしいので，<a href="http://en.wikipedia.org/wiki/Symbolic_execution" target="_blank" rel="external">Symbolic execution - Wikipedia, the free encyclopedia</a>を例に考えよう．残念ながら日本語記事はないものの，原理は単純明快．</p>
<pre><code>y = read<span class="list">()</span>
y = <span class="number">2</span> * y
if <span class="list">(<span class="keyword">y</span> == <span class="number">12</span>)</span>
    fail<span class="list">()</span>
print<span class="list">(<span class="string">"OK"</span>)</span>
</code></pre><p>シンボリック実行では入力に具体値を与えない．例えば，変数yに割り当てられる入力値をsというシンボルで表現する．見ての通り，このルーチンはif文で2つの実行経路に分岐するが，この分岐の条件を制約と呼ぶ．ここでの制約は<code>2 * s == 12</code>となる．実行経路を分岐させる条件となる入力値は，式を解けば分かる．言うまでもなく<code>6</code>だ．おっと，これは充足可能性問題というやつじゃないか？その通り，シンボリック実行では制約を解くにあたって制約充足ソルバ(constraint solver)を用いる．ここでは，<code>2 * s == 12</code>という制約が<code>¬s1 ∧ ¬s2 ∧ ¬s3 ∧ ¬s4 ∧ s5 ∧ s6 ∧ ¬s7 ∧ ¬0</code>という連言標準形で表される．<code>2 * s</code>は<code>s1s2s3s4s5s6s70</code>に，<code>12</code>は<code>00001100</code>となる．<br>このように，具体値を与えないまま，必ず1つの実行経路を通る制約(path constraints)を求め，条件分岐に影響する入力値の制約を特定する手法がシンボリック実行である．シンボリック「実行」と銘打っていても，実際にプログラムを実行しているわけではない．飽くまでシンボルの操作を通して，擬似的にプログラムを実行しているのだ．</p>
<h1 id="Concolic_Testing/Dynamic_Symbolic_Execution">Concolic Testing/Dynamic Symbolic Execution</h1><p>では，シンボリック実行は銀の弾丸たりえるか？そんなわけがない．真っ先に以下の課題に直面してしまう．</p>
<ul>
<li>計算爆発</li>
<li>制約充足ソルバで解くことができない制約</li>
<li>入力値が一意に定まらない</li>
</ul>
<p>そこで，<a href="http://mir.cs.illinois.edu/marinov/publications/SenETAL05CUTE.pdf" target="_blank" rel="external">CUTE: A Concolic Unit Testing Engine for C [PDF]</a>において，concolic testingという手法が提案された．concolicとは耳慣れない言葉だが，どういった意味だろうか？これは，symbolic(シンボル)とconcrete(具体値)からなる造語で，concolic testingとはシンボリック実行に具体値(concrete value)を持ち込んだ手法である．またの名を動的シンボリック実行．<br>具体値を持ち込むとはどういうことか？動的シンボリック実行では，制約充足ソルバが不得手とする非線形な制約に到達した場合，その箇所だけ実際に実行(concrete execution)することで，具体値を代入する．これによって，コードカバレッジを拡大するというのが狙いである．現在「シンボリック実行」と呼ばれているのは概ね動的シンボリック実行である．</p>
<h1 id="KLEE">KLEE</h1><p><a href="http://klee.github.io/klee/" target="_blank" rel="external">KLEE</a>はシンボリック実行にLLVM bitcodeを導入したプロジェクトである．チュートリアルは<a href="http://feliam.wordpress.com/2010/10/07/the-symbolic-maze/" target="_blank" rel="external">The Symbolic Maze! - Feliam’s Blog</a>が秀逸．<br>使い方は簡単で，解析対象のソースコードに<code>#include &lt;klee/klee.h&gt;</code>と<code>klee_make_symbolic()</code>とを追加するだけで準備は完了する．<code>klee_make_symbolic()</code>にはシンボリック実行を適用したい変数のアドレスとサイズ，名前を引数として与える．</p>
<pre><code><span class="tag">llvm-gcc</span> <span class="tag">--emit-llvm</span> <span class="tag">-c</span> <span class="tag">-g</span> <span class="attr_selector">[file]</span><span class="class">.c</span>
<span class="tag">klee</span> <span class="attr_selector">[file]</span><span class="class">.o</span>
</code></pre><p>LLVM bitcodeとしてコンパイルし，KLEEに与えて実行すると，ktestという形式のテストケースが生成される．</p>
<pre><code>ktest-tool --<span class="keyword">write</span>-ints klee-<span class="keyword">last</span>/[<span class="keyword">file</span>].ktest 
</code></pre><p>ktest-toolを実行すると，入力値が出力される．</p>
<pre><code>ktest <span class="string">file :</span> ‘klee-last/test000001.ktest’
<span class="string">args :</span> [<span class="string">'[file].o'</span>]
num <span class="string">objects:</span> <span class="number">1</span>
object <span class="number">0</span>: <span class="string">name:</span> ‘hoge’
object <span class="number">0</span>: <span class="string">size:</span> <span class="number">4</span>
object <span class="number">0</span>: <span class="string">data:</span> ‘fuga′
</code></pre><p>これによって，KLEEは90%以上のコードカバレッジを実現する．論文の評価実験では，Coreutilsについて，15年に渡って作成されてきたテストスイートよりも高いカバレッジをたったの89時間で達成している．<br>KLEEは多くの研究者に利用されており，シンボリック実行に関する研究のstate-of-the-artはKLEEを分散化した<a href="https://code.comsys.rwth-aachen.de/redmine/projects/kleenet-public" target="_blank" rel="external">KleeNet</a>だと聞いている．<br>しかし，もちろんKLEEは万能ではない．特にループ文の解釈がうまくいかないことが多く，これはシンボリック実行が抱える永年の課題である．</p>
<h1 id="STP">STP</h1><p>KLEEは<a href="https://sites.google.com/site/stpfastprover/" target="_blank" rel="external">STP Constraint Solver</a>という制約充足ソルバを用いている．STPは制約充足ソルバの中でもSMT(Satisfiable Modulo Theories)ソルバと呼ばれるものに相当する．SAT(SATisfiability problem)ソルバはブール式のみを扱うが，SMTソルバはこれに加えて配列やビットベクトル，加減算大小比較など様々な背景理論を用いることができる．STPではAND，OR，NOT，XORといった演算についてもサポートされ，式の最適化についても工夫されているようだ．</p>
<h1 id="S2E">S2E</h1><p>少しばかり，リバースエンジニアリングにも目を向けてみよう．解析対象のソースコードが存在しない場合，どうやってシンボリック実行を適用すればよいだろうか？解決策のひとつとして挙げられるのが<a href="https://github.com/dslab-epfl/s2e" target="_blank" rel="external">S2E</a>である．<br>S2EはQEMUの動的バイナリ変換(dynamic binary translation)を用いる．QEMUの動的バイナリ変換機能をTCG(Tiny Code Generator)といい，これによって例えばARM向けにビルドされたバイナリをx86の計算機で動かすといった機能が実現される．<br>まず，QEMUは対象のバイナリを逆アセンブルし，複数のブロックに分割する．このブロックをTB(translation block)といい，定義は<code>translate-all.h</code>に記述されている．TBは分岐命令やページの境界によって区切られる．そして，ブロック単位で逆アセンブルしたコードを<code>gen_intermediate_code()</code>という関数で中間コードに変換し，<code>tcg_gen_code()</code>という関数で他のアーキテクチャの命令とマッピングする．これらは<code>target-[arch]/translate.c</code>および<code>tcg/tgc.c</code>に記述されている．こうして変換されたコードは，TB単位でキャッシュされる．実行にあたっては，変換されたTBをchainとして繋いでいく．この処理は，<code>main()</code>から<code>cpu_exec()</code>を経由して呼ばれる<code>tb_find_fast()</code>や<code>tb_find_slow()</code>に記述されている．こうして，QEMUは異なるアーキテクチャ向けバイナリの実行を可能にしている．<br>S2Eは，QEMUのTCGを用いてPEファイルをLLVM bitcodeに変換し，KLEEに受け渡す．TCGは，中間コードを変換するにあたって，変換先のアーキテクチャの命令が記述された辞書を参照する．S2Eはこの辞書にLLVM bitcodeを登録することで，実行ファイルをLLVM bitcodeに「逆アセンブル」するのだ．<br>このようにして，S2Eはシンボリック実行を実現しているが，そもそもLLVM bitcodeに変換する必要はあるのだろうか？KLEEは確かに優れたツールだが，バイナリに直接シンボリック実行を適用すれば良いのではないか？<br>これには理由がある．QEMUの中間コードも，LLVM bitcodeもレジスタが無限個存在するSSA(Static Single Assignment form，静的単一代入)形式をとっている．一方で，x86アーキテクチャはSSA形式ではない．x86における逆アセンブルコードにシンボリック実行を適用する例を考えよう．</p>
<pre><code><span class="keyword">mov</span> <span class="literal">esi</span>, <span class="number">0x09</span>
<span class="keyword">mov</span> <span class="number">edx</span>, <span class="number">0x2014</span>
</code></pre><p>この場合，制約は<code>(esi == 0x09) and (edx == 0x2014)</code>となる．これなら問題はないが，以下の例はどうだろう．</p>
<pre><code><span class="keyword">mov</span> <span class="literal">esi</span>, <span class="number">0x09</span>
...
<span class="keyword">mov</span> <span class="literal">esi</span>, <span class="number">0x2014</span>
</code></pre><p>同じレジスタに違う値が代入されている．この場合，制約は<code>(esi == 0x09) and (esi == 0x2014)</code>となってしまう．こうした理由から，シンボリック実行にはSSA形式への変換が必要となるようだ．</p>
<h1 id="おわりに">おわりに</h1><p>シンボリック実行の基礎を学んだつもりになった．この技術が情報セキュリティの分野でどう活きてくるのかについては，また改めて．進捗だめです．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li><a href="http://debugeng.com/concolic%20testing.pdf" target="_blank" rel="external">Concolic testingと背景技術 ~テスト技法の新動向~ [PDF]</a></li>
<li><a href="http://blog.livedoor.jp/prjmng/archives/52297951.html" target="_blank" rel="external">テスト入力値の自動生成と、concolic testing - ソフトウェアの品質を学びまくる</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/12/symexec-intro/" data-id="cilaj6h0w000r9soszj6y4dhk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-after-rop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/11/after-rop/">Return-oriented programming以後</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-11T10:07:12.000Z" itemprop="datePublished">09-11-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに">はじめに</h1><p>Return-oriented programming(ROP)が提唱されて久しい．CTFにおいても，ROPは当たり前のように要求される技術となってきている．一方で，ROPに代わる新たな攻撃手法も模索されている．ここでは，そういったROP以後の攻撃手法を概観する．</p>
<h1 id="Return-oriented_programming">Return-oriented programming</h1><h2 id="コンセプト">コンセプト</h2><p>まずは簡単にROPをおさらいする．<br>ROPは主にハードウェアDEPという脆弱性対策技術に対抗するために編み出された攻撃手法である．ハードウェアDEPはCPUのNX bitを有効化することで，スタック上でコードを実行する攻撃を無効化する．<br>そこで，ROPはコード領域のretで終わる命令列(gadget)を実行することによってこれを回避する．単体のgadgetではわずかな処理しか行えないが，スタックに次のgadgetのアドレスを積むことで，gadgetを組み合わせたchainを構築することができる．ROPの作成にはコード領域からgadgetを探索する段階とgadgetを組み合わせる段階を要する．レジスタの操作はpopによって行う．</p>
<h2 id="ASLR/PIEの迂回">ASLR/PIEの迂回</h2><p>ASLRはスタックやヒープなどが読み込まれる位置を実行ごとにランダマイズすることで，アドレスを決め打ちした攻撃を困難にする．だが，ASLRはROPに対処しうる技術ではない．<br>まず，LinuxにおいてASLRはコード領域のランダマイズを行わないため，スタックオーバーフローなどをROPの起点とすることができる．また，bssセグメントに存在する変数のアドレスを取得することができるのは，ASLRの重大な欠陥である．さらに，32bitの場合は総当りによってアドレスを特定できるほか，ulimit -s unlimitedによってASLRを無効化することができる．<br>PIEはASLRに加えてgadgetのアドレスまでランダマイズの対象となるため，攻撃にあたってはleakが前提となる．</p>
<h2 id="RELROの迂回">RELROの迂回</h2><p>RELROはセクションをread onlyに設定する機能である．Partial RELROとFull RELROがあり，前者の場合はGOTを利用した攻撃が可能である．後者の場合はread onlyにしうる全てのセクションがread onlyとなるが，ROPによって攻撃を成立させることができる．</p>
<h2 id="Stager">Stager</h2><p>攻撃に使える領域のサイズが制限されている場合，readなどの関数を用いて再度メモリに書き込む方法をstagerと呼ぶ．</p>
<h2 id="Stack_Pivot">Stack Pivot</h2><p>スタックのサイズ上，リターンアドレスの下にROP chainを構築できないような場合，xchg esp,eaxなどのgadgetを用いてスタックのアドレスを移動させる方法をstack pivotと呼ぶ．</p>
<h2 id="論文">論文</h2><ul>
<li><a href="http://cseweb.ucsd.edu/~hovav/dist/geometry.pdf" target="_blank" rel="external">The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86) [PDF]</a></li>
</ul>
<h1 id="BROP:_Blind_return-oriented_programming">BROP: Blind return-oriented programming</h1><h2 id="コンセプト-1">コンセプト</h2><p>以下の要件を満たすサーバープログラムの場合は，バイナリが手元になくてもROPを試みることができる．</p>
<ul>
<li>listen，forkを行う</li>
<li>スタックオーバーフローで子プロセスが落ちた場合も動き続ける</li>
<li>GOTにstrcmpなど第三引数を操作できる関数が存在する</li>
<li>GOTにwriteなどleakさせることができる関数が存在する</li>
<li>総当りなどでGOTのアドレスが分かる</li>
</ul>
<p>目的は，自身をwriteによってダンプさせることである．<br>まず，リターンアドレスを総当りして，無限ループに陥るようなgadget(STOP gadgetと呼称)を探す．次に，関数にinnvalidな引数を渡した場合であっても，GOTに正しく飛んだ場合はSEGVしないという点に着目し，0x08040000周辺に存在しているはずのGOTセクションの位置を推定する．推定にあたっては，+0x6のアドレスや次のGOTエントリに飛んだ場合もSEGVしないという特性を用いる．そして，fdを総当りするか，多数のコネクションからwriteを探り当てる．<br>GOTエントリは要素数のサイズが同じであるため，スタックのleakからゴリ押しできる，といった内容のようだが，実際のところどうなのだろうか．CTFのネタとしては面白いのではないか．</p>
<h2 id="論文-1">論文</h2><ul>
<li><a href="http://www.scs.stanford.edu/brop/bittau-brop.pdf" target="_blank" rel="external">Hacking Blind [PDF]</a></li>
</ul>
<h2 id="実例">実例</h2><ul>
<li><a href="http://www.scs.stanford.edu/brop/braille.rb" target="_blank" rel="external">Braille [Ruby]</a></li>
</ul>
<h1 id="SROP:_Sigreturn-oriented_Programming">SROP: Sigreturn-oriented Programming</h1><h2 id="コンセプト-2">コンセプト</h2><p>vdsoには，シグナル割り込みから復帰する際に，ユーザーランドのスタック上に作成したsignal frameに保存している値を全てのレジスタへ戻すsigreturnという命令が存在する．つまり，popadが廃止されたx64においても，sigreturnによってスタック上の値を複数のレジスタにセットすることができる．これによって，任意のシステムコールを呼び出すことが可能となるほか，関数の呼び出しがレジスタ渡しの場合においてもROPが容易になる．なお，vsyscallはASLRが有効であっても固定アドレスである．<br>ulimit -s unlimitedを用いてvdsoのマッピングアドレスを固定できる場合はCTFでも活用できそうだ．</p>
<h2 id="論文-2">論文</h2><ul>
<li><a href="https://www.cs.vu.nl/~herbertb/papers/srop_sp14.pdf" target="_blank" rel="external">Framing Signals—A Return to Portable Shellcode [PDF]</a></li>
</ul>
<h2 id="実例-1">実例</h2><ul>
<li><a href="http://inaz2.hatenablog.com/entry/2014/07/30/021123" target="_blank" rel="external">x64でSigreturn Oriented ProgrammingによるASLR+DEP+RELRO回避をやってみる - ももいろテクノロジー</a></li>
</ul>
<h1 id="JOP:_Jump-oriented_programmingとCOP:_Call-oriented_programming">JOP: Jump-oriented programmingとCOP: Call-oriented programming</h1><h2 id="コンセプト-3">コンセプト</h2><p>通常，retの次にはそのサブルーチンを呼び出したcallの次の命令が存在する．そこで，コールスタックを辿ることでROPによってretが使われていないか検出するROPguardが考案された．ROPguardはMicrosoftの脆弱性対策ツールであるEMET 3.5の根幹を成す理論だった．<br>そこで，retの代わりにjmpを用いるJump-oriented programmingが考案された．また，retやjmpの代わりにcallを用いるCall-oriented programmingも可能である．例えば以下のコードスニペットにおいて，callはjmpと実質的に等価である．</p>
<pre><code><span class="keyword">pop</span> <span class="literal">esi</span><span class="comment">;</span>
<span class="keyword">ret</span><span class="comment">;</span>
<span class="keyword">push</span> <span class="number">eax</span><span class="comment">;</span>
<span class="keyword">call</span> <span class="literal">esi</span><span class="comment">;</span>

<span class="comment">; call先</span>
<span class="keyword">pop</span> <span class="literal">esi</span> <span class="comment">;retアドレスを除去</span>
<span class="comment">;eaxを用いる処理</span>
</code></pre><p>COPでは，pushのような表現力の高い命令を用いることができる．</p>
<h2 id="論文-3">論文</h2><h3 id="ROPguard">ROPguard</h3><ul>
<li><a href="http://ifsec.blogspot.jp/2012/08/my-bluehat-prize-entry-ropguard-runtime.html" target="_blank" rel="external">My BlueHat Prize entry: ROPGuard - runtime prevention of return-oriented programming attacks - Ivan Fratric’s Security Blog</a></li>
</ul>
<h3 id="JOP">JOP</h3><ul>
<li><a href="ftp://ftp.ncsu.edu/pub/tech/2010/TR-2010-8.pdf" target="_blank" rel="external">Jump-Oriented Programming: A New Class of Code-Reuse Attack [PDF]</a></li>
</ul>
<h3 id="COP">COP</h3><ul>
<li><a href="http://www.cs.stevens.edu/~gportoka/files/outofcontrol_oakland14.pdf" target="_blank" rel="external">Out of control: Overcoming control-flow integrity [PDF]</a></li>
<li><a href="http://www.cs.berkeley.edu/~daw/papers/rop-usenix14.pdf" target="_blank" rel="external">ROP is Still Dangerous: Breaking Modern Defenses [PDF]</a></li>
</ul>
<h2 id="実例-2">実例</h2><h3 id="COP-1">COP</h3><ul>
<li><a href="http://potetisensei.hatenablog.com/entry/2014/09/12/020720" target="_blank" rel="external">Call Oriented Programming - 生きたい</a></li>
</ul>
<h1 id="おわりに">おわりに</h1><p>ざっとROP以後の攻撃手法を列挙した．これ以外にも，AlphanumericなROPを作成する技術やバイナリから自動的にROPを作成する技術などが研究されている．また，<a href="http://inaz2.hatenablog.com/entry/2014/08/03/230528" target="_blank" rel="external">roputils</a>や<a href="http://bap.ece.cmu.edu/" target="_blank" rel="external">BAP</a>など，ROPを支援するフレームワークも開発されている．これらについてもいずれ理解したい．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/11/after-rop/" data-id="cilaj6gza00009soscqq4nvid" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploiting/">exploiting</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 ntddk<br>
      <a href="https://github.com/steven5538/hexo-theme-athena" target="_blank">Athena</a> by <a href="http://steven5538.tw" target="_blank">Steven5538</a> | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>