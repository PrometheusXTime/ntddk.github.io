<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一生あとで読んでろ]]></title>
  <subtitle><![CDATA[技術ブログ]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ntddk.github.io/"/>
  <updated>2016-07-09T06:17:58.664Z</updated>
  <id>http://ntddk.github.io/</id>
  
  <author>
    <name><![CDATA[ntddk]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Unicornのソースコードを読む（Python編）]]></title>
    <link href="http://ntddk.github.io/2016/07/09/unicorn-internals/"/>
    <id>http://ntddk.github.io/2016/07/09/unicorn-internals/</id>
    <published>2016-07-09T06:20:00.000Z</published>
    <updated>2016-07-09T06:17:58.664Z</updated>
    <content type="html"><![CDATA[<p>　※Rackサーバの方のUnicornではない．</p>
<h1 id="はじめに">はじめに</h1><p>　<a href="http://www.unicorn-engine.org/" target="_blank" rel="external">Unicorn</a>は<a href="http://www.qemu.org/" target="_blank" rel="external">QEMU</a>ベースの軽量，マルチプラットフォーム・マルチアーキテクチャ・JIT対応のCPUエミュレータ．周辺機器をエミュレーションしないため用途は限られるが，GoやPythonなど<a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings" target="_blank" rel="external">複数言語のバインディング</a>を備えている．現在システムセキュリティ分野で最も注目されているOSSのひとつと言っても過言ではなく，<a href="https://github.com/vrtadmin/ROPMEMU" target="_blank" rel="external">AsiaCCS 2016で発表されたROPチェーン解析ツールROPMEMU</a>や，<a href="https://github.com/oblivia-simplex/roper" target="_blank" rel="external">遺伝的アルゴリズムによってROPチェーンを自動生成するツールroper</a>のバックエンドとして用いられたり，Unicornと同じように注目を集めているバイナリ解析ツール<a href="https://github.com/angr/simuvex/issues/29" target="_blank" rel="external">angrとの連携</a>が進められたりと，一大コミュニティを形成しつつある．<br>　コンセプトの説明は<a href="http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf" target="_blank" rel="external">Black Hat USA 2015の発表スライド</a>に譲るとして，ここではその利用方法と内部実装にふれる．</p>
<h1 id="Pythonバインディング">Pythonバインディング</h1><blockquote>
<p>　情報セキュリティに興味があり，セキュリティ関係の仕事に携わりたいという人には，Pythonはうってつけの言語だ．その理由は，リバースエンジニアリングと攻撃コード作成のためのライブラリが充実しているためだ．<br>　　　　　　　— Justin Seitz『<a href="https://www.oreilly.co.jp/books/9784873117317/" target="_blank" rel="external">サイバーセキュリティプログラミング———Pythonで学ぶハッカーの思考</a>』序文</p>
</blockquote>
<p>　リバースエンジニアリングというタスクにUnicornを用いることを考える．他言語を選ぶ積極的な理由やPythonへのアレルギーがなければ，他のライブラリとの連携も考慮して，Pythonバインディングを活用すべきだろう．</p>
<h1 id="エミュレーション">エミュレーション</h1><p>　最もシンプルな用例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># unicorn/bindings/python/sample_x86.pyを抜粋・改変</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function <span class="comment"># Python 2.7を利用</span></span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># エミュレーション対象の機械語</span></span><br><span class="line">X86_CODE32 = <span class="string">b"\x41\x4a"</span> <span class="comment"># INC ecx; DEC edx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各基本ブロックに対するコールバック</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_block</span><span class="params">(uc, address, size, user_data)</span>:</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt; Tracing basic block at 0x%x, block size = 0x%x"</span> %(address, size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 各命令に対するコールバック</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span><span class="params">(uc, address, size, user_data)</span>:</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = %u"</span> %(address, size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x86 32bitのコードをエミュレーション</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_i386</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Emulate i386 code"</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># x86-32bitモードでエミュレータを初期化</span></span><br><span class="line">        mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># エミュレーション用に2MBのメモリを割り当て</span></span><br><span class="line">        mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 割り当てられたメモリに機械語を書き込み</span></span><br><span class="line">        mu.mem_write(ADDRESS, X86_CODE32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># レジスタ初期化</span></span><br><span class="line">        mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>) <span class="comment"># エミュレーション中に加算される</span></span><br><span class="line">        mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>) <span class="comment"># エミュレーション中に減算される</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 各基本ブロックに対するコールバックを設定</span></span><br><span class="line">        mu.hook_add(UC_HOOK_BLOCK, hook_block)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 各命令に対するコールバックを設定</span></span><br><span class="line">        mu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># エミュレーション開始</span></span><br><span class="line">        mu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># レジスタの表示</span></span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; Emulation done. Below is the CPU context"</span>)</span><br><span class="line"></span><br><span class="line">        r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">        r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; ECX = 0x%x"</span> %r_ecx)</span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; EDX = 0x%x"</span> %r_edx)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># メモリから命令列を読む</span></span><br><span class="line">        tmp = mu.mem_read(ADDRESS, <span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; Read 2 bytes from [0x%x] ="</span> %(ADDRESS), end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">            print(<span class="string">" 0x%x"</span> %i, end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"ERROR: %s"</span> % e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_i386()</span><br></pre></td></tr></table></figure>
<p>　これを実行すると次のような出力が得られる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Emulate i386 code&#10;&#62;&#62;&#62; Tracing basic block at 0x1000000, block size = 0x2&#10;&#62;&#62;&#62; Tracing instruction at 0x1000000, instruction size = 1&#10;&#62;&#62;&#62; Tracing instruction at 0x1000001, instruction size = 1&#10;&#62;&#62;&#62; Emulation done. Below is the CPU context&#10;&#62;&#62;&#62; ECX = 0x1235&#10;&#62;&#62;&#62; EDX = 0x788f&#10;&#62;&#62;&#62; Read 2 bytes from [0x1000000] = 0x41 0x4a</span><br></pre></td></tr></table></figure>
<p>　はい．<br>　なおエミュレーション時に各命令のトレースを得たければ，同じ開発陣による逆アセンブラ<a href="http://www.capstone-engine.org/" target="_blank" rel="external">Capstone</a>のPythonバインディングを併用して（詳細は割愛）次のようなフックを用意すればよい：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleEngine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.capmd = Cs(CS_ARCH_X86, CS_MODE_32) <span class="comment"># アーキテクチャ指定</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disas_single</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.capmd.disasm(data, <span class="number">16</span>): <span class="comment"># 逆アセンブル</span></span><br><span class="line">            print(<span class="string">"\t%s\t%s"</span> % (i.mnemonic, i.op_str))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">disasm = SimpleEngine()</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span><span class="params">(uc, address, size, user_data)</span>:</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = %u, "</span> %(address, size), end=<span class="string">""</span>)</span><br><span class="line">    <span class="comment"># メモリから実行される命令を読む</span></span><br><span class="line">    ins = uc.mem_read(address, size)</span><br><span class="line">    disasm.disas_single(str(ins))</span><br></pre></td></tr></table></figure>
<p>　実行すると命令のトレースが得られる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;&#62;&#62;&#62; Tracing instruction at 0x1000000, instruction size = 1,     inc     ecx&#10;&#62;&#62;&#62; Tracing instruction at 0x1000001, instruction size = 1,     dec     edx&#10;...</span><br></pre></td></tr></table></figure>
<p>　このように，Unicornではプラグイン側のエントリポイントからQEMUの機能を呼び出していくことになる．この内部では，ctypesによる共有ライブラリのロードが行われている．<code>unicorn/bindings/python/unicorn/unicorn.py</code>を見よう：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _lib <span class="keyword">in</span> _all_libs:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> _lib == <span class="string">"unicorn.dll"</span>:</span><br><span class="line">            <span class="keyword">for</span> dll <span class="keyword">in</span> _all_windows_dlls:    <span class="comment"># load all the rest DLLs first</span></span><br><span class="line">                _lib_file = os.path.join(_lib_path, dll)</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(_lib_file):</span><br><span class="line">                    ctypes.cdll.LoadLibrary(_lib_file)</span><br><span class="line">        _lib_file = os.path.join(_lib_path, _lib)</span><br><span class="line">        _uc = ctypes.cdll.LoadLibrary(_lib_file)</span><br><span class="line">        _found = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>　ここで<code>_uc</code>に<code>unicorn.dll</code>（環境によって異なるがいずれにせよ共有ライブラリ）がロードされている．<br>　さて，これまで利用してきた関数のプロトタイプ宣言は<code>unicorn/bindings/python/unicorn/unicorn.py</code>にある：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup all the function prototype</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_setup_prototype</span><span class="params">(lib, fname, restype, *argtypes)</span>:</span></span><br><span class="line">    getattr(lib, fname).restype = restype</span><br><span class="line">    getattr(lib, fname).argtypes = argtypes</span><br><span class="line"></span><br><span class="line">ucerr = ctypes.c_int</span><br><span class="line">uc_engine = ctypes.c_void_p</span><br><span class="line">uc_hook_h = ctypes.c_size_t</span><br><span class="line"></span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_version"</span>, ctypes.c_uint, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int))</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_arch_supported"</span>, ctypes.c_bool, ctypes.c_int)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_open"</span>, ucerr, ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(uc_engine))</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_close"</span>, ucerr, uc_engine)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_strerror"</span>, ctypes.c_char_p, ucerr)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_errno"</span>, ucerr, uc_engine)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_reg_read"</span>, ucerr, uc_engine, ctypes.c_int, ctypes.c_void_p)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_reg_write"</span>, ucerr, uc_engine, ctypes.c_int, ctypes.c_void_p)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_read"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.POINTER(ctypes.c_char), ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_write"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.POINTER(ctypes.c_char), ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_emu_start"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_uint64, ctypes.c_uint64, ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_emu_stop"</span>, ucerr, uc_engine)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_hook_del"</span>, ucerr, uc_engine, uc_hook_h)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_map"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_uint32)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_map_ptr"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_unmap"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_protect"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_uint32)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_query"</span>, ucerr, uc_engine, ctypes.c_uint32, ctypes.POINTER(ctypes.c_size_t))</span><br><span class="line"></span><br><span class="line"><span class="comment"># uc_hook_add is special due to variable number of arguments</span></span><br><span class="line">_uc.uc_hook_add = _uc.uc_hook_add</span><br><span class="line">_uc.uc_hook_add.restype = ucerr</span><br><span class="line"></span><br><span class="line">UC_HOOK_CODE_CB = ctypes.CFUNCTYPE(<span class="keyword">None</span>, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_void_p)</span><br><span class="line">UC_HOOK_MEM_INVALID_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    ctypes.c_bool, uc_engine, ctypes.c_int,</span><br><span class="line">    ctypes.c_uint64, ctypes.c_int, ctypes.c_int64, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_MEM_ACCESS_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    <span class="keyword">None</span>, uc_engine, ctypes.c_int,</span><br><span class="line">    ctypes.c_uint64, ctypes.c_int, ctypes.c_int64, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INTR_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    <span class="keyword">None</span>, uc_engine, ctypes.c_uint32, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INSN_IN_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    ctypes.c_uint32, uc_engine, ctypes.c_uint32, ctypes.c_int, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INSN_OUT_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    <span class="keyword">None</span>, uc_engine, ctypes.c_uint32,</span><br><span class="line">    ctypes.c_int, ctypes.c_uint32, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INSN_SYSCALL_CB = ctypes.CFUNCTYPE(<span class="keyword">None</span>, uc_engine, ctypes.c_void_p)</span><br></pre></td></tr></table></figure>
<p>　メモリ・レジスタを読み書きできることがわかる．<br>　さきほどは基本ブロック・命令単位のコールバック関数———フック———を設置した．その他のフックも次のように書ける：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mu.hook_add(UC_HOOK_BLOCK, hook_block) <span class="comment"># 基本ブロック単位</span></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)   <span class="comment"># 命令単位</span></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code, <span class="keyword">None</span>, ADDRESS, ADDRESS+<span class="number">20</span>) <span class="comment"># 指定範囲[ADDRESS, ADDRESS+20]の全命令</span></span><br><span class="line">mu.hook_add(UC_HOOK_INSN, hook_in, <span class="keyword">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_IN)   <span class="comment"># IN命令</span></span><br><span class="line">mu.hook_add(UC_HOOK_INSN, hook_out, <span class="keyword">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_OUT) <span class="comment"># OUT命令</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_access) <span class="comment"># メモリ書き込み</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ, hook_mem_access)  <span class="comment"># メモリ読み込み</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, hook_mem_access) <span class="comment"># その両方</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED, hook_mem_invalid) <span class="comment"># 無効なメモリアクセス</span></span><br><span class="line">mu.hook_add(UC_HOOK_INSN, hook_syscall, <span class="keyword">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_SYSCALL) <span class="comment"># システムコール</span></span><br><span class="line">mu.hook_add(UC_HOOK_INTR, hook_intr) <span class="comment"># 割り込み</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>　こうしたフックや，これまで用いてきたレジスタやメモリの読み書き・エミュレーションといった機能は<code>Uc</code>クラスのメソッドとして用意されている：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uc</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arch, mode)</span>:</span></span><br><span class="line">        <span class="comment"># verify version compatibility with the core before doing anything</span></span><br><span class="line">        (major, minor, _combined) = uc_version()</span><br><span class="line">        <span class="keyword">if</span> major != uc.UC_API_MAJOR <span class="keyword">or</span> minor != uc.UC_API_MINOR:</span><br><span class="line">            self._uch = <span class="keyword">None</span></span><br><span class="line">            <span class="comment"># our binding version is different from the core's API version</span></span><br><span class="line">            <span class="keyword">raise</span> UcError(uc.UC_ERR_VERSION)</span><br><span class="line"></span><br><span class="line">        self._arch, self._mode = arch, mode</span><br><span class="line">        self._uch = ctypes.c_void_p()</span><br><span class="line">        status = _uc.uc_open(arch, mode, ctypes.byref(self._uch))</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            self._uch = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line">        <span class="comment"># internal mapping table to save callback &amp; userdata</span></span><br><span class="line">        self._callbacks = &#123;&#125;</span><br><span class="line">        self._ctype_cbs = &#123;&#125;</span><br><span class="line">        self._callback_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># emulate from @begin, and stop when reaching address @until</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">emu_start</span><span class="params">(self, begin, until, timeout=<span class="number">0</span>, count=<span class="number">0</span>)</span>:</span></span><br><span class="line">        status = _uc.uc_emu_start(self._uch, begin, until, timeout, count)</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return the value of a register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reg_read</span><span class="params">(self, reg_id)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._arch == uc.UC_ARCH_X86:</span><br><span class="line">            <span class="keyword">if</span> reg_id <span class="keyword">in</span> [x86_const.UC_X86_REG_IDTR, x86_const.UC_X86_REG_GDTR, x86_const.UC_X86_REG_LDTR, x86_const.UC_X86_REG_TR]:</span><br><span class="line">                reg = uc_x86_mmr()</span><br><span class="line">                status = _uc.uc_reg_read(self._uch, reg_id, ctypes.byref(reg))</span><br><span class="line">                <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">                    <span class="keyword">raise</span> UcError(status)</span><br><span class="line">                <span class="keyword">return</span> reg.selector, reg.base, reg.limit, reg.flags</span><br><span class="line">            <span class="keyword">if</span> reg_id <span class="keyword">in</span> range(x86_const.UC_X86_REG_FP0, x86_const.UC_X86_REG_FP0+<span class="number">8</span>):</span><br><span class="line">                reg = uc_x86_float80()</span><br><span class="line">                status = _uc.uc_reg_read(self._uch, reg_id, ctypes.byref(reg))</span><br><span class="line">                <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">                    <span class="keyword">raise</span> UcError(status)</span><br><span class="line">                <span class="keyword">return</span> reg.mantissa, reg.exponent</span><br><span class="line"></span><br><span class="line">        <span class="comment"># read to 64bit number to be safe</span></span><br><span class="line">        reg = ctypes.c_int64(<span class="number">0</span>)</span><br><span class="line">        status = _uc.uc_reg_read(self._uch, reg_id, ctypes.byref(reg))</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line">        <span class="keyword">return</span> reg.value</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read data from memory</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mem_read</span><span class="params">(self, address, size)</span>:</span></span><br><span class="line">        data = ctypes.create_string_buffer(size)</span><br><span class="line">        status = _uc.uc_mem_read(self._uch, address, data, size)</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line">        <span class="keyword">return</span> bytearray(data)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add a hook</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hook_add</span><span class="params">(self, htype, callback, user_data=None, begin=<span class="number">1</span>, end=<span class="number">0</span>, arg1=<span class="number">0</span>)</span>:</span></span><br><span class="line">        _h2 = uc_hook_h()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># save callback &amp; user_data</span></span><br><span class="line">        self._callback_count += <span class="number">1</span></span><br><span class="line">        self._callbacks[self._callback_count] = (callback, user_data)</span><br><span class="line">        cb = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> htype == uc.UC_HOOK_INSN: <span class="comment"># 特定の命令に応じた内部処理</span></span><br><span class="line">            insn = ctypes.c_int(arg1)</span><br><span class="line">            <span class="keyword">if</span> arg1 == x86_const.UC_X86_INS_IN:  <span class="comment"># IN命令</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_INSN_IN_CB(self._hook_insn_in_cb), UC_HOOK_INSN_IN_CB)</span><br><span class="line">            <span class="keyword">if</span> arg1 == x86_const.UC_X86_INS_OUT:  <span class="comment"># OUT命令</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_INSN_OUT_CB(self._hook_insn_out_cb), UC_HOOK_INSN_OUT_CB)</span><br><span class="line">            <span class="keyword">if</span> arg1 <span class="keyword">in</span> (x86_const.UC_X86_INS_SYSCALL, x86_const.UC_X86_INS_SYSENTER):  <span class="comment"># SYSCALL/SYSENTER命令</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_INSN_SYSCALL_CB(self._hook_insn_syscall_cb), UC_HOOK_INSN_SYSCALL_CB)</span><br><span class="line">            status = _uc.uc_hook_add(</span><br><span class="line">                self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                ctypes.c_uint64(begin), ctypes.c_uint64(end), insn</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> htype == uc.UC_HOOK_INTR: <span class="comment"># 割り込み</span></span><br><span class="line">            cb = ctypes.cast(UC_HOOK_INTR_CB(self._hook_intr_cb), UC_HOOK_INTR_CB)</span><br><span class="line">            status = _uc.uc_hook_add(</span><br><span class="line">                self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> htype <span class="keyword">in</span> (uc.UC_HOOK_BLOCK, uc.UC_HOOK_CODE): <span class="comment"># 基本ブロック・命令単位</span></span><br><span class="line">                <span class="comment"># set callback with wrapper, so it can be called</span></span><br><span class="line">                <span class="comment"># with this object as param</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_CODE_CB(self._hookcode_cb), UC_HOOK_CODE_CB)</span><br><span class="line">                status = _uc.uc_hook_add(</span><br><span class="line">                    self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                    ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                    ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">elif</span> htype &amp; (uc.UC_HOOK_MEM_READ_UNMAPPED |  <span class="comment"># 無効なメモリアクセス</span></span><br><span class="line">                          uc.UC_HOOK_MEM_WRITE_UNMAPPED |</span><br><span class="line">                          uc.UC_HOOK_MEM_FETCH_UNMAPPED |</span><br><span class="line">                          uc.UC_HOOK_MEM_READ_PROT |      <span class="comment"># 保護された領域へのメモリアクセス</span></span><br><span class="line">                          uc.UC_HOOK_MEM_WRITE_PROT |</span><br><span class="line">                          uc.UC_HOOK_MEM_FETCH_PROT):</span><br><span class="line">                cb = ctypes.cast(UC_HOOK_MEM_INVALID_CB(self._hook_mem_invalid_cb), UC_HOOK_MEM_INVALID_CB)</span><br><span class="line">                status = _uc.uc_hook_add(</span><br><span class="line">                    self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                    ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                    ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># メモリ読み書き</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_MEM_ACCESS_CB(self._hook_mem_access_cb), UC_HOOK_MEM_ACCESS_CB)</span><br><span class="line">                status = _uc.uc_hook_add(</span><br><span class="line">                    self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                    ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                    ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># save the ctype function so gc will leave it alone.</span></span><br><span class="line">        self._ctype_cbs[self._callback_count] = cb</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _h2.value</span><br></pre></td></tr></table></figure>
<h1 id="おわりに">おわりに</h1><p>　PythonからUnicornを利用する方法を紹介した．<br>　結局のところctypesでラップされており，こうした機能がどのようにして実行されるのかは本体のコードを読まなければ理解できない．そういうわけで，次回はUnicorn本体の実装を読んでいく．</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　※Rackサーバの方のUnicornではない．</p>
<h1 id="はじめに">はじめに</h1><p>　<a href="http://www.unicorn-engine.org/" target="_blank" rel="external">Unicorn</]]>
    </summary>
    
      <category term="dynamic binary translation" scheme="http://ntddk.github.io/tags/dynamic-binary-translation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[イスラエルのサイバーセキュリティ事情]]></title>
    <link href="http://ntddk.github.io/2016/06/29/cyber-security-in-israel/"/>
    <id>http://ntddk.github.io/2016/06/29/cyber-security-in-israel/</id>
    <published>2016-06-29T13:30:00.000Z</published>
    <updated>2016-06-30T00:46:12.703Z</updated>
    <content type="html"><![CDATA[<p>　これはマルウェアに感染した端末の基板で構成されたトロイの木馬．国際会議<a href="http://cyberweek.tau.ac.il" target="_blank" rel="external">Cyber Week</a>の展示の一環．</p>
<p><img src="/image/israel/cyberhorse.jpg" width="100%" height="100%"></p>
<h1 id="はじめに">はじめに</h1><p>　先週，イスラエル外務省からの招待でイスラエルのサイバーセキュリティ産業の視察に参加した．<br>　視察の参加者は日本政府・重要インフラ・セキュリティ業界関係に大別される．視察の目的は彼らにイスラエルの起業文化とサイバーセキュリティ技術を伝え，相互理解を図ることにあった．そんな視察になぜ一介のモラトリアム大学生でしかない私が潜り込めたのかというと，イスラエル外務省をハックしたから———というのは嘘．昨年発表した<a href="http://codeblue.jp/" target="_blank" rel="external">CODEBLUE</a>というセキュリティカンファレンスのオーガナイザーにイスラエル大使館から打診があり，若者枠に組み込まれたという経緯である．なんと旅費はイスラエル外務省の負担．<br>　そういうわけで，記憶が錆びつかないうちに，イスラエルのサイバーセキュリティ事情を紹介したい．</p>
<h1 id="総括">総括</h1><p>　最初にまとめてしまうと，イスラエルのサイバーセキュリティ産業は小国ゆえのフットワークの軽さがあってこそ成り立っている．とりわけ，以下の要素に負うところが大きい：</p>
<ul>
<li>徴兵制による人的つながり</li>
<li>R&amp;Dを重視したスタートアップのエコシステム</li>
<li>危機感</li>
</ul>
<p>したがって，そのまま日本にあてはめて考えることはできないが，柔軟な組織間連携の体制は間違いなく参考になるはずだ．</p>
<h2 id="徴兵制による人的つながり">徴兵制による人的つながり</h2><p>　イスラエルでは，18歳から男性は36ヶ月，女性は21ヶ月にわたる兵役が義務づけられている．高校を卒業して大学に進学するのではなく，まず国防軍 (IDF) に組み込まれるというわけだ．ツアーガイドの方が「6ヶ月間の基礎訓練が終わってはじめて教官が名前を教えてくれる．それからは下の名前で呼び合う，生涯にわたる仲になる」というエモい話を聞かせてくれたが，この兵役での人的つながりが，イスラエルのサイバーセキュリティ産業に多大な影響を及ぼしている．<strong>分野を越えたコネクションが形成され，小国ゆえに誰がどのように優秀か国が一元的に把握できる</strong>ためである．<br>　とりわけ優秀な人材は<a href="https://en.wikipedia.org/wiki/Talpiot_program" target="_blank" rel="external">タルピオット</a>という3年で数学と物理学の学位および中尉の階級を取得する人材育成プログラムに組み込まれるか，<a href="https://en.wikipedia.org/wiki/Unit_8200" target="_blank" rel="external">8200部隊</a>という諜報部隊———かのStuxnetをNSAと共同で開発したといういわくつきの———に配属され，それらの出身者であることがキャリアパス上の絶大なアピールポイントとなっている．<br>　このように兵役による能力のフィルタリングがあるため，学生は日本のように就職活動をするのではなく，優秀だった順に政府機関や企業から声がかかるという．多くの企業は軍との直接的なつながりを持たないが，重要インフラ事業者や政府のサイバーセキュリティ関連機関，軍需企業は軍と密接に結びついていて，盛んに情報を共有しているという．<br>　軍との関係は兵役が終わったらそれきりというわけではない．たとえば視察時に開催されていたCyber Week併設の全年齢対象CTFでは，空軍が（おそらくリクルートを兼ねて）作成した問題が用いられていた．開始早々に見学した問題の内容としてはMetasploitを用いるペンテストのようなものや，Androidアプリケーションのリバースエンジニアリングなど．</p>
<h2 id="R&amp;Dを重視したスタートアップのエコシステム">R&amp;Dを重視したスタートアップのエコシステム</h2><p>　さて，イスラエル政府が擁するサイバーセキュリティ関連機関は軍を除くと次のような構造になっている：</p>
<ul>
<li>イスラエル首相府<ul>
<li><a href="http://www.pmo.gov.il/English/PrimeMinistersOffice/DivisionsAndAuthorities/cyber/Pages/default.aspx" target="_blank" rel="external">国家サイバー局 (NCB: National Cyber Bureau)</a><ul>
<li><a href="http://www.cyberspark.org.il/" target="_blank" rel="external">CyberSpark</a></li>
<li><a href="https://icrc.tau.ac.il/" target="_blank" rel="external">ICRC (Blavatnik Interdisciplinary Cyber Research Center)</a></li>
<li>IC3 (Israel Cyber Companies Consortium)</li>
</ul>
</li>
<li>国家サイバーセキュリティ委員会 (NCSA: National Cyber Security Authority)<ul>
<li><a href="https://il-cert.org.il/" target="_blank" rel="external">IL-CERT</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　国家サイバー局は日本でいうところの<a href="http://www.nisc.go.jp/" target="_blank" rel="external">内閣サイバーセキュリティセンター (NISC) </a>的な立ち位置で，サイバーセキュリティ関連の産業育成と防衛について政府に進言する立場を担っている．国家サイバーセキュリティ委員会は各種標準化団体のほかCSIRTとしてIL-CERTを抱える機関である．<strong>IL-CERTではSTIX/TAXIIを用いた情報共有体制が確立されており，検体の挙動をタグベースで共有することで，機微情報を漏らすことなく複数機関にまたがったインシデントに対応できるようになっている</strong>らしい．視察では，ウェブベースの情報共有ツールも紹介された．<br>　国家サイバー局の下部にあるCyberSparkはイスラエル南部の中心都市ベエルシェバにある研究開発特区・機関で，ベンチャーキャピタル，国内のスタートアップ企業のほか，IBMやLockheed Martinといった多国籍企業，隣接するベン・グリオン大学から構成される．ネゲブ砂漠の開発を進めつつ，<strong>競合他社を大学との共同研究という形でまとめ，その研究をスタートアップとして興す</strong>ことを目的としているようだ．ICRCもまたテルアビブ大学を中心とした同様の学際的研究機関で，Cyber Weekのオーガナイザーでもあった．これらは東大京大と産総研やNII, NICTが直接つながっているようなものだと思えばよいが，研究内容を即座にスタートアップ化する点は興味深い．<br>　IC3は国営の軍需企業<a href="http://www.iai.co.il/" target="_blank" rel="external">IAI (Israel Aerospace Industries) </a>を中心としたジョイントベンチャーで，2020年の東京オリンピックに向けた日本市場開拓を虎視眈々とねらっている．<br>　この構造には，政府機関のほか次のようなベンチャーキャピタルとスタートアップ推進企業が噛んでいる：</p>
<ul>
<li><a href="https://www.bvp.com/" target="_blank" rel="external">BVP (Bessemer Venture Partners)</a></li>
<li><a href="www.jvpvc.com/">JVP (Jerusalem Venture Partners)</a></li>
<li><a href="http://www.team8.vc/" target="_blank" rel="external">Team8</a></li>
</ul>
<p>　BVPはアメリカ最古のベンチャーキャピタルだが，イスラエルのサイバーセキュリティ産業に熱視線を投げかけており，後述のTeam8や<a href="http://www.illusivenetworks.com/" target="_blank" rel="external">illusive networks</a>などに投資している．<br>　JVPはイスラエルのベンチャーキャピタルで，CyberSparkを構成する企業のひとつである．Cyber Labsという研究部門も設けており，軍と連携を図りつつ，国内のスタートアップをいくつも育成してきた．興味深かったのは<a href="http://www.cyactive.com/" target="_blank" rel="external">CyActive</a>なる企業の取り組み．遺伝的アルゴリズムを用いて既存のマルウェアを変異させることで，亜種そして未来のマルウェアに対して頑強なヒューリスティックエンジンを開発するといった研究を行っているそうだ．折しも今年のはじめに国際会議NDSSにおいて（PDFファイルに限定してはいるものの）<a href="http://www.internetsociety.org/sites/default/files/11_2-ndss2016-slides.pdf" target="_blank" rel="external">類似の研究</a>が発表されており，今後の動向に注目したい．<br>　Team8はサイバーセキュリティのR&amp;Dをスタートアップ化することを目的としたインキュベーション企業で，illusive networksの母体である．Team8の創設者はかの8200部隊出身者であり，軍で培った問題意識やマネジメント能力が糧となっていると語る．<br>　これらの企業の支援のもと興ったスタートアップは，狭いイスラエル国内でシェアを握るのではなく，海外市場の開拓とCyberSparkに参画しているような多国籍企業へのイグジットを目的としている．<br>　しかしこうした産学軍連携のスタートアップ促進体制は，<strong>イスラエルが小国であり，かつ物騒な隣人に恵まれていて，軍が産業の中核に食い込んでいるという特性</strong>（それは同時に「<strong>だからこそ</strong>イスラエルはサイバーセキュリティ先進国である」というイメージを抱かせることにも寄与している）あってこそだろう．</p>
<h2 id="危機感">危機感</h2><p>　彼らの口ぶりからすると，やはり周辺諸国との関係がサイバーセキュリティ産業の発展を後押ししているようだ．<br>　たとえば，<a href="https://www.iec.co.il/" target="_blank" rel="external">イスラエル電力公社</a>は国内の電力を一手に担っており，発電所がサイバー攻撃によって停止してしまえばイスラエルの国防は壊滅的な打撃を被る（もちろん周辺諸国からの給電は望めない）．したがって彼らのサイバーセキュリティに対する意識はきわめて高い．彼らのSOCは各施設に派遣されたオペレーターとそこからのアラートを分析する本社施設に分散して設置されており，情報の集約（縮約）と即時共有に力を入れている様子がうかがえた．<br>　また，電力公社の子会社として，電力制御システムに対するサイバー攻撃とその防御の訓練施設<a href="http://www.cybergym.co.il/" target="_blank" rel="external">CyberGym</a>がある．CyberGymは電力公社における訓練のみならず，他社からの依頼に応じてその運用環境を可能な限り再現，かつ攻撃ベクタを強調した環境を用いた5日ほどの演習サービスを提供している．演習場には小型のプラント装置が設置されており，攻撃によってはそこから水が噴き出してくるという．そうした物理的な（！）非常事態への対応力を養うことも，演習の目的であるようだ．<br>　電力公社のほか，IAIは企業のネットワークに対するサイバー攻撃演習サービスを提供している．IAIの演習では，仮想マシン・仮想ネットワーク上の演習環境を用いて，シナリオベースで攻撃への対応を学べるようになっている．<br>　電力公社・IAIとも，ベンダを問わずハードウェア・サーバソフトウェアを柔軟に組み替えられる環境を提供しており，有事———<strong>つねに有事ともいえる</strong>———に備えた訓練に余念がない．</p>
<h1 id="おわりに">おわりに</h1><p>　ざっくりとではあるが，イスラエルのサイバーセキュリティ事情を紹介してきた．<br>　国防上の要請があるため，どうしても緊張感は漂っているし，そこばかり強調したような文章になってしまったが，いい国だと思う．海は綺麗だし，食事も野菜が多く健康的で美味（帰国したらすぐに口内炎ができてしまった）．なにより，技術者が必要とされ，尊敬される風土である．サイバーセキュリティ関連の事業を興したいのであれば，移住を十分検討していい．とりあえずビザ申請しておくか……．<br>　はじめに断ったとおり，私はインテリジェンス活動や最新の脅威分析に携わっているわけではない，しがない学生なので，提示できる情報の解像度はこの程度である．同行した<a href="https://www.facebook.com/dnobori/posts/997712146972091?pnref=story" target="_blank" rel="external">ソフトイーサ登さんのレポート</a>も参照されたし．<br>　そのほかメモと感想：</p>
<ul>
<li>テルアビブ大学の学生のポスターセッション，みんな（セキュリティ分野なのに）機械学習やってて海外でも流行ってるんだなと思った</li>
<li>何の変哲もない（外には看板など一切なし）アパートの一区画を徴発して国家サイバー局が運営されていて流石にクソ興奮した，まあ見学者向けのダミーかもしれないが</li>
<li>イスラエル電力公社のSOCではおよそオペレーターの役には立たないだろう攻撃元の国をGoogle Mapにマッピングするシステムが表示されていたが，「可視化はきわめて重要だ．なぜなら，視察にきた海外政府関係者におたくの国からこれほど攻撃されている．ゆえに～とアピールできるからだ」と語っていたのがよかった．nicterやWADJETもそんな感じに使えるのかな</li>
<li>在イスラエル日本国大使館大使公邸にお邪魔したら入口の扉が3つあってモンティ・ホール問題かよと思った</li>
<li>飲み屋でチェイサーに水 (water) を頼んだら毎回ウォッカ (vodka) が出てくるので英語力の低さを呪っていたらロシア系移民のふざけた風習だった</li>
<li>エルサレムもテルアビブも治安としては渋谷とかその辺程度</li>
<li>人工知能による意思決定の文脈でadversarial examplesの問題を引き合いに出していた人がいて，やはりセキュリティ分野ではルールベースというか決定木に起こせないとトリアージが効かないから難しいなと思った</li>
<li>死海の名前の由来は「塩分濃度が高すぎて魚が住めないから」だそうだが，湖水の比重が高く多少の風では波立たないため時間が停まっているように見える様子が死を連想させる</li>
<li>IED兵士はみんなタボールを抱えているのかと思ったらベエルシェバの検問を除いて警察と同様みなCAR-15系にジェリコだった</li>
<li>イスラエルはLGBTに寛容で多様性を尊重する国であるというイメージ戦略なのだろうか，カーナビの地図上でLGBT区域が緑色に表示されるらしい</li>
<li>ベン・グリオン国際空港の端末はWindows + IE9でアエロフロート機内の端末はLinuxベース</li>
<li>トランジットで立ち寄ったシェレメチェボ空港での入出国審査はロシアだし「<a href="http://store.steampowered.com/app/239030/" target="_blank" rel="external">Papers, Please</a>」のような感じだと思っていたらそんなことはなかった</li>
<li>イスラエル出国審査時にパスポートの顔写真と顔が一致するかスキャンする（？）装置があったが，しっかりaccuracyが出るわけないのでおそらくはハリボテで，裏で人間がチェックしているのだろう</li>
<li>アラブ諸国に入国できなくなるという噂のパスポートへのスタンプは廃止されていた</li>
</ul>
<p>　はい．</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　これはマルウェアに感染した端末の基板で構成されたトロイの木馬．国際会議<a href="http://cyberweek.tau.ac.il" target="_blank" rel="external">Cyber Week</a>の展示の一環．</p>
<p><img]]>
    </summary>
    
      <category term="intelligence" scheme="http://ntddk.github.io/tags/intelligence/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写真から説明文を自動生成するbotを作った]]></title>
    <link href="http://ntddk.github.io/2016/03/26/neural-image-caption-generator-twitter-bot/"/>
    <id>http://ntddk.github.io/2016/03/26/neural-image-caption-generator-twitter-bot/</id>
    <published>2016-03-25T15:30:00.000Z</published>
    <updated>2016-07-08T08:51:14.827Z</updated>
    <content type="html"><![CDATA[<p><center><br><a class="twitter-timeline" href="https://twitter.com/img2cap" data-widget-id="713361832895860739" target="_blank" rel="external">@img2capさんのツイート</a></center></p>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<h1 id="これはなに">これはなに</h1><p>　<code>@img2cap file</code>という形式で画像を投げつけると説明文をつけ加えて返信するだけのTwitter bot.</p>
<h1 id="しくみ">しくみ</h1><p>　CNN + LSTM.<br>　以下の論文や実装を参考にした．裏ではChainerが動いている．</p>
<ul>
<li>論文<ul>
<li><a href="http://arxiv.org/abs/1411.4555" target="_blank" rel="external">[1411.4555] Show and Tell: A Neural Image Caption Generator</a></li>
</ul>
</li>
<li>実装<ul>
<li><a href="https://github.com/apple2373/chainer_caption_generation" target="_blank" rel="external">apple2373/chainer_caption_generation: Caption generation from images using deep neural net</a></li>
<li><a href="https://github.com/dsanno/chainer-image-caption" target="_blank" rel="external">dsanno/chainer-image-caption</a></li>
</ul>
</li>
<li>データセット<ul>
<li><a href="http://mscoco.org" target="_blank" rel="external">Microsoft COCO</a>を<a href="https://gist.github.com/ksimonyan/3785162f95cd2d5fee77#file-readme-md" target="_blank" rel="external">VGG_ILSVRC_19_layers</a>で<a href="http://cs.stanford.edu/people/karpathy/deepimagesent/coco.zip" target="_blank" rel="external">学習したもの</a></li>
</ul>
</li>
</ul>
<p>　はじめは論文通りの活性化関数と勾配法を試してみたが，dsanno氏のいうようにSGDよりAdamの方が高速．MomentumSGDと比べてもみたが即Adam最高！　という気分にさせられた．AdamがそもそもAdaGradとRMSPropのいいとこどりらしいので，その両者は試していない．なおネットワーク構成は論文のまま．<br>　データセットに含まれているのは<strong>写真</strong>8万枚とその説明文だけ．よってTwitterの各位がいくらイラストを投げつけようと無駄な話で，その手のニーズに対応するには<a href="https://nico-opendata.jp/ja/index.html" target="_blank" rel="external">ニコニコ静画のデータセット</a>あたりを使う必要がありそう．これには画像とそのタグ，コメントを学習したモデルが含まれているそうだが，説明文の生成というタスクに向けてどう転移学習させるか目処は立っていない．<br>　当然ながら学習データと実際に各位が投げつけてくるデータの分布は全く異なるし，困ったものだ．</p>
<h1 id="謝辞">謝辞</h1><p>　お遊びにGPU環境を貸してくれた<a href="https://twitter.com/georgioush" target="_blank" rel="external">@georgioush</a>, <a href="https://twitter.com/dasoran" target="_blank" rel="external">@dasoran</a>両氏に感謝．</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><center><br><a class="twitter-timeline" href="https://twitter.com/img2cap" data-widget-id="713361832895860739" target="_blank" rel="exter]]>
    </summary>
    
      <category term="machine learning" scheme="http://ntddk.github.io/tags/machine-learning/"/>
    
      <category term="neural network" scheme="http://ntddk.github.io/tags/neural-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ニューラルネットと脳の違いが知りたくて]]></title>
    <link href="http://ntddk.github.io/2016/03/21/book-guide-for-computational-neuroscience/"/>
    <id>http://ntddk.github.io/2016/03/21/book-guide-for-computational-neuroscience/</id>
    <published>2016-03-20T15:30:00.000Z</published>
    <updated>2016-07-08T08:51:43.733Z</updated>
    <content type="html"><![CDATA[<p>　読書メモ．</p>
<h1 id="はじめに">はじめに</h1><p>　人間の脳を模したニューラルネットの手法，<ruby>深層学習<rt>ディープラーニング</rt></ruby>がめざましい成果を挙げている—といった謳い文句をよく目にする．だが機械学習の専門書を紐解いても出てくるのはロジスティック回帰のお化けばかり．<br>　われらがPRMLのニューラルネットを扱う章にはこうある．</p>
<blockquote>
<p>しかしながら，パターン認識という実際的な応用の観点からは，生物学的な現実性などは全く不要な制約である．<br>　　　　　　　　　　　　　　　　　　　　　　　　— C.M.ビショップ『<a href="http://www.amazon.co.jp/dp/4621061224" target="_blank" rel="external">パターン認識と機械学習 上</a>』 (p.226)</p>
</blockquote>
<p>　では，機械学習の文脈で言うところのニューラルネットと脳はどれほど異なっているのだろうか？</p>
<h1 id="ニューラルネットと脳の違い">ニューラルネットと脳の違い</h1><p>　結論から言えば全然違うわけだが，ざっくり以下の三点から整理できる（と思う）：</p>
<ul>
<li>ニューロンのモデル</li>
<li>ネットワーク構造</li>
<li>微分計算の手法</li>
</ul>
<h2 id="ニューロンのモデル">ニューロンのモデル</h2><p>　現在広く普及している多層パーセプトロンは，単純な差分方程式であるMcCulloch-Pittsモデルをベースに，層を重ねたとき微分できるような活性化関数を組み合わせている．だがそれ以外にも膜電位が変動するメカニズムを考慮した：</p>
<ul>
<li>Hodgkin-Huxleyモデル</li>
<li>FitzHugh-Nagumoモデル</li>
<li>Izhikevichモデル</li>
</ul>
<p>などが提案されている—というようなことは機械学習の道具としてニューラルネットを扱っている本にはあまり書かれていない．ひとまず手元にあった：</p>
<ul>
<li>はじパタこと『<a href="http://www.amazon.co.jp/dp/4627849710/" target="_blank" rel="external">はじめてのパターン認識</a>』</li>
<li>わかパタこと『<a href="http://www.amazon.co.jp/dp/4274131491/" target="_blank" rel="external">わかりやすいパターン認識</a>』</li>
<li>『<a href="http://www.amazon.co.jp/dp/B016Q22IX2/" target="_blank" rel="external">ITエンジニアのための機械学習理論入門</a>』</li>
<li>PRMLこと『<a href="http://www.amazon.co.jp/dp/4621061224/" target="_blank" rel="external">パターン認識と機械学習</a>』</li>
<li>青色の『<a href="http://www.amazon.co.jp/dp/B018K6C99A/" target="_blank" rel="external">深層学習</a>』</li>
<li>紫色の『<a href="http://www.amazon.co.jp/dp/B01B768QJW/" target="_blank" rel="external">深層学習</a>』</li>
</ul>
<p>はモデル名に言及しておらず，McCulloch-Pittsモデルを紹介していたのは：</p>
<ul>
<li>『<a href="http://www.amazon.co.jp/dp/4274218023/" target="_blank" rel="external">進化計算と深層学習</a>』</li>
<li>『<a href="http://www.amazon.co.jp/dp/406153825X" target="_blank" rel="external">イラストで学ぶディープラーニング</a>』</li>
</ul>
<p>だけだった．<br>　ちなみにこの中だと機械学習マジで何もわからんって人はまずサンプルコードを動かしながら『<a href="http://www.amazon.co.jp/dp/B016Q22IX2/" target="_blank" rel="external">ITエンジニアのための機械学習理論入門</a>』を読むとよい．深層学習については<a href="http://www.amazon.co.jp/dp/B01B768QJW/" target="_blank" rel="external">紫色の本</a>が好み．<a href="http://www.amazon.co.jp/dp/B018K6C99A/" target="_blank" rel="external">青色の本</a>は数式が追いにくい（どっちもどっちだが）上，深層学習以前と以後でどのような変遷があったのか不明瞭で，『<a href="http://www.amazon.co.jp/dp/4274218023/" target="_blank" rel="external">進化計算と深層学習</a>』は概論のみ．『<a href="http://www.amazon.co.jp/dp/406153825X" target="_blank" rel="external">イラストで学ぶディープラーニング</a>』は読みやすく，汎化性能を向上させる方法も載っていて実践的ではあるが，RNNに触れられていないのが惜しい．<br>　さて，それではニューロンのモデルが複雑であれば脳に近いのかというと，どうやらそういうわけでもないらしい．たとえば複雑かつイオンコンダクタンスの挙動が緻密なHodgkin-Huxleyモデルは，ヤリイカの軸索のニューロンをモデル化したものだが，これはヒトの大脳皮質とはタイプが異なるようだ．<br>　しかし，McCulloch-Pittsモデルには，STDP (Spike Timing Dependent Plasticity, スパイク時刻依存シナプス可塑性) を表現できていないという問題点がある．STDPはニューロンの発火タイミングに応じて重みを更新する規則で，脳はこれにより時系列を学習しているとされる．<br>　こういったことを把握するためにいくつか神経科学の本を読んでみた．だいたいの書籍がまず最初にニューロンのモデルを紹介し，それからニューロンの同期に章を割き，つづいて脳の任意の部位の詳説という体裁をとっている．</p>
<ul>
<li>『<a href="http://www.amazon.co.jp/dp/4130643010/" target="_blank" rel="external">脳の計算論</a>』</li>
<li>『<a href="http://www.amazon.co.jp/dp/4130623044/" target="_blank" rel="external">理工学系からの脳科学入門</a>』</li>
<li>『<a href="http://www.amazon.co.jp/dp/B006YKU67M/" target="_blank" rel="external">臨時別冊数理科学 SGCライブラリ 60 「計算神経科学への招待」脳の学習機構の理解を目指して 2007年 12月号</a>』</li>
<li>『<a href="http://www.amazon.co.jp/dp/478281514X/" target="_blank" rel="external">脳の計算理論</a>』</li>
</ul>
<p>など．全部読んだ感想としては『<a href="http://www.amazon.co.jp/dp/4130643010/" target="_blank" rel="external">脳の計算論</a>』が最も明快かつ簡潔で，STDPにも詳しく，この記事で触れている範囲のことはほぼカバーしている．<br>　Izhikevichモデルの考案者も『<a href="http://www.izhikevich.org/publications/dsn/index.htm" target="_blank" rel="external">Dynamical Systems in Neuroscience: The Geometry of Excitability and Bursting</a>』という本を書いているのだが，これは難しそう．<br>　本腰を入れて学ぶには「<a href="http://gaya.jp/research/LTP-papers.htm" target="_blank" rel="external">シナプス可塑性の初心者へ　推薦論文リスト</a>」を消化すべきなのだろう．</p>
<h2 id="ネットワーク構造">ネットワーク構造</h2><p>　パーセプトロンは小脳に，BESOMは大脳皮質に，畳み込みニューラルネットは受容野に，TD学習は大脳基底核に似ていると言われている．ではどこが．<br>　小脳についてはさきほど挙げた『<a href="http://www.amazon.co.jp/dp/478281514X/" target="_blank" rel="external">脳の計算理論</a>』がよい．この<a href="http://www.cns.atr.jp/~kawato/Japanese.html" target="_blank" rel="external">著者</a>は小脳による運動の内部モデル獲得というテーマの大家だそうで，公開されている無料のPDFでその足跡が追える．Hodgkin-Huxleyモデルの解説も丁寧．あわせて“<a href="http://ci.nii.ac.jp/naid/10028190905" target="_blank" rel="external">現代の小脳パーセプトロン仮説</a>”も読みたい．<br>　大脳皮質については<a href="https://staff.aist.go.jp/y-ichisugi/j-index.html" target="_blank" rel="external">BESOMの人</a>の「<a href="https://staff.aist.go.jp/y-ichisugi/rapid-memo/brain-deep-learning.html" target="_blank" rel="external">大脳皮質と deep learning の類似点と相違点</a>」がとにかくわかりやすい．やはり正則化が重要なようだが，それについては「<a href="http://blog.livedoor.jp/brain_network/archives/50968197.html" target="_blank" rel="external">脳とネットワーク/The Swingy Brain:まとめてスパースコーディング - livedoor Blog（ブログ）</a>」に挙げられている論文を読むとよさそう．<br>　さらなる部位との関連については，「<a href="https://staff.aist.go.jp/y-ichisugi/brain-archi/j-index.html" target="_blank" rel="external">全脳アーキテクチャ解明に向けて</a>」から辿れる資料が親切だった．特に「<a href="http://www.slideshare.net/sato0427/wba3rd-satonao" target="_blank" rel="external">海馬神経回路の機能ダイナミクス</a>」で触れられている内容は元論文の古さとは裏腹にあまり書籍では見ない．</p>
<h2 id="微分計算の手法">微分計算の手法</h2><p>　みんな大好き誤差逆伝播法は脳では使われていない．じゃあどうすればいいかというと：</p>
<ul>
<li>『<a href="http://www.amazon.co.jp/dp/0262650541" target="_blank" rel="external">Computational Explorations in Cognitive Neuroscience: Understanding the Mind by Simulating the Brain</a>』<ul>
<li>5章</li>
</ul>
</li>
<li>“<a href="http://arxiv.org/abs/1412.7525" target="_blank" rel="external">Difference Target Propagation</a>”<ul>
<li><a href="http://deeplearning.jp/wp-content/uploads/2014/04/20150826_suzuki.pdf" target="_blank" rel="external">日本語の解説</a></li>
</ul>
</li>
<li>“<a href="http://arxiv.org/abs/1502.04156" target="_blank" rel="external">Towards Biologically Plausible Deep Learning</a>”</li>
</ul>
<p>がある．後者2つは深層学習の大家であるBengioらの研究で，ここでSTDPが重要となってくるらしい．生物学的な妥当な深層学習まであと何年だろうか．</p>
<h1 id="おわりに">おわりに</h1><p>　機械学習のことは多少わかるけど（計算論的）神経科学については何から勉強すればいいのかもわからないというところから，騙し騙しとはいえ論文を読める程度になるにはこのあたりを読むとよいのではないかと思います．<br>　なお，このブログに貼られているAmazonリンクはいずれも素のリンクです．ご安心ください．アフィリエイトリンクを貼りまくって小銭を稼ごうと画策しましたが審査に落ちました．</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　読書メモ．</p>
<h1 id="はじめに">はじめに</h1><p>　人間の脳を模したニューラルネットの手法，<ruby>深層学習<rt>ディープラーニング</rt></ruby>がめざましい成果を挙げている—といった謳い文句をよく目にする．だが機械学習の専門書を紐解]]>
    </summary>
    
      <category term="machine learning" scheme="http://ntddk.github.io/tags/machine-learning/"/>
    
      <category term="neural network" scheme="http://ntddk.github.io/tags/neural-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[寿司とメモ化再帰]]></title>
    <link href="http://ntddk.github.io/2016/03/02/sushi-and-memorized-recursion/"/>
    <id>http://ntddk.github.io/2016/03/02/sushi-and-memorized-recursion/</id>
    <published>2016-03-02T06:30:00.000Z</published>
    <updated>2016-03-02T07:24:52.782Z</updated>
    <content type="html"><![CDATA[<p>　わざわざブログに書くほどでもないことから書いていかないとなまるので書く．</p>
<h1 id="はじめに">はじめに</h1><p>　寿司 虚空編[1]第2話で登場したアッカーマン関数というかS変換を実装する．</p>
<h1 id="定義">定義</h1><p>　<span>$x, y$</span><!-- Has MathJax -->を非負整数として，</p>
<span>$$Ack(x,y)=
  \begin{cases}
   y+1 &amp; \text{if}\ x=0, \\
   Ack(x-1,1) &amp; \text{if}\ x&gt;0, y=0, \\
   Ack(x-1,Ack(x,y-1)) &amp; \text{otherwise}.
  \end{cases}$$</span><!-- Has MathJax -->
<p>　恥ずかしながら「Union-Find木のならし計算量はアッカーマン関数の逆関数となる」といった説明でしか見たことがない．</p>
<h1 id="実験">実験</h1><p>　何も考えずに<span>$Ack(3, 3)$</span><!-- Has MathJax -->を実装．なお記号は寿司 虚空編に準拠．</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(m, n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> f(n)</span><br><span class="line">  <span class="keyword">elif</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> b(m - <span class="number">1</span>, <span class="number">1</span>) </span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> b(m - <span class="number">1</span>, b(m, n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> b(x, x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">print</span> g(<span class="number">3</span>) <span class="comment"># Ack(3, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>
<p>　実行してみる．ついでにプロファイリング．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python -m cProfile -s time ./sushi.py&#10;61&#10;         3624 function calls (1193 primitive calls) in 0.006 seconds&#10;&#10;   Ordered by: internal time&#10;&#10;   ncalls  tottime  percall  cumtime  percall filename:lineno(function)&#10;   2432/1    0.005    0.000    0.006    0.006 sushi.py:4(b)&#10;     1188    0.001    0.000    0.001    0.000 sushi.py:1(f)&#10;        1    0.000    0.000    0.006    0.006 sushi.py:15(main)&#10;        1    0.000    0.000    0.006    0.006 sushi.py:1(&#60;module&#62;)&#10;        1    0.000    0.000    0.006    0.006 sushi.py:12(g)&#10;        1    0.000    0.000    0.000    0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125;</span><br></pre></td></tr></table></figure>
<p>　このプログラムで<span>$Ack(x, y)$</span><!-- Has MathJax -->を計算しようとすると<code>RuntimeError: maximum recursion depth exceeded</code>となって死ぬ．<br>　そこで次の手法を導入する：</p>
<ul>
<li>スタック制限の緩和</li>
<li>再帰深度制限の緩和</li>
<li>メモ化再帰</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, threading, thread</span><br><span class="line"></span><br><span class="line">memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(m, n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> (m, n) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">    memo[(m, n)] = (</span><br><span class="line">      f(n)        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span> <span class="keyword">else</span></span><br><span class="line">      b(m - <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">if</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span> <span class="keyword">else</span></span><br><span class="line">      b(m - <span class="number">1</span>, b(m, n - <span class="number">1</span>))</span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">return</span> memo[(m,n)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> b(x, x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">print</span> g(<span class="number">3</span>)   <span class="comment"># 61</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  sys.setrecursionlimit(<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">  thread.stack_size(<span class="number">128</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">  threading.Thread(target=main).start()</span><br></pre></td></tr></table></figure>
<p>　やる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python -m cProfile -s time ./sushi.py&#10;61&#10;         415 function calls in 0.002 seconds&#10;&#10;   Ordered by: internal time&#10;&#10;   ncalls  tottime  percall  cumtime  percall filename:lineno(function)&#10;        1    0.000    0.000    0.002    0.002 threading.py:1(&#60;module&#62;)&#10;        1    0.000    0.000    0.000    0.000 collections.py:1(&#60;module&#62;)&#10;        1    0.000    0.000    0.002    0.002 sushi.py:1(&#60;module&#62;)&#10;        7    0.000    0.000    0.000    0.000 &#123;method &#39;acquire&#39; of &#39;thread.lock&#39; objects&#125;&#10;        1    0.000    0.000    0.000    0.000 heapq.py:31(&#60;module&#62;)&#10;       91    0.000    0.000    0.000    0.000 &#123;method &#39;append&#39; of &#39;list&#39; objects&#125;&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:379(_parse)&#10;       28    0.000    0.000    0.000    0.000 sre_parse.py:182(__next)&#10;        2    0.000    0.000    0.000    0.000 sre_compile.py:359(_compile_info)&#10;       73    0.000    0.000    0.000    0.000 &#123;len&#125;&#10;        2    0.000    0.000    0.000    0.000 sre_compile.py:32(_compile)&#10;       26    0.000    0.000    0.000    0.000 sre_parse.py:201(get)&#10;       22    0.000    0.000    0.000    0.000 sre_parse.py:138(append)&#10;        1    0.000    0.000    0.000    0.000 &#123;thread.start_new_thread&#125;&#10;        4    0.000    0.000    0.000    0.000 threading.py:259(__init__)&#10;        2    0.000    0.000    0.000    0.000 threading.py:656(__init__)&#10;        2    0.000    0.000    0.001    0.000 re.py:226(_compile)&#10;       21    0.000    0.000    0.000    0.000 &#123;ord&#125;&#10;        2    0.000    0.000    0.001    0.000 sre_compile.py:493(compile)&#10;        1    0.000    0.000    0.001    0.001 warnings.py:45(filterwarnings)&#10;        1    0.000    0.000    0.000    0.000 threading.py:308(wait)&#10;        8    0.000    0.000    0.000    0.000 threading.py:58(__init__)&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:675(parse)&#10;        2    0.000    0.000    0.000    0.000 threading.py:560(__init__)&#10;        1    0.000    0.000    0.000    0.000 threading.py:640(Thread)&#10;        4    0.000    0.000    0.000    0.000 threading.py:241(Condition)&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:140(getwidth)&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:301(_parse_sub)&#10;       12    0.000    0.000    0.000    0.000 &#123;_sre.getlower&#125;&#10;       10    0.000    0.000    0.000    0.000 &#123;isinstance&#125;&#10;        1    0.000    0.000    0.000    0.000 threading.py:726(start)&#10;        2    0.000    0.000    0.000    0.000 sre_compile.py:478(_code)&#10;        4    0.000    0.000    0.000    0.000 sre_compile.py:472(isstring)&#10;        1    0.000    0.000    0.000    0.000 threading.py:1090(__init__)&#10;        2    0.000    0.000    0.000    0.000 &#123;method &#39;setter&#39; of &#39;property&#39; objects&#125;&#10;        1    0.000    0.000    0.000    0.000 collections.py:26(OrderedDict)&#10;        6    0.000    0.000    0.000    0.000 &#123;thread.allocate_lock&#125;&#10;        1    0.000    0.000    0.000    0.000 threading.py:602(wait)&#10;        1    0.000    0.000    0.000    0.000 threading.py:124(_RLock)&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:178(__init__)&#10;        1    0.000    0.000    0.000    0.000 threading.py:627(_newname)&#10;        1    0.000    0.000    0.000    0.000 threading.py:575(set)&#10;        4    0.000    0.000    0.000    0.000 &#123;min&#125;&#10;        2    0.000    0.000    0.001    0.000 re.py:188(compile)&#10;        3    0.000    0.000    0.000    0.000 &#123;thread.get_ident&#125;&#10;        1    0.000    0.000    0.000    0.000 keyword.py:11(&#60;module&#62;)&#10;        1    0.000    0.000    0.000    0.000 threading.py:372(notify)&#10;        1    0.000    0.000    0.000    0.000 &#123;thread.stack_size&#125;&#10;        1    0.000    0.000    0.000    0.000 threading.py:709(_set_daemon)&#10;        2    0.000    0.000    0.000    0.000 threading.py:541(Event)&#10;        2    0.000    0.000    0.000    0.000 threading.py:299(_is_owned)&#10;        2    0.000    0.000    0.000    0.000 &#123;_sre.compile&#125;&#10;        3    0.000    0.000    0.000    0.000 &#123;method &#39;release&#39; of &#39;thread.lock&#39; objects&#125;&#10;        1    0.000    0.000    0.000    0.000 threading.py:296(_acquire_restore)&#10;        1    0.000    0.000    0.000    0.000 &#123;sys.setrecursionlimit&#125;&#10;        2    0.000    0.000    0.000    0.000 &#123;method &#39;extend&#39; of &#39;list&#39; objects&#125;&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:67(__init__)&#10;        1    0.000    0.000    0.000    0.000 threading.py:399(notifyAll)&#10;        1    0.000    0.000    0.000    0.000 collections.py:387(Counter)&#10;        2    0.000    0.000    0.000    0.000 &#123;method &#39;get&#39; of &#39;dict&#39; objects&#125;&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:90(__init__)&#10;        1    0.000    0.000    0.000    0.000 threading.py:293(_release_save)&#10;        1    0.000    0.000    0.000    0.000 threading.py:551(_Event)&#10;        2    0.000    0.000    0.000    0.000 sre_parse.py:195(match)&#10;        3    0.000    0.000    0.000    0.000 threading.py:63(_note)&#10;        1    0.000    0.000    0.000    0.000 threading.py:1152(currentThread)&#10;        1    0.000    0.000    0.000    0.000 threading.py:254(_Condition)&#10;        2    0.000    0.000    0.000    0.000 &#123;method &#39;items&#39; of &#39;dict&#39; objects&#125;&#10;        1    0.000    0.000    0.000    0.000 threading.py:789(_set_ident)&#10;        1    0.000    0.000    0.000    0.000 threading.py:1058(_Timer)&#10;        1    0.000    0.000    0.000    0.000 threading.py:1088(_MainThread)&#10;        1    0.000    0.000    0.000    0.000 &#123;method &#39;insert&#39; of &#39;list&#39; objects&#125;&#10;        1    0.000    0.000    0.000    0.000 threading.py:422(_Semaphore)&#10;        1    0.000    0.000    0.000    0.000 threading.py:1097(_set_daemon)&#10;        1    0.000    0.000    0.000    0.000 threading.py:569(isSet)&#10;        1    0.000    0.000    0.000    0.000 threading.py:56(_Verbose)&#10;        1    0.000    0.000    0.000    0.000 threading.py:1128(_DummyThread)&#10;        1    0.000    0.000    0.000    0.000 threading.py:1008(daemon)&#10;        1    0.000    0.000    0.000    0.000 &#123;issubclass&#125;&#10;        1    0.000    0.000    0.000    0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125;&#10;        1    0.000    0.000    0.000    0.000 threading.py:514(_BoundedSemaphore)</span><br></pre></td></tr></table></figure>
<p>　関数呼び出し回数が3624回から415回まで減り，4msec高速化．</p>
<h1 id="おわりに">おわりに</h1><p>　それでも<span>$Ack(4, 2)$</span><!-- Has MathJax -->でSEGVするのでこのお話はなかったことに．<span>$2^{65536}-3$</span><!-- Has MathJax -->は遠い．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>[1] 寿司 虚空編 -Sushi Kokuu Hen- - pixivコミックで漫画を無料試し読み．<a href="https://comic.pixiv.net/works/1505" target="_blank" rel="external">https://comic.pixiv.net/works/1505</a></li>
<li>[2] S変換 - 巨大数研究 Wiki - Wikia．<a href="http://ja.googology.wikia.com/wiki/S%E5%A4%89%E6%8F%9B" target="_blank" rel="external">http://ja.googology.wikia.com/wiki/S%E5%A4%89%E6%8F%9B</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>　わざわざブログに書くほどでもないことから書いていかないとなまるので書く．</p>
<h1 id="はじめに">はじめに</h1><p>　寿司 虚空編[1]第2話で登場したアッカーマン関数というかS変換を実装する．</p>
<h1 id="定義">定義</h1><p>　<s]]>
    </summary>
    
      <category term="algorithm" scheme="http://ntddk.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[凧揚げ]]></title>
    <link href="http://ntddk.github.io/2016/01/08/controlling-rolling-spider-with-leap-motion-cylon-js/"/>
    <id>http://ntddk.github.io/2016/01/08/controlling-rolling-spider-with-leap-motion-cylon-js/</id>
    <published>2016-01-08T09:00:00.000Z</published>
    <updated>2016-04-02T00:51:25.553Z</updated>
    <content type="html"><![CDATA[<p>　凧揚げの様子．</p>
<center><iframe src="https://vine.co/v/ihdD7VVeeYz/embed/simple" width="300" height="300" frameborder="0"></iframe><script src="https://platform.vine.co/static/scripts/embed.js"></script></center>

<h1 id="TL;DR:">TL;DR:</h1><p>　新年なので凧揚げをやる．<br>　具体的にはCylon.jsを用いてLeap MotionからRolling Spiderを操作し，ついでにSlackに通知する．<br>　依存関係は次の通り．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install cylon cylon-keyboard cylon-leapmotion cylon-rolling-spider node-slack</span><br></pre></td></tr></table></figure></p>
<h1 id="Cylon-js">Cylon.js</h1><p>　<a href="http://cylonjs.com/" target="_blank" rel="external">Cylon.js</a>はロボティクス向けに開発されているJavaScriptのラッパーライブラリ．<br>　マイコンボードやドローン，スマートウォッチなど，さまざまなガジェットのSDKを統一されたインターフェイスで利用できる．反面，バグを踏み抜くと少ししんどい．<br>　たとえばキーボードに接続するには，次のように書く．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cylon = <span class="built_in">require</span>(<span class="string">'cylon'</span>);</span><br><span class="line"></span><br><span class="line">Cylon.robot(&#123;</span><br><span class="line">    connections: &#123;</span><br><span class="line">        <span class="string">'keyboard'</span>: &#123; adaptor: <span class="string">'keyboard'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    devices: &#123;</span><br><span class="line">        keyboard: &#123;driver: <span class="string">'keyboard'</span>, connection: <span class="string">'keyboard'</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    work: <span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">        my.keyboard.on(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">            my.log(<span class="string">"A PRESSED!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>　これでお手軽キーロガーのできあがりだ．内部ではkeypressというモジュールが呼ばれる．</p>
<h1 id="Leap_Motion">Leap Motion</h1><p>　<a href="https://www.leapmotion.com/" target="_blank" rel="external">Leap Motion</a>は人間の手の動きを入力に変換できるモーションセンサー．<br>　以前から研究室に転がっていたものの，これまで<a href="http://radiatoryang.itch.io/hurt-me-plenty" target="_blank" rel="external">ケツ叩きゲーム</a>にしか使われてこなかった．<br>　Cylon.jsで複数のガジェットを扱うときは，<code>connections</code>と<code>devices</code>に追記していけばよい．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cylon = <span class="built_in">require</span>(<span class="string">'cylon'</span>);</span><br><span class="line"></span><br><span class="line">Cylon.robot(&#123;</span><br><span class="line">    connections: &#123;</span><br><span class="line">        <span class="string">'keyboard'</span>: &#123; adaptor: <span class="string">'keyboard'</span> &#125;,</span><br><span class="line">        <span class="string">'leapmotion'</span>: &#123; adaptor: <span class="string">'leapmotion'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    devices: &#123;</span><br><span class="line">        keyboard: &#123;driver: <span class="string">'keyboard'</span>, connection: <span class="string">'keyboard'</span>&#125;,</span><br><span class="line">        leapmotion: &#123; driver: <span class="string">'leapmotion'</span>, connection: <span class="string">'leapmotion'</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    work: <span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">        my.leapmotion.on(<span class="string">'gesture'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">            my.log(g.type.toString());</span><br><span class="line">            <span class="keyword">if</span> (g.type == <span class="string">"circle"</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>　これで手の動きが取れる．内部ではleapjsというモジュールが呼ばれる．<br>　次はドローンだ．</p>
<h1 id="Rolling_Spider">Rolling Spider</h1><p>　<a href="http://www.parrot.com/jp/products/rolling-spider/" target="_blank" rel="external">Rolling Spider</a>はParrot社の小型ドローン．というとすぐドローンの定義は自律航行可能であるとかないとかクアッドコプターという呼称がどうとか言いだすやつがいるけど，ここではドローンと呼んでいる．<br>　それでは，Rolling SpiderをLeap Motionで操作してみよう．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cylon = <span class="built_in">require</span>(<span class="string">'cylon'</span>);</span><br><span class="line"></span><br><span class="line">Cylon.robot(&#123;</span><br><span class="line">    connections: &#123;</span><br><span class="line">        <span class="string">'keyboard'</span>: &#123; adaptor: <span class="string">'keyboard'</span> &#125;,</span><br><span class="line">        <span class="string">'leapmotion'</span>: &#123; adaptor: <span class="string">'leapmotion'</span> &#125;,</span><br><span class="line">        <span class="string">'rolling-spider'</span>: &#123; adaptor: <span class="string">'rolling-spider'</span>, uuid: <span class="string">'***'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    devices: &#123;</span><br><span class="line">        keyboard: &#123;driver: <span class="string">'keyboard'</span>, connection: <span class="string">'keyboard'</span>&#125;,</span><br><span class="line">        leapmotion: &#123; driver: <span class="string">'leapmotion'</span>, connection: <span class="string">'leapmotion'</span>&#125;,</span><br><span class="line">        drone: &#123; driver: <span class="string">'rolling-spider'</span>, connection: <span class="string">'rolling-spider'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">​</span><br><span class="line">    work: <span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">        my.leapmotion.on(<span class="string">'gesture'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">            my.log(g.type.toString());</span><br><span class="line">            <span class="keyword">if</span> (g.type == <span class="string">"circle"</span>) &#123;</span><br><span class="line">                my.drone.takeOff();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g.type == <span class="string">"swipe"</span> &amp;&amp; !flag) &#123;</span><br><span class="line">                <span class="keyword">var</span> isHorizontal = <span class="built_in">Math</span>.abs(g.direction[<span class="number">0</span>]) &gt; <span class="built_in">Math</span>.abs(g.direction[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(isHorizontal)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(g.direction[<span class="number">0</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        my.drone.right();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        my.drone.left();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(g.direction[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        my.drone.up();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        my.drone.down();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g.type == <span class="string">"keyTap"</span>) &#123;</span><br><span class="line">                my.drone.land();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        my.keyboard.on(<span class="string">"down"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            my.drone.land();    </span><br><span class="line">        &#125;);</span><br><span class="line">        my.keyboard.on(<span class="string">"m"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            my.drone.emergency();</span><br><span class="line">        &#125;);</span><br><span class="line">        my.keyboard.on(<span class="string">"q"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            Cylon.halt();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>　とりあえずこれで動く．指を回すとドローンが飛び上がり，スワイプに応じて移動する．内部ではnode-rolling-spiderというモジュールが呼ばれる．<br>　複数台の機体に接続できるから，ドローンの編隊飛行も夢ではない．とはいえ，Bluetoothを経由した中央集権的な制御なので，自律飛行にはいたらないが．ほんとうに自律させたければ，ドローン側のファームウェアに手を入れる必要がある．Parrot社が公開している<a href="https://github.com/Parrot-Developers/RollingSpiderEdu" target="_blank" rel="external">RollingSpiderEdu</a>によると，どうやら共有ライブラリを用いてドローンのファームウェアに機能を追加できるようだ．いずれはレクサスのPVのように美しく飛ばしてみたいが，いっそドローンから自作したほうがいいかもしれないな．</p>
<center><iframe width="560" height="315" src="https://www.youtube.com/embed/uj0v1BgzUdc" frameborder="0" allowfullscreen></iframe></center>

<p>　なおRolling Spiderの総重量は65gなので，空港等の周辺や人口中心地区の上空でのドローン飛行を制限する<a href="http://www.mlit.go.jp/koku/koku_tk10_000003.html" target="_blank" rel="external">改正航空法</a>の対象とはならない．</p>
<h1 id="Slack">Slack</h1><p>　凧揚げもChatOpsの時代．<br>　node-slackというモジュールと，ドローンのコールバック機能を用いれば，バッテリー残量をSlackに通知できる．SlackのWebHooks URLに投げるだけだ．</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cylon = <span class="built_in">require</span>(<span class="string">'cylon'</span>),</span><br><span class="line">    Slack = <span class="built_in">require</span>(<span class="string">'node-slack'</span>),</span><br><span class="line">    slack = <span class="keyword">new</span> Slack(<span class="string">'https://hooks.slack.com/services/***'</span>);</span><br><span class="line">...</span><br><span class="line">    work: <span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">        my.drone.on(<span class="string">'battery'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            slack.send(&#123;</span><br><span class="line">                text: <span class="string">':battery:: '</span> + my.drone.getBatteryLevel() + <span class="string">'%'</span>,</span><br><span class="line">                channel: <span class="string">'#drone'</span>,</span><br><span class="line">                username: <span class="string">'Drone'</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>　こんなふうに通知される．</p>
<p><img src="/image/drone/slack.png" width="50%" height="50%"></p>
<p>　ちなみに，ドローンが移動するたびに通知なんかしていると「短期間に送信されたメッセージが多すぎるから表示しないよ！」と怒られる．</p>
<h1 id="その他の凧揚げ">その他の凧揚げ</h1><p>　Leap Motionによるドローンの操作はたぶんこの人が初．</p>
<center><iframe width="560" height="315" src="https://www.youtube.com/embed/hfq2SisPvCU" frameborder="0" allowfullscreen></iframe></center>

<p>　やっぱデカいドローンを飛ばしたいっすね．</p>
<h1 id="おわりに">おわりに</h1><p>　ジェスチャーでドローンを操作できるようになったことだし，フォースの力みたいでかっこいいと思って，年始にRolling Spiderを多摩川の土手で飛ばしていたらドローン嫌いっぽい人にクソ怒られた．すいません．<br>　あとドローンといえば『<a href="http://www.amazon.co.jp/dp/415031201X" target="_blank" rel="external">伊藤計劃トリビュート</a>』所収の藤井太洋「公正的戦闘規範」がおもしろいぞ！！！</p>
<h1 id="謝辞">謝辞</h1><ul>
<li>Leap Motionは<a href="https://twitter.com/shunki9" target="_blank" rel="external">@shunki9</a>から借りた．</li>
<li>Rolling Spiderは<a href="http://www.gehirn.co.jp/" target="_blank" rel="external">Gehirn Inc.</a>に買ってもらった．</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>　凧揚げの様子．</p>
<center><iframe src="https://vine.co/v/ihdD7VVeeYz/embed/simple" width="300" height="300" frameborder="0"></iframe><script s]]>
    </summary>
    
      <category term="drone" scheme="http://ntddk.github.io/tags/drone/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RNNLMによる論文タイトルの自動生成]]></title>
    <link href="http://ntddk.github.io/2015/12/19/generating-thesis-titles-with-rnnlm/"/>
    <id>http://ntddk.github.io/2015/12/19/generating-thesis-titles-with-rnnlm/</id>
    <published>2015-12-19T14:45:00.000Z</published>
    <updated>2016-07-08T08:52:28.589Z</updated>
    <content type="html"><![CDATA[<p>　本稿は<a href="http://www.adventar.org/calendars/1053" target="_blank" rel="external">慶應義塾大学SFC村井&amp;徳田研 Advent Calendar 2015</a>の19日目である．</p>
<h1 id="TL;DR:">TL;DR:</h1><p>　村井研・徳田研の卒論・修論・博論アーカイブから過去の論文タイトルを収集し，RNNLM（Recurrent Neural Network Language Model, 再帰型ニューラルネット言語モデル）[1]を用いて論文タイトルを自動生成する．</p>
<h1 id="手順">手順</h1><ol>
<li><a href="http://www.sfc.wide.ad.jp/paper.html" target="_blank" rel="external">論文アーカイブ</a>を雑にスクレイピング．</li>
<li>簡単のため英語タイトルを削る．データサイズは540行・16294字．</li>
<li>MeCabの<code>-Owakati</code>オプションで分かち書き．単語数は6272と少ない．</li>
<li>RNNLMで学習，出力．</li>
</ol>
<p>　生成した論文タイトルは次の通り．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25913;&#22793;&#36969;&#24540;&#27231;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#21270;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#26286;&#12425;&#12375;&#35336;&#31639;&#30330;&#35211;&#12434;&#21033;&#29992;&#12375;&#12383;UDL&#27231;&#22120;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12434;&#29992;&#12356;&#12383;&#27231;&#22120;&#12503;&#12525;&#12540;&#12502;&#20307;&#31995;&#12398;VoD&#12395;&#12388;&#12356;&#12390;&#38283;&#30330;&#12394;&#25915;&#25731;&#36939;&#29992;&#25163;&#27861;&#10;&#33258;&#24459;&#35336;&#31639;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;&#34892;&#21205;&#12395;-&#31227;&#21205;&#12471;&#12473;&#12486;&#12512;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#34907;&#26143;&#24773;&#22577;&#12434;&#29992;&#12356;&#12383;&#12499;&#12472;&#12517;&#12450;&#12521;&#12452;&#12476;&#12540;&#12471;&#12519;&#12531;&#23450;&#32681;&#12450;&#12540;&#12461;&#12486;&#12463;&#12481;&#12515;&#34920;&#12434;&#12377;&#12427;&#26908;&#20986;&#12518;&#12499;&#12461;&#12479;&#12473;&#12494;&#12540;&#12489;&#12398;&#12501;&#12449;&#12452;&#12523;&#27083;&#25104;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#12354;&#12375;&#12354;&#12392;&#36969;&#24540;&#12475;&#12461;&#12517;&#12522;&#12486;&#12451;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12434;&#29992;&#12356;&#12383;&#36000;&#33655;&#35696;&#20107;&#21462;&#12426;&#20837;&#12428;&#12383;&#12475;&#12531;&#12469;NEMOMANET&#35299;&#27770;&#10;&#12518;&#12540;&#12470;&#12456;&#12531;&#12486;&#12451;&#12486;&#12451;&#12395;&#36969;&#12375;&#12383;&#20206;&#24819;&#12394;&#36890;&#20449;&#25509;&#36817;&#12395;&#12424;&#12427;&#21046;&#24481;&#23550;&#35937;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#33988;&#31309;&#23398;&#26657;&#21033;&#29992;&#24615;&#12398;&#12383;&#12417;&#12398;&#20877;&#20316;&#26989;&#12395;&#38306;&#12377;&#12427;&#25345;&#32154;&#10;&#22411;&#36899;&#25658;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12395;&#22522;&#12389;&#12367;&#36960;&#38548;&#12467;&#12540;&#12489;&#12398;&#21521;&#12369;&#12383;&#12487;&#12472;&#12479;&#12523;&#27231;&#27083;&#12398;&#27083;&#31689;&#10;&#12450;&#12503;&#12522;&#12465;&#12540;&#12471;&#12519;&#12531;&#65306;&#22411;&#12392;&#26178;&#38291;&#29305;&#23450;&#12434;&#29992;&#12356;&#12383;&#21033;&#29992;&#22411;&#36335;&#28310;&#25312;&#30456;&#38306;&#12398;&#27083;&#31689;&#10;&#33258;&#24459;&#38651;&#35441;&#25945;&#32946;&#12395;&#12362;&#12369;&#12427;&#30064;&#31278;&#21697;&#36074;&#31354;&#38291;&#25903;&#25588;&#12471;&#12473;&#12486;&#12512;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#20301;&#32622;AV&#31471;&#26411;&#33879;&#20316;&#25480;&#26989;&#29305;&#27530;&#12488;&#12509;&#12525;&#12472;&#22411;&#12375;&#20998;&#26512;&#39640;&#36895;&#27083;&#31689;&#10;&#24195;&#22495;&#12434;&#21033;&#29992;&#12375;&#12383;&#27425;&#24540;&#29992;&#12395;&#12362;&#12369;&#12427;&#12524;&#12452;&#12516;&#12540;&#12394;&#25480;&#26989;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#12503;&#12525;&#12471;&#12473;&#12486;&#12512;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#27425;&#21046;&#24481;&#23550;&#12377;&#12427;&#12459;&#12513;&#12521;&#12434;&#21033;&#29992;&#12375;&#12383;Ad&#22411;&#38291;&#23627;&#22806;&#12497;&#12502;&#12522;&#12483;&#12463;&#27083;&#31689;&#10;&#21332;&#35519;:&#19981;s&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12395;&#12362;&#12369;&#12427;OS&#12473;&#12488;&#12522;&#12540;&#12511;&#12531;&#12464;&#12398;&#32771;&#24942;&#27231;&#22120;&#12467;&#12511;&#12517;&#12491;&#12465;&#12540;&#12471;&#12519;&#12531;&#37197;&#20449;&#12471;&#12473;&#12486;&#12512;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#12475;&#12531;&#12469;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#12487;&#12496;&#12452;&#12473;&#12477;&#12501;&#12488;&#12454;&#12455;&#12450;&#25991;&#23383;&#36890;&#20449;&#12471;&#12473;&#12486;&#12512;&#10;&#28961;&#32218;&#20316;&#26989;&#12417;&#12368;&#12427;&#12395;&#12362;&#12369;&#12427;&#12497;&#12465;&#12483;&#12488;IP&#30330;&#20449;&#12539;&#25903;&#25588;&#27231;&#27083;&#10;ELA&#19978;&#29872;&#22659;&#12395;&#24540;&#12376;&#12383;&#12375;&#12383;&#12467;&#12531;&#12500;&#12517;&#12540;&#12479;&#28204;&#23450;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#22411;&#12503;&#12521;&#12483;&#12488;&#12507;&#12540;&#12512;&#12398;&#36960;&#38548;&#12497;&#12465;&#12483;&#12488;&#12392;&#12471;&#12473;&#12486;&#12512;&#10;&#28961;&#32218;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12475;&#12531;&#12469;&#12434;&#32771;&#24942;&#12377;&#12427;&#21442;&#21152;&#21442;&#21152;&#12469;&#12540;&#12499;&#12473;&#12398;&#30740;&#31350;&#10;&#31227;&#21205;&#32773;&#12395;&#12362;&#12369;&#12427;&#20301;&#32622;&#36969;&#24540;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#25163;&#27861;&#12398;&#30740;&#31350;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12464;&#12523;&#12540;&#12500;&#12531;&#12464;&#12398;&#22238;&#35239;&#24615;&#12434;&#12471;&#12473;&#12486;&#12512;&#12375;&#12383;&#32076;&#36335;&#28040;&#32791;&#24615;&#12398;&#23455;&#29694;&#10;&#33258;&#24049;&#24773;&#22577;&#12434;&#29992;&#12356;&#12383;&#23455;&#12434;&#37327;&#23376;&#12424;&#12427;&#21332;&#35519;&#34920;&#34892;&#21205;&#27969;&#36890;&#10;&#12487;&#12472;&#12479;&#12523;&#21069;&#36960;&#38548;&#12375;&#12427;&#12375;&#12398;&#24773;&#22577;&#20849;&#26377;&#25903;&#25588;&#27231;&#27083;&#10;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12488;&#21487;&#35222;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12434;&#36554;&#30340;&#22522;&#30436;&#12301;&#38306;&#25968;&#12398;&#20998;&#26512;&#10;&#29872;&#22659;Computing&#36890;&#20449;DVB&#25658;&#24111;&#24615;&#12395;&#38306;&#12377;&#12427;&#31227;&#21205;&#21516;&#26399;&#21033;&#29992;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#12510;&#12523;&#12481;&#12497;&#12473;Function&#28961;&#32218;&#12475;&#12531;&#12469;&#12494;&#12540;&#12489;&#12434;&#29992;&#12356;&#12383;&#25216;&#34899;&#12510;&#12523;&#12481;&#25903;&#25588;&#25903;&#25588;&#20419;&#36914;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#12473;&#12510;&#12540;&#12488;&#19990;&#20195;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12395;&#12362;&#12369;&#12427;&#30456;&#20114;&#12502;&#12522;&#12483;&#12472;&#23478;&#38651;&#12471;&#12473;&#12486;&#12512;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#24773;&#22577;&#12398;&#12383;&#12417;&#12398;&#33288;&#21619;&#28961;&#25903;&#25588;&#12471;&#12473;&#12486;&#12512;&#12398;&#27083;&#31689;&#10;&#12458;&#12506;&#12524;&#12540;&#12486;&#12451;&#12531;&#12464;&#22411;IP&#29872;&#22659;&#12398;&#12503;&#12525;&#12501;&#12449;&#12452;&#12522;&#12531;&#12464;&#30340;&#12394;&#20449;&#38972;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#23455;&#26041;&#21521;&#33258;&#21205;&#12509;&#12525;&#12472;&#12395;&#12362;&#12369;&#12427;&#21516;&#26399;&#27231;&#22120;&#24615;&#12395;&#12362;&#12369;&#12427;&#30740;&#31350;&#10;&#12475;&#12531;&#12469;-&#25277;&#20986;&#29983;&#25104;&#12434;&#25903;&#25588;&#24773;&#22577;&#30331;&#37682;&#25277;&#20986;&#27231;&#27083;&#12398;&#27083;&#31689;&#10;&#12450;&#12489;&#12507;&#12483;&#12463;OS&#12395;&#12362;&#12369;&#12427;OS&#29872;&#22659;&#12398;Glass&#24615;&#22522;&#30436;&#27231;&#27083;&#12398;&#27083;&#31689;&#10;DV&#22320;&#12450;&#12503;&#12522;&#12465;&#12540;&#12471;&#12519;&#12531;&#12398;&#32773;&#12395;&#12424;&#12427;&#26368;&#36969;&#12356;&#12450;&#12523;&#12468;&#12522;&#12474;&#12512;&#10;&#21830;&#19978;&#12398;&#12383;&#12417;&#12398;&#36984;&#25246;&#12394;Mobile&#21177;&#29575;&#12471;&#12473;&#12486;&#12512;&#12398;&#27083;&#31689;&#10;&#12518;&#12499;&#12461;&#12479;&#12473;&#19990;&#20195;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#21177;&#29575;Wireless&#24773;&#22577;&#12398;Markit&#10;&#31995;&#21015;&#28436;&#22863;&#20301;&#32622;&#12473;&#12524;&#12483;&#12489;&#12469;&#12540;&#12499;&#12473;&#20108;&#12510;&#12483;&#12481;&#12531;&#12464;&#12510;&#12523;&#12481;&#12503;&#12525;&#12450;&#12463;&#12486;&#12451;&#12502;&#12514;&#12487;&#12523;&#12398;&#27083;&#31689;&#10;&#12497;&#12465;&#12483;&#12488;&#36969;&#24540;&#20184;&#12369;&#21033;&#29992;&#12434;&#32771;&#24942;&#12375;&#12383;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12502;&#12525;&#12464;&#12514;&#12487;&#12523;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;TranS&#24773;&#22577;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#12464;&#12523;&#12540;&#12503;&#12507;&#12473;&#12488;&#21516;&#26399;&#12408;&#12398;&#23433;&#20840;&#23653;&#27508;&#12392;&#20998;&#25955;&#10;&#12398;&#24773;&#22577;&#23550;&#35937;&#12391;&#12398;Mediator&#12467;&#12521;&#12508;&#12524;&#12540;&#12471;&#12519;&#12531;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#39006;&#20284;All&#12471;&#12473;&#12486;&#12512;&#10;&#24773;&#22577;&#12464;&#12523;&#12540;&#12503;&#12434;&#21033;&#29992;&#12377;&#12427;&#12487;&#12472;&#12479;&#12523;&#21046;&#24481;&#21205;&#30011;&#20687;&#37197;&#36865;&#12471;&#12473;&#12486;&#12512;&#12398;&#27083;&#31689;&#10;RFID&#12434;&#21033;&#29992;&#12375;&#12383;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;&#12503;&#12521;&#12483;&#12488;&#12501;&#12457;&#12540;&#12512;&#36578;&#36865;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#21608;&#36794;&#19978;&#12475;&#12461;&#12517;&#12522;&#12486;&#12451;&#12395;&#12362;&#12369;&#12427;&#12467;&#12531;&#12486;&#12461;&#12473;&#12488;&#32773;&#22522;&#28961;&#32218;&#12398;&#25552;&#26696;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;Link&#22411;&#26381;&#34892;&#21205;RCS&#12395;&#12362;&#12369;&#12427;&#21177;&#29575;&#12375;&#12394;&#12356;&#27231;&#27083;&#10;&#12463;&#12521;&#12471;&#12483;&#12463;&#22411;&#36554;&#36617;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12434;&#35299;&#27770;&#12375;&#12383;&#20998;&#25955;&#38899;&#22768;&#12394;&#12426;&#12377;&#12414;&#12375;&#12471;&#12473;&#12486;&#12512;&#10;Dynamic&#29305;&#24500;&#35299;&#26512;&#12395;&#22522;&#12389;&#12367;&#20206;&#24819;&#21046;&#24481;&#27231;&#27083;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#22810;&#27573;CSMA&#12395;&#12362;&#12369;&#12427;&#22810;&#27096;&#12394;&#35299;&#26512;&#31649;&#29702;&#27231;&#27083;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#31227;&#21205;&#27231;:&#12434;&#29992;&#12356;&#12383;-&#12467;&#12531;&#12486;&#12531;&#12484;&#12471;&#12473;&#12486;&#12512;&#12398;&#27083;&#31689;&#10;&#25216;&#34899;&#12475;&#12531;&#12469;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#12507;&#12540;&#12512;&#21270;&#12395;&#12424;&#12427;&#32076;&#36335;&#12469;&#12540;&#12496;&#10;&#12450;&#12503;&#12522;&#12465;&#12540;&#12471;&#12519;&#12531;&#22238;&#32218;&#12395;&#22522;&#12389;&#12367;&#34214;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#12377;&#12427;&#20316;&#25104;&#12408;&#12398;&#34892;&#21205;&#21033;&#29992;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12434;&#29992;&#12356;&#12383;&#12375;&#12383;&#12394;&#21205;&#30011;&#12523;&#12540;&#12523;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#27231;&#22120;&#21332;&#35519;&#21033;&#29992;Efficient&#12398;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#35299;&#27770;&#12398;&#12456;&#12531;&#12489;&#26144;&#20687;&#27083;&#31689;&#10;&#35336;&#31639;&#24773;&#22577;&#12434;&#21033;&#29992;&#12375;&#12383;&#23478;&#38651;&#25277;&#35937;&#12398;&#36855;&#12356;&#36899;&#25658;&#12408;&#12398;&#27083;&#31689;&#10;&#38306;&#36899;&#24773;&#22577;&#25945;&#32946;&#12395;&#12362;&#12369;&#12427;&#21205;&#30340;&#12513;&#12540;&#12523;&#12452;&#12505;&#12531;&#12488;&#21454;&#38598;&#12398;&#30740;&#31350;&#10;&#36890;&#30693;&#12395;&#12362;&#12369;&#12427;&#12487;&#12540;&#12479;&#12505;&#12540;&#12473;&#26041;&#24335;&#36092;&#36023;&#12395;&#12424;&#12427;&#12375;&#12383;&#29366;&#24907;&#26178;&#38291;&#12464;&#12523;&#12540;&#12503;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#12467;&#12531;&#12486;&#12461;&#12473;&#12488;:6&#12398;&#12383;&#12417;&#12398;&#12383;&#12417;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#38651;&#23376;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;&#12383;&#12417;&#12398;&#25552;&#26696;&#12392;&#23455;&#35013;&#10;&#33258;&#24049;&#38651;&#35441;&#12434;&#21033;&#29992;&#12375;&#12383;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#20998;&#25955;&#22411;&#25480;&#26989;&#23646;&#24615;&#21046;&#24481;&#27231;&#27083;&#12398;&#23455;&#29694;&#10;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;&#25277;&#20986;&#21270;&#29872;&#22659;&#12398;&#21521;&#19978;&#22311;&#32302;&#12471;&#12473;&#12486;&#12512;&#12398;&#27083;&#31689;&#10;Networks&#23550;&#25126;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12395;&#12362;&#12369;&#12427;&#23478;&#24237;&#12486;&#12522;&#12488;&#12522;&#12540;&#25163;&#27861;&#12398;&#27083;&#31689;&#10;&#24195;&#12496;&#12452;&#12488;&#20381;&#23384;&#24739;&#32773;&#12398;&#12383;&#12417;&#12398;&#21454;&#38598;&#21450;&#12403;&#31309;&#26997;&#12471;&#12473;&#12486;&#12512;&#10;IP&#12467;&#12531;&#12486;&#12461;&#12473;&#12488;&#31934;&#24230;&#28857;&#12398;&#12487;&#12540;&#12479;&#12505;&#12540;&#12473;&#30340;&#12392;-&#30330;&#35211;&#29872;&#22659;&#21205;&#30011;&#20687;&#12514;&#12487;&#12523;&#34892;&#21205;-&#10;&#36890;&#20449;&#20316;&#26989;&#12471;&#12473;&#12486;&#12512;&#12398;&#21547;&#12416;&#23646;&#24615;&#12475;&#12531;&#12469;&#12494;&#12540;&#12489;&#20184;&#12369;&#21487;&#33021;&#12513;&#12487;&#12451;&#12450;&#12398;&#25552;&#26696;&#12392;&#38283;&#30330;&#10;&#24773;&#22577;&#19990;&#20195;&#29872;&#22659;&#26178;&#12395;&#12424;&#12427;&#26368;&#36969;&#35222;&#28857;&#29872;&#22659;&#27231;&#27083;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#21332;&#35519;&#33988;&#31309;&#12514;&#12496;&#12452;&#12523;&#12496;&#12483;&#12486;&#12522;&#25903;&#25588;Shumu&#27231;&#22120;&#22411;&#35373;&#32622;&#12452;&#12531;&#12471;&#12487;&#12531;&#12488;Irma&#20445;&#35703;&#37327;&#10;&#20998;&#25955;&#22238;&#32218;&#12395;&#12475;&#12531;&#12469;&#12487;&#12540;&#12479;&#36969;&#24540;&#12434;&#12510;&#12483;&#12481;&#12531;&#12464;&#12392;&#22522;&#28310;&#21270;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#29872;&#22659;&#12373;&#26178;&#35079;&#25968;&#29992;&#26041;&#24335;&#12392;&#23529;&#35696;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#33258;&#24459;&#12522;&#12531;&#12463;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12539;&#23646;&#24615;&#21697;&#36074;&#10;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12375;&#12395;&#12362;&#12369;&#12427;&#12452;&#12531;&#12479;&#12501;&#12455;&#12540;&#12473;&#25216;&#27861;&#21270;&#25512;&#34214;&#27231;&#27083;&#12398;&#30740;&#31350;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12395;&#12362;&#12369;&#12427;&#20809;&#12434;&#29992;&#12356;&#12383;&#26368;&#36969;&#36960;&#38548;&#25903;&#25588;&#29872;&#22659;&#12398;&#27083;&#31689;&#10;&#12514;&#12540;&#12496;&#12452;&#12523;s&#21033;&#29992;&#12392;&#12408;&#12398;&#23455;&#29694;&#33258;&#21205;&#25163;&#27861;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12395;&#36969;&#12375;&#12383;&#26178;&#31471;&#26411;&#22411;TCP&#22411;&#12487;&#12540;&#12479;&#22522;&#28310;&#12398;&#20869;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12434;&#29992;&#12356;&#12383;&#21463;&#20449;&#12539;&#36766;&#26360;&#21454;&#38598;&#10;DOS&#30340;&#21033;&#29992;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;based&#37197;&#20449;&#12471;&#12473;&#12486;&#12512;&#12398;&#27083;&#31689;&#10;i&#65306;&#12392;&#21033;&#29992;&#12375;&#12383;&#24773;&#22577;&#12514;&#12540;&#12480;&#12523;&#12398;&#20316;&#25104;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;API&#12398;&#24773;&#22577;&#12395;&#12362;&#12369;&#12427;&#12477;&#12501;&#12488;&#12454;&#12455;&#12450;&#12377;&#12427;&#12434;&#12471;&#12473;&#12486;&#12512;&#12398;&#33258;&#24459;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12434;&#29992;&#12356;&#12383;&#12475;&#12523;&#20869;&#22238;&#36991;&#25163;&#27861;&#12450;&#12503;&#12522;&#12465;&#12540;&#12471;&#12519;&#12531;Function&#36984;&#25246;&#21046;&#24481;&#27231;&#27083;&#10;&#12510;&#12523;&#12481;:&#12518;&#12540;&#12470;&#26178;&#12398;Looking&#25903;&#25588;&#31478;&#21512;&#12398;&#21442;&#21152;&#24773;&#22577;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#12510;&#12523;&#12481;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12395;&#12424;&#12427;&#21205;&#30340;&#12522;&#12514;&#12467;&#12531;&#12450;&#12540;&#12461;&#12486;&#12463;&#12481;&#12515;&#12398;&#20998;&#26512;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#65306;&#25991;&#23383;&#12434;&#21547;&#12416;&#12392;&#23550;&#31574;&#36605;&#28187;&#22320;&#29702;&#12501;&#12449;&#12452;&#12523;&#12398;&#27083;&#31689;&#10;&#12450;&#12503;&#12522;&#12465;&#12540;&#12471;&#12519;&#12531;&#12398;&#12487;&#12472;&#12479;&#12523;&#34892;&#21205;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#36000;&#33655;&#25945;&#32946;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#31227;&#21205;&#21046;&#24481;&#22411;&#12513;&#12487;&#12451;&#12450;&#21462;&#12426;&#20837;&#12428;&#12383;&#12395;&#12362;&#12369;&#12427;&#33258;&#24459;&#12488;&#12509;&#12525;&#12472;&#12514;&#12487;&#12523;&#12398;&#25552;&#26696;&#10;&#26085;&#26412;&#22238;&#32218;&#26178;&#12395;&#12362;&#12369;&#12427;&#12475;&#12531;&#12469;&#12398;&#12450;&#12540;&#12461;&#12486;&#12463;&#12481;&#12515;&#10;&#12302;&#19990;&#20195;sion&#12434;&#25903;&#25588;&#24773;&#22577;&#12518;&#12540;&#12470;&#12398;&#23455;&#29694;&#10;Mobile&#12398;&#34892;&#21205;&#31354;&#38291;&#12395;&#22522;&#12389;&#12367;&#12377;&#12427;&#12467;&#12531;&#12509;&#12540;&#12493;&#12531;&#12488;&#12471;&#12473;&#12486;&#12512;&#12398;&#35373;&#35336;&#12392;&#27083;&#31689;&#10;&#12461;&#12483;&#12488;&#12521;&#12452;&#12502;&#12521;&#12522;&#12398;&#12450;&#12489;&#12524;&#12473;&#21033;&#29992;&#12434;&#25903;&#25588;&#12377;&#12427;&#12450;&#12503;&#12522;&#12465;&#12540;&#12471;&#12519;&#12531;&#12398;&#34892;&#21205;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#38291;:&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#35469;&#35388;&#26908;&#20986;&#12398;&#32771;&#23519;&#10;&#37749;&#30436;&#12434;&#29992;&#12356;&#12383;&#22522;&#30436;&#32076;&#36335;&#12488;&#12509;&#12525;&#12472;&#25903;&#25588;&#25163;&#27861;&#12398;&#30740;&#31350;&#10;RFID&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12434;&#29992;&#12356;&#12383;&#12392;&#12518;&#12540;&#12470;&#10;&#33258;&#24459;&#22411;&#27231;&#30340;&#12394;&#25903;&#25588;&#12524;&#12452;&#12516;&#12540;&#25163;&#27861;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;&#12450;&#12489;&#12507;&#12483;&#12463;&#12434;&#29992;&#12356;&#12383;&#12487;&#12472;&#12479;&#12523;&#26368;&#36969;&#26263;&#21495;&#12471;&#12473;&#12486;&#12512;&#12398;&#30740;&#31350;&#10;WWW&#20154;IPv&#12471;&#12473;&#12486;&#12512;&#12398;&#21205;&#30340;2&#12434;&#21270;&#12501;&#12525;&#12540;&#12452;&#12531;&#12501;&#12457;&#12513;&#12540;&#12471;&#12519;&#12531;&#37197;&#36865;&#21270;&#25163;&#27861;&#10;&#27425;&#30340;&#27231;&#12479;&#12501;&#12455;&#12540;&#12473;6&#12471;&#12473;&#12486;&#12512;&#12398;&#23455;&#29694;&#10;IP&#12524;&#12452;&#12516;&#12540;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12395;&#12362;&#12369;&#12427;&#12464;&#12523;&#12540;&#12503;&#21462;&#24471;&#36960;&#38548;&#12471;&#12473;&#12486;&#12512;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#10;&#20108;&#36890;&#20449;&#12518;&#12491;&#12496;&#12540;&#12469;&#12523;&#12395;&#12362;&#12369;&#12427;&#35079;&#25968;&#20849;&#26377;&#20877;&#12395;&#12388;&#12356;&#12390;&#12398;&#30740;&#31350;&#10;Tapirus&#19978;&#12398;&#24773;&#22577;&#30340;&#23455;&#29694;&#12354;&#12427;&#12398;&#27083;&#31689;&#10;&#29872;&#22659;&#19978;&#12395;&#12362;&#12369;&#12427;&#20206;&#24819;&#25351;&#27231;&#27083;&#12398;&#27083;&#31689;&#10;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#12395;&#12362;&#12369;&#12427;RFID&#32076;&#36335;&#12456;&#12531;&#12489;&#12494;&#12540;&#12489;&#12487;&#12540;&#12479;&#12505;&#12540;&#12473;&#20184;&#12369;&#12514;&#12487;&#12523;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;&#10;2&#22238;&#32218;&#23398;&#32722;&#12408;&#12398;&#21177;&#29575;&#30340;&#22411;&#29872;&#22659;&#12398;&#25552;&#26696;&#12392;&#27083;&#31689;&#10;...</span><br></pre></td></tr></table></figure>
<p>　これはRNNLMが生成した論文タイトルを100件無作為抽出したもの．全リストは<a href="https://gist.github.com/ntddk/c1dd4476677667157a97" target="_blank" rel="external">gist</a>に置いている．この程度のデータサイズでRNNLMの性能を云々するのはいささか危うい気がするが，論文タイトルの末尾はえてして「～の構築」「～の研究」「～の実現」になるというルールを獲得できている，ということだろうか．<br>　同じデータセットから，ありがちな2単語プリフィックスのマルコフ連鎖で生成した論文タイトルは次の通り．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#27880;&#30446;&#12375;&#12383;&#20108;&#28857;&#38291;&#25509;&#32154;&#22522;&#30436;&#12477;&#12501;&#12488;&#12454;&#12456;&#12450;&#12398;&#27083;&#31689;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#10;&#22320;&#22495;&#12395;&#12362;&#12369;&#12427;&#39640;&#31561;&#25945;&#32946;&#21332;&#21147;&#25163;&#27861;&#12398;&#30740;&#31350;&#12507;&#12540;&#12512;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12395;&#12362;&#12369;&#12427;&#22810;&#27096;&#10;&#12363;&#12388;&#12473;&#12465;&#12540;&#12521;&#12502;&#12523;&#12394;&#35672;&#21029;&#23376;&#31649;&#29702;&#12471;&#12473;&#12486;&#12512;&#12466;&#12540;&#12512;&#12467;&#12531;&#12477;&#12540;&#12523;&#12395;&#23550;&#24540;&#12377;&#12427;&#31649;&#29702;&#10;&#36939;&#29992;&#22522;&#30436;&#20998;&#26512;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#12509;&#12522;&#12471;&#32076;&#36335;&#21046;&#24481;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#22823;&#10;&#20219;&#24847;&#12398;&#29289;&#29702;&#30340;&#37327;&#23376;&#12499;&#12483;&#12488;&#12395;&#23550;&#12377;&#12427;&#21177;&#29575;&#30340;&#12394;&#24773;&#22577;&#38322;&#35239;&#10;&#33075;&#30130;&#21172;&#26908;&#30693;&#12471;&#12473;&#12486;&#12512;&#12398;&#25552;&#26696;&#27425;&#19990;&#20195;&#12452;&#12531;&#12479;&#12540;&#12493;&#12483;&#12488;&#32076;&#36335;&#21046;&#24481;&#12434;&#29992;&#12356;&#10;&#37749;&#20132;&#25563;&#27231;&#27083;&#12398;&#23455;&#35013;&#12392;&#35413;&#20385;&#21021;&#31561;&#20013;&#31561;&#25945;&#32946;&#12395;&#12362;&#12369;&#12427;WWW&#10;&#12503;&#12525;&#12475;&#12473;&#12487;&#12470;&#12452;&#12531;&#29255;&#26041;&#21521;&#12502;&#12525;&#12540;&#12489;&#12461;&#12515;&#12473;&#12488;&#12513;&#12487;&#12451;&#12450;&#12434;&#29992;&#12356;&#12383;&#12518;&#12499;&#12461;&#12479;&#12473;&#12467;&#12531;&#12500;&#12517;&#12540;&#12486;&#12451;&#12531;&#12464;&#29872;&#22659;&#12395;&#36969;&#12375;&#10;&#36899;&#25658;&#12471;&#12473;&#12486;&#12512;&#12398;&#35373;&#35336;&#12392;&#23455;&#35013;exPhoto:&#21608;&#36794;&#27231;&#22120;&#12392;&#25774;&#24433;&#10;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#20998;&#25955;&#29872;&#22659;&#12395;&#12362;&#12369;&#12427;&#12503;&#12525;&#12450;&#12463;&#12486;&#12451;&#12502;&#21046;&#24481;&#26041;&#24335;&#12395;&#38306;&#12377;&#12427;&#30740;&#31350;&#12450;&#12489;&#12507;&#12483;&#12463;&#10;...</span><br></pre></td></tr></table></figure>
<p>　パッと見でRNNLMが生成した論文タイトルの方がより自然に思える．で，RNNLMって何なの？</p>
<h1 id="RNNLM">RNNLM</h1><p>　読んで字のごとくRNNLMはRNNの言語モデルへの応用である．<br>　RNNは内部に有向閉路をもつニューラルネット．系列データの各時刻<span>$t$</span><!-- Has MathJax -->につき1つの入力<span>$x^t$</span><!-- Has MathJax -->をとり1つの出力<span>$y^t$</span><!-- Has MathJax -->を返す．ふつう順伝播型ニューラルネットは入力1つをとり1つの入力を与える写像を表現するが，RNNは任意の系列—すなわち過去のすべての入力から任意の系列への写像を表現する．<br>　これは<strong>時刻<span>$t-1$</span><!-- Has MathJax -->の隠れ層の出力を，時刻<span>$t$</span><!-- Has MathJax -->の隠れ層の入力に与える</strong>ことで実現される．</p>
<p><img src="/image/rnnlm/rnnlm.png" width="30%" height="30%"></p>
<p>　文章は系列データであり，文章に含まれる各単語は直前の単語の並びに依存している．そこで，1990年のエルマンネット[2]以来，RNNを用いた文章の分析が試みられてきた—近頃「RNNは深層学習の一種」というような言辞を見かけるが，RNN<span>$\in$</span><!-- Has MathJax -->深層学習では<strong>ない</strong>．<br>　RNNLMと既存手法との相違点は，単語を潜在空間に写像して単語の意味を獲得しようとしているところだ．<br>　上図において隠れ層のベクトルは単語の潜在ベクトルとその履歴より<span>$\begin{split}s(t) =&amp; f(Uw(t) + Ws(t-1))\end{split}$</span><!-- Has MathJax -->となる．次の単語の確率は<span>$\begin{split}y(t) =&amp; g(Vs(t))\end{split}$</span><!-- Has MathJax -->となる．<br>　ここで活性化関数<span>$f(z)$</span><!-- Has MathJax -->は標準シグモイド関数で，<span>$g(z)$</span><!-- Has MathJax -->はソフトマックス関数<span>$\dfrac {e^{zm}} {\Sigma _{k}e^{zm}}$</span><!-- Has MathJax -->である．<br>　学習では確率的勾配降下法を用いて重み<span>$U$</span><!-- Has MathJax -->, <span>$W$</span><!-- Has MathJax -->, <span>$V$</span><!-- Has MathJax -->を更新していくが，このときRNNLMは各層を時間方向に展開し，最後の時刻<span>$t$</span><!-- Has MathJax -->から誤差逆伝播計算をおこなう（BPTT, Backpropagation through time法）．<br>　ここにおいてRNNは多層の順伝播型ニューラルネットのようにみなせる．</p>
<p><img src="/image/rnnlm/bptt.png" width="30%" height="30%"></p>
<p>　BPTT法において，ある時刻<span>$t$</span><!-- Has MathJax -->における出力層の誤差は正解ベクトル<span>$d(t)$</span><!-- Has MathJax -->から出力<span>$y(t)$</span><!-- Has MathJax -->を引いた出力誤差<span>$e_{o}(t)$</span><!-- Has MathJax -->と，時刻<span>$t+1$</span><!-- Has MathJax -->から伝播してきた誤差の和となる．ここでたとえば<span>$V(t+1) = V(t) + s(t)e_{o}(t)^t\alpha - V(t)\beta$</span><!-- Has MathJax -->．<span>$\alpha$</span><!-- Has MathJax -->は学習率であり，各層で行列の勾配に掛かる．<span>$\beta$</span><!-- Has MathJax -->はL2正則化の係数．<br>　このBPTT法で長い系列を扱うとき勾配が消失してしまう問題[3]があり，解決策としてLSTM（Long Short-Term Memory, 長・短期記憶）[4]が提案されているが，割愛する．<br>　なお今回のパラメータは次の通り．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last probability of validation data: -441.610349&#10;number of finished iterations: 14&#10;current position in training data: 0&#10;current probability of training data: -441.576456&#10;save after processing # words: 0&#10;# of training words: 6272&#10;input layer size: 1295&#10;hidden layer size: 200&#10;compression layer size: 0&#10;output layer size: 1096&#10;direct connections: 0&#10;direct order: 3&#10;bptt: 6&#10;bptt block: 10&#10;vocabulary size: 1095&#10;class size: 1&#10;old classes: 0&#10;independent sentences mode: 1&#10;starting learning rate: 0.100000&#10;current learning rate: 0.000195&#10;learning rate decrease: 1</span><br></pre></td></tr></table></figure>
<h1 id="おわりに">おわりに</h1><p>　恥知らずのクソ野郎なので何番煎じともわからない記事を書いてしまった．元ネタは<a href="http://www.phontron.com/nlp-title/" target="_blank" rel="external">NLP論文ネタ一覧</a>．<br>　このほか青空文庫やなろう小説[5]をRNNに学習させてはいるが，LSTM込みでもいまだ人間が見て自然に思える文章の生成は難しく思える．<br>　いずれは論文タイトルばかりか論文の内容も自動生成して知の欺瞞をもう一発カマしたいのだが．SFC自体が知の欺瞞っぽいところはさておき．<br>　物語の自動生成なら円城塔がなんとかしてくれるだろう．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>[1] “RNNLM Toolkit,” <a href="http://rnnlm.org/" target="_blank" rel="external">http://rnnlm.org/</a><ul>
<li>記事中の画像は開発者による<a href="http://www.fit.vutbr.cz/~imikolov/rnnlm/google.pdf" target="_blank" rel="external">紹介スライド</a>より．</li>
<li>解説は<a href="http://kiyukuta.github.io/2013/12/09/mlac2013_day9_recurrent_neural_network_language_model.html" target="_blank" rel="external">これもある意味Deep Learning，Recurrent Neural Network Language Modelの話 [MLAC2013_9日目] — KiyuHu</a>がわかりやすい．</li>
</ul>
</li>
<li>[2] Jeffrey L. Elman, “<a href="http://crl.ucsd.edu/~elman/Papers/fsit.pdf" target="_blank" rel="external">Finding Structure in Time[PDF]</a>,” Cognitive Science, vol. 14, issue. 2, pp. 179-211, 1990.</li>
<li>[3] Sepp Hochreiter, “<a href="http://www.bioinf.jku.at/publications/older/3804.pdf" target="_blank" rel="external">Untersuchungen zu dynamischen neuronalen Netzen[PDF]</a>,” Diploma thesis, TU Munich, 1991.<ul>
<li>読めない．</li>
</ul>
</li>
<li>[4] Sepp Hochreiter and Jürgen Schmidhuber, “<a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="external">Long Short-Term Memory[PDF]</a>,” Neural Computation, vol. 9, no. 8, pp. 1735-1780, 1997.<ul>
<li>解説は<a href="http://qiita.com/t_Signull/items/21b82be280b46f467d1b" target="_blank" rel="external">MachineLearning - わかるLSTM ～ 最近の動向と共に - Qiita</a>がわかりやすい．</li>
</ul>
</li>
<li>[5] <a href="http://ncode.syosetu.com/n9073ca/" target="_blank" rel="external">幻想再帰のアリュージョニスト</a>，おすすめです．</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>　本稿は<a href="http://www.adventar.org/calendars/1053" target="_blank" rel="external">慶應義塾大学SFC村井&amp;徳田研 Advent Calendar 2015</a>の19日目である．]]>
    </summary>
    
      <category term="machine learing" scheme="http://ntddk.github.io/tags/machine-learing/"/>
    
      <category term="neural network" scheme="http://ntddk.github.io/tags/neural-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[マルウェアの動的解析に基づくC&Cサーバの探索]]></title>
    <link href="http://ntddk.github.io/2015/12/11/autoprobe/"/>
    <id>http://ntddk.github.io/2015/12/11/autoprobe/</id>
    <published>2015-12-11T03:00:00.000Z</published>
    <updated>2016-01-03T16:34:08.944Z</updated>
    <content type="html"><![CDATA[<p>　本稿は<a href="http://www.adventar.org/calendars/784" target="_blank" rel="external">情報セキュリティ系論文紹介 Advent Calendar 2015</a>の11日目である．</p>
<h1 id="TL;DR:">TL;DR:</h1><p>　テイント解析（taint analysis）やプログラムスライシング（program slicing），記号的実行（symbolic execution）やファジング（fuzzing）といったバイナリ解析技術を総動員して，マルウェアが通信するC&amp;Cサーバのフィンガープリントを<strong>C&amp;Cサーバと通信せずとも</strong>生成する手法—AUTOPROBE[1]を紹介する．</p>
<h1 id="背景">背景</h1><p>　マルウェアによるサイバー犯罪はC&amp;Cサーバやコンフィグファイルの配布元，二次検体の配布元など様々な悪性サーバ（malicious server）からなるインフラによって支えられている．攻撃者はこれらの悪性サーバを頻繁に閉鎖・移転させて対策から逃れようとする．とりわけ攻撃者の命令を送信してマルウェアの動作を決定するC&amp;Cサーバはその後の攻撃の起点となるため早期発見が望ましい．したがって不審なサーバがC&amp;Cサーバかどうか判定するフィンガープリントが必要となる．<br>　しかしながら従来のフィンガープリント生成手法にはC&amp;Cサーバとの長期的な通信を前提としている[2]，サーバとして動作するマルウェアを前提としている[3]といった問題点があった．</p>
<h1 id="問題定義">問題定義</h1><p>　あるマルウェアのファミリFに属する検体Pを入力として受け取り，Fが用いるC&amp;Cサーバのフィンガープリントφを出力することがAUTOPROBEの目的である．C&amp;Cサーバ側のコードは参照できず，マルウェアの検体はシンボル情報やソースコードを含んでいなくともよい．またマルウェアは複数のリクエストをC&amp;Cサーバに送信するものとする．</p>
<h1 id="提案手法">提案手法</h1><p>　あるサーバにマルウェアと同様のリクエストを送って，マルウェアがコマンドとして解釈できるレスポンスが返ってきたら，そのサーバは疑いようもなくC&amp;Cサーバである—AUTOPROBEの鍵となる発想は至極単純だ．<br>　AUTOPROBEは検体の命令・API・システムコールの実行を—おそらくQEMUによって—トレースし，リクエストを生成する処理とレスポンスをハンドルする処理をそれぞれマルウェアから抽出する．つづいて前者によって不審なサーバに対するリクエストを生成し，後者によってレスポンスをハンドルする．レスポンスハンドリングの可否をもってフィンガープリントとするから，その処理の抽出さえできれば不審なサーバがC&amp;Cサーバかどうか判定するまで実際のC&amp;Cサーバと通信する必要はない—でもどうやって？</p>
<h2 id="リクエスト生成">リクエスト生成</h2><p>　マルウェアの多くは時間や擬似乱数，OS情報などの環境依存の値によって動作を変更する．たとえばWin32/LoadMoney.AFはレジストリキーの有無によって送信するリクエストを変更する．</p>
<p><img src="/image/autoprobe/win32_loadmoney.af.png" width="50%" height="50%"></p>
<p>　不審なサーバがC&amp;Cサーバかどうか判定するためには攻撃者の期待するリクエストをより多く送信しより多くレスポンスを得たい．そこでAUTOPROBEは以下のアルゴリズムにしたがって複数の実行トレースを得る．これは条件分岐の度に直前のシステムコールを参照する，ある種の深さ優先探索として実装される．</p>
<p><img src="/image/autoprobe/request.png" width="50%" height="50%"></p>
<p>　さらにAUTOPROBEはトレースをスライスし，システムコールの結果に依存する値を環境依存の値として決定論的な値・定数と区別する．ここで環境依存の値を書き換えれば攻撃者の期待するリクエストを送信できるようになる．また環境依存の値に影響するシステムコールの戻り値に時間，IPアドレス，擬似乱数，OS情報など200種類のラベルを設定しているとのことだ．</p>
<h2 id="レスポンスハンドリング">レスポンスハンドリング</h2><p>　生成したリクエストをC&amp;Cサーバに送信してレスポンスを得たら，AUTOPROBEはレスポンスの各バイトを記号値として扱い，実行トレースから検体の分岐制約を充足する解およびスライスθ<sub>1</sub>を得る．ここで探索の終了条件は<code>closesocket</code>や<code>exitprocess</code>に到達した場合，データを受信してから50個の条件分岐にわたってそのデータを参照するものが存在しない場合である．つづいてレスポンスとして正しく解釈できない値を検体に与え，実行トレースから分岐制約を充足する解およびスライスθ<sub>2</sub>を得る．ここでηは以下の式によって得られる実行経路の類似度である．</p>
<p><img src="/image/autoprobe/slice.png" width="50%" height="50%"></p>
<p>　bnとfnはそれぞれ各スライスに含まれるユニークなコードブロックとシステムコールの数を示す．AUTOPROBEはηが閾値10を下回ればレスポンスを正しく解釈していない実行経路とみなしてスライスを破棄し，上回れば別々のハンドラであるとしてそれぞれの分岐制約をフィンガープリントとして保持する．たとえばこんなふうに．</p>
<p><img src="/image/autoprobe/equations.png" width="50%" height="50%"></p>
<p>　C&amp;Cサーバからレスポンスを得られなければ，AUTOPROBEは記号的実行とファジング，フラグレジスタの書き換えによる強制実行（forced execution）を併用してレスポンスに依存する実行経路を探索する．</p>
<p><img src="/image/autoprobe/response.png" width="55%" height="55%"></p>
<p>　このファジングでは検体にランダム値を与えるが，検体が用いるアルゴリズムがHTTPなど既知のものであればエラーメッセージのハンドラを起点に探索する．<br>　AUTOPROBEはこのように探索したレスポンスのハンドラをフィンガープリントとするが，期待されるレスポンスが得られずさきほどのアルゴリズムによって探索した場合は以下のようにC&amp;Cサーバの尤もらしさを算出する．</p>
<p><img src="/image/autoprobe/score.png" width="50%" height="50%"></p>
<h1 id="評価">評価</h1><p>　論文ではふたつのデータセットを用いてAUTOPROBEの性能を評価している．ひとつはSality, ZeroAccess, Ramnit, Bamital, Taidoorを含む37ファミリ10亜種計370検体．もうひとつはネットワーク通信の特徴量に基づいてフィンガープリントを生成する既存研究—CYBERPROBE[2]で用いられた19ファミリ． “which have been kindly provided to us by the authors of CYBERPROBE”って書いてるけどAUTOPROBEと同じメンバーじゃねえか．<br>　検体の実行時間は5分．</p>
<h2 id="リクエスト生成-1">リクエスト生成</h2><p>　まずはリクエストの生成から．可能であればC&amp;Cサーバとの接続をともなうがAlexaトップ10,000サイトは除外している．ここでAUTOPROBEはC&amp;Cサーバに接続せずとも検体のバイナリを分析してCYBERPROBEと同様の結果を得ている．</p>
<p><img src="/image/autoprobe/request_eval.png"></p>
<p>　AUTOPROBEはふたつのデータセットに含まれる56ファミリのトレースから105のリクエストを生成した．生成にかかった時間は平均13.2分．リクエストはすべてHTTPであったとのこと．</p>
<h2 id="レスポンスハンドリング-1">レスポンスハンドリング</h2><p>　生成したリクエストのうち76件がC&amp;Cサーバからのレスポンスを引き出した．さらにAUTOPROBEは<code>HTTP 200</code>レスポンスコードを含む同数のランダムなレスポンスを生成し，検体に与えた．これはレスポンスハンドリングの可否によって検体の異なる挙動を確認したいためだ．結果として76件のテストケース中71件（93％）で検体は異なる挙動を示した—<strong>期待される受信データを得たマルウェアは一般に10以上のシステムコールと50以上のコードブロックを実行する</strong>．残りの5件はC&amp;Cサーバではなかった．つまりAUTOPROBEはマルウェアの通信先がC&amp;Cサーバかどうか正しく判定できている．</p>
<h2 id="ケーススタディ">ケーススタディ</h2><p>　たとえばBamitalのリクエストはファイル名・<code>GetVersionEx</code>によって得たOS情報・DGA (domain generation algorithm) によって生成したホスト名を含んでいた．AUTOPROBEはこれらの値が依存するシステムコールを得ている．</p>
<p><img src="/image/autoprobe/bamital.png" width="50%" height="50%"></p>
<p>　C&amp;Cサーバと接続せずとも<code>HTTP/1.1 200 OK</code>を与えればBamitalのハンドラは分析できるとのこと．<br>　また標的型攻撃に用いられるTaidoorのリクエストは<code>GetAdaptersInfo</code>によって得たMACアドレスに依存する値を含んでいた．これによってTaidoorのC&amp;Cサーバは感染端末のみで動作するレスポンスを送信していたようだ．<br>　ドライブバイダウンロード検体であるSalityのC&amp;Cサーバは<code>spm/s_tasks.php</code>, <code>logos_s.gif</code>, <code>231013_d.exe</code>というファイルをレスポンスに含んでいた．AUTOPROBEはこれらのファイルの存在するサーバをSalityのC&amp;Cサーバとみなす．などなど．</p>
<h2 id="限定的な探索">限定的な探索</h2><p>　Malware Domain Listに含まれる9,500アドレスの近傍/24サブネット・2.6Mアドレスのスキャン結果．</p>
<p><img src="/image/autoprobe/localized.png" width="60%" height="60%"></p>
<p>　VirusTotal, Malware Domain List, そしてURLQueryに発見されていないC&amp;Cサーバを特定できている．</p>
<h2 id="インターネット全体の探索">インターネット全体の探索</h2><p>　ここではBGPからインターネット全体をスキャンし，7,100万ものHTTPサーバを発見している．</p>
<p><img src="/image/autoprobe/horizontal.png"></p>
<p>　このうちマルウェア3ファミリのC&amp;Cサーバをどれだけ発見できるかCYBERPROBEと比較した結果．</p>
<p><img src="/image/autoprobe/comparison.png"></p>
<p>　CYBERPROBEが40件のC&amp;Cサーバを特定しているのにたいしてAUTOPROBEは54件のC&amp;Cサーバを特定している．<br>　高度化するマルウェアが通信内容を難読化・秘匿する傾向にあることを鑑みると，CYBERPROBEのようにネットワーク通信の特徴量を用いる手法よりもAUTOPROBEのようにバイナリ解析を応用した手法こそ吟味されるべきだろう．</p>
<h1 id="感想">感想</h1><p>　AUTOPROBEは折しも私が昨年度のインターンシップでほとんど同じようなテーマに取り組んでいたとき発表された．テイント解析のソースを受信データではなくシステムコールの結果に設定することで，リクエストのセマンティクスを復元しようとするAUTOPROBEの発想は野心的であり，さまざまなバイナリ解析技術を結集して未知のC&amp;Cサーバを発見する手際は鮮やかというほかない．<br>　私は来年書くことになる卒業論文のテーマとして，インターネット接続のない閉環境におけるマルウェアの分析に本手法を応用できないか検討している．Ryzhykら[4]はデバイスドライバと環境（デバイスおよびOS）との相互作用を有限オートマトンを用いて表現し，デバイスドライバを半自動的に合成する手法を提案している．問題領域は異なるがこうした手法も検討したい．</p>
<h1 id="用語解説">用語解説</h1><ul>
<li>テイント解析<ul>
<li>任意のデータに設定したタグをルールにしたがって伝搬させることで，データ間の依存関係を分析する手法</li>
</ul>
</li>
<li>プログラムスライシング<ul>
<li>任意のデータに依存する処理部分をプログラムから抽出する手法</li>
</ul>
</li>
<li>記号的実行<ul>
<li>プログラムの分岐条件を充足論理問題とし，制約を充足する解を得る手法</li>
</ul>
</li>
<li>ファジング<ul>
<li>開発者が意図しない入力を自動生成してプログラムに与えることで脆弱性を顕在化させる手法</li>
</ul>
</li>
</ul>
<h1 id="参考文献">参考文献</h1><ul>
<li>[1] Zhaoyan Xu, Antonio Nappa, Robert Baykov, Guangliang Yang, Juan Caballero, and Guofei Gu, “<a href="http://www.cs.wm.edu/~ksun/csci780-f14/papers/AutoProbe-CCS14.pdf" target="_blank" rel="external">AUTOPROBE: Towards Automatic Active Malicious Server Probing Using Dynamic Binary Analysis[PDF]</a>,” In Proc. of the 21st ACM Conference on Computer and Communications Security (CCS’14), 2014.</li>
<li>[2] Antonio Nappa, Zhaoyan Xu, M. Zubair Rafique, Juan Caballero, and Guofei Gu, “<a href="http://faculty.cs.tamu.edu/guofei/paper/CyberProbe_NDSS14.pdf" target="_blank" rel="external">Cyberprobe: Towards Internet-Scale Active Detection of Malicious Servers[PDF]</a>,” In Network and Distributed System Security Symposium (NDSS’14), 2014.</li>
<li>[3] Zhaoyan Xu, Lingfeng Chen, Guofei Gu, and Christopher Kruegel, “<a href="http://dl.acm.org/citation.cfm?id=2382257" target="_blank" rel="external">Peerpress: Utilizing Enemies’ P2P Strength against Them</a>,” In ACM Conference on Computer and Communications Security (CCS’12), 2012.</li>
<li>[4] Leonid Ryzhyk, Adam Walker, John Keys, Alexander Legg, Arun Raghunath, Michael Stumm, and Mona Vij, “<a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/ryzhyk" target="_blank" rel="external">User-Guided Device Driver Synthesis</a>,” In Proc. of the 11th USENIX Conference on Operating Systems Design and Implementation (OSDI’14), 2014.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>　本稿は<a href="http://www.adventar.org/calendars/784" target="_blank" rel="external">情報セキュリティ系論文紹介 Advent Calendar 2015</a>の11日目である．</p>
<h]]>
    </summary>
    
      <category term="symbolic execution" scheme="http://ntddk.github.io/tags/symbolic-execution/"/>
    
      <category term="taint analysis" scheme="http://ntddk.github.io/tags/taint-analysis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[コラッツの問題を用いた難読化は脅威なのか]]></title>
    <link href="http://ntddk.github.io/2015/11/09/is-linear-obfuscation-a-threat/"/>
    <id>http://ntddk.github.io/2015/11/09/is-linear-obfuscation-a-threat/</id>
    <published>2015-11-09T08:30:00.000Z</published>
    <updated>2015-11-09T08:27:51.226Z</updated>
    <content type="html"><![CDATA[<h1 id="TL;DR:">TL;DR:</h1><p>　ソフトウェアの多くは外部からの入力に依存する実行パス（trigger-based code）をもつ．<br>　これを記号的実行（symbolic execution, シンボリック実行）などの解析手法から隠蔽する手法として，コラッツの問題を用いた線型難読化（linear obfuscation）がある[1]．<br>　本稿ではしかし，線型難読化されたコードはコンパイラ最適化によってある程度除去できることを示す．</p>
<h1 id="コラッツの問題">コラッツの問題</h1><p>　コラッツの問題は数論の未解決問題のひとつである．<br>　任意の1でない自然数nに対して，nが偶数ならば2で割り，nが奇数ならば3倍して1を足す．この操作を繰り返していくと，どのような自然数nから出発しても，有限回の操作のうちに必ず1に到達する．<br>　この定理は経験則的に正しいと考えられているが，いまだ証明はなされていない．</p>
<h1 id="線型難読化">線型難読化</h1><p>　たとえば次のプログラム<code>tr.c</code>は外部からの入力に依存する実行パスをもつ．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tr.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=argc;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"triggered!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　LLVM bitcodeレベルでの<code>tr.c</code>の制御フローグラフは次のようになる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># clang -emit-llvm -c -g tr.c&#10;# opt tr.bc -dot-cfg &#62; /dev/null&#10;# dot -Tpng cfg.main.dot &#62; tr.png</span><br></pre></td></tr></table></figure>
<p><img src="/image/tr.png"></p>
<p>　この単純なプログラムにたいして，コラッツの問題にもとづくループを挿入する．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tr2.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = argc;</span><br><span class="line">    <span class="keyword">int</span> y = x + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(y &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            y = <span class="number">3</span> * y + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y = y / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((x - y &gt; <span class="number">0</span>)&amp;&amp;(x + y &lt; <span class="number">4</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"triggered!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　変数<code>y</code>は必ず1に到達する，いわば偽の変数である．<br>　難読化された<code>tr2.c</code>の制御フローグラフは次のようになる．</p>
<p><img src="/image/tr2.png"></p>
<p>　ループが挿入されたことによって実行パスが複雑化していることが見て取れる．</p>
<h1 id="記号的実行">記号的実行</h1><p>　では，線型難読化がどれほど記号的実行にたいして効力をもつか見てみよう．<br>　今回はLLVM bitcodeを扱う記号的実行ツール<a href="klee.github.io">KLEE</a>を用いる．<br>　まず次のコードを解析対象のソースに追記する必要がある．これは，変数<code>x</code>にたいして記号的実行を適用するという意味である．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -3,6 +3,7 @@&#10; int main(int argc, char *argv[])&#10; &#123;&#10;     int x=argc;&#10;+    klee_make_symbolic(&#38;x, sizeof(x), &#34;x&#34;);&#10;     if(x==2)&#10;         printf(&#34;triggered!\n&#34;);</span><br></pre></td></tr></table></figure>
<p>　次に，LLVM bitcodeを生成する．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># clang -emit-llvm -c -g tr.c&#10;tr.c:6:5: warning: implicit declaration of function &#39;klee_make_symbolic&#39; is&#10;      invalid in C99 [-Wimplicit-function-declaration]&#10;    klee_make_symbolic(&#38;x, sizeof(x), &#34;x&#34;);&#10;    ^&#10;1 warning generated.</span><br></pre></td></tr></table></figure>
<p>　警告が出るが，気にしてはいけない．この関数呼び出しがKLEEにトラップされることになるのだ．<br>　ソースコードのないマルウェアなどを分析するにあたっては，IDAなどのデコンパイラでソースを出力し，型情報やシグナルハンドラなどの記述を整えたのち上記のようなコードを挿入するか，あるいはS2EやPANDAといった動的解析環境を頼ることになるだろう．<br>　それはさておき，KLEEを動かしてみよう．少し前までKLEEをビルドして動かすのはとても面倒だったが，いまではDocker Imageが提供されている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo docker pull klee/klee&#10;# sudo docker run --rm -ti klee/klee</span><br></pre></td></tr></table></figure>
<p>　線型難読化をおこなう前の<code>tr.c</code>について記号的実行をおこなった結果を示す．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klee@4d625535c122:~$ time klee tr.bc&#10;KLEE: output directory is &#34;/home/klee/klee-out-1&#34;&#10;KLEE: WARNING: undefined reference to function: printf&#10;KLEE: WARNING ONCE: calling external: printf(39707328)&#10;triggered!&#10;&#10;KLEE: done: total instructions = 17&#10;KLEE: done: completed paths = 2&#10;KLEE: done: generated tests = 2&#10;&#10;real    0m0.032s&#10;user    0m0.009s&#10;sys     0m0.012s</span><br></pre></td></tr></table></figure>
<p>　パスは2つしか存在しないため，32msecで解析が終わっている．<br>　ならば，線型難読化を施した後の<code>tr2.c</code>についてはどうか．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klee@4d625535c122:~$ time klee tr2.bc&#10;KLEE: output directory is &#34;/home/klee/klee-out-2&#34;&#10;KLEE: WARNING: undefined reference to function: printf&#10;KLEE: WARNING ONCE: calling external: printf(49859696)&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;...&#10;&#10;KLEE: done: total instructions = 285809&#10;KLEE: done: completed paths = 158&#10;KLEE: done: generated tests = 158&#10;&#10;real    6m11.933s&#10;user    3m56.240s&#10;sys     2m14.245s</span><br></pre></td></tr></table></figure>
<p>　さきほどに比べ，実行パスは158に増加し，解析に11622.9倍（！）もの時間がかかっている．<br>　今回の単純なプログラムでさえこのようになるならば，複数の入出力に依存する実行パスに線型難読化が施されたらどうなることか．</p>
<h1 id="コンパイラ最適化">コンパイラ最適化</h1><p>　難読化とはえてしてコンパイラ最適化の逆写像である．<br>　KLEEがLLVMにもとづいているということもあって，LLVMの最適化が線型難読化を除去できるかどうか興味をもった．検証してみよう．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># opt -O3 tr2.bc -o tr3.bc</span><br></pre></td></tr></table></figure>
<p>　<code>-O3</code>をもって最適化した後の制御フローグラフは次のようになる．</p>
<p><img src="/image/tr3.png"></p>
<p>　最初の<code>tr.c</code>ほどではないが，いくらか単純になっていることがわかる．<code>printf()</code>も<code>puts()</code>に変換されている．<br>　では，実行パスは減少しているだろうか．記号的実行をおこなった結果は次の通り．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klee@4d625535c122:~$ time klee tr3.bc&#10;KLEE: output directory is &#34;/home/klee/klee-out-4&#34;&#10;KLEE: WARNING: undefined reference to function: puts&#10;KLEE: WARNING ONCE: calling external: puts(32090720)&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;triggered!&#10;&#10;KLEE: done: total instructions = 3383&#10;KLEE: done: completed paths = 10&#10;KLEE: done: generated tests = 10&#10;&#10;real    0m2.845s&#10;user    0m2.490s&#10;sys     0m0.357s</span><br></pre></td></tr></table></figure>
<p>　実行パスは10とさきほどの<code>tr2.c</code>よりも減少している．実行時間は<code>tr.c</code>の88.9倍であった．</p>
<h1 id="おわりに">おわりに</h1><p>　線型難読化は脅威ではないことがわかった—少なくとも提唱者の思惑ほどには．<br>　塵も積もれば山となるように，線型難読化を多数の箇所に施せばその効力は増すだろう．しかしそれはクラスタリングなどの手法で対処される可能性を高めるだけである．もちろん，どれほどの範囲で難読化を適用すれば効果的かという閾値を探ることに価値はある．<br>　LLVMの<code>-O3</code>最適化は複数の最適化パスを組み合わせ，再帰的に適用することによっておこなわれる．どのパスが線型難読化の除去にもっとも寄与しているか調べてみるとおもしろいかもしれない（やる気がない）．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>[1]Zhi Wang, Jiang Ming, Chunfu Jia, Debin Gao, “<a href="http://flyer.sis.smu.edu.sg/esorics11.pdf" target="_blank" rel="external">Linear Obfuscation to Combat Symbolic Execution[PDF]</a>,” Proceedings of the 16th European Conference on Research in Computer Security(ESORICS’11), pp.210-226, 2011.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="TL;DR:">TL;DR:</h1><p>　ソフトウェアの多くは外部からの入力に依存する実行パス（trigger-based code）をもつ．<br>　これを記号的実行（symbolic execution, シンボリック実行）などの解析手法から隠蔽する手法と]]>
    </summary>
    
      <category term="symbolic execution" scheme="http://ntddk.github.io/tags/symbolic-execution/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xenにハイパーコールを追加する]]></title>
    <link href="http://ntddk.github.io/2015/09/14/xen-add-hypercall/"/>
    <id>http://ntddk.github.io/2015/09/14/xen-add-hypercall/</id>
    <published>2015-09-14T13:00:00.000Z</published>
    <updated>2016-07-08T08:52:59.377Z</updated>
    <content type="html"><![CDATA[<h1 id="はじめに">はじめに</h1><p>いわゆるVM床抜きをXenで試す．</p>
<h1 id="Xenのインストール">Xenのインストール</h1><p>いつかインストールしたXen 4.4.1を用いた．</p>
<ul>
<li><p>依存パッケージ</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install wget git bcc bin86 gawk bridge-utils iproute libcurl3 libcurl4-openssl-dev bzip2 module-init-tools pciutils-dev build-essential make gcc libc6-dev libc6-dev-i386 linux-libc-dev zlib1g-dev python python-dev python-twisted python-gevent libncurses5-dev patch libvncserver-dev libssl-dev libsdl-dev iasl libbz2-dev e2fslibs-dev git-core uuid-dev ocaml libx11-dev bison flex ocaml-findlib xz-utils gettext libyajl-dev libpixman-1-dev libaio-dev libfdt-dev cabextract libglib2.0-dev autoconf automake libtool check libjansson-dev libfuse-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>Xenのビルド</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget http://bits.xensource.com/oss-xen/release/4.4.1/xen-4.4.1.tar.gz&#10;# tar xzvf xen-4.4.1.tar.gz&#10;# cd ./xen-4.4.1&#10;# export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu&#10;# ./configure --enable-systemd --enable-githttp&#10;# make -j4 dist-xen&#10;# make -j4 dist-tools</span><br></pre></td></tr></table></figure>
</li>
<li><p>DomUの設定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo su&#10;# make -j4 install-xen&#10;# make -j4 install-tools&#10;# echo &#34;GRUB_CMDLINE_XEN_DEFAULT=\&#34;dom0_mem=4096M,max:4096M dom0_max_vcpus=4 dom0_vcpus_pin=true hap_1gb=false hap_2mb=false\&#34;&#34; &#62;&#62; /etc/default/grub&#10;# echo &#34;/usr/local/lib&#34; &#62; /etc/ld.so.conf.d/xen.conf&#10;# ldconfig&#10;# update-grub&#10;# echo &#34;none /proc/xen xenfs defaults,nofail 0 0&#34; &#62;&#62; /etc/fstab&#10;# echo &#34;xen-evtchn&#34; &#62;&#62; /etc/modules&#10;# echo &#34;xen-privcmd&#34; &#62;&#62; /etc/modules&#10;# update-rc.d xencommons defaults 19 18&#10;# update-rc.d xendomains defaults 21 20&#10;# update-rc.d xen-watchdog defaults 22 23&#10;# reboot</span><br></pre></td></tr></table></figure>
</li>
<li><p>動作確認</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo xen-detect&#10;Running in PV context on Xen v4.4.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ハイパーコールの追加">ハイパーコールの追加</h1><p>予約済みの<code>__HYPERVISOR_xc_reserved_op</code>に代わって39番目のハイパーコールを定義する．</p>
<ul>
<li><p>xen-4.4.1/xen/include/public/xen.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -100,6 +100,7 @@&#10; #define __HYPERVISOR_domctl               36&#10; #define __HYPERVISOR_kexec_op             37&#10; #define __HYPERVISOR_tmem_op              38&#10;+#define __HYPERVISOR_rdtsc_hypercall      39&#10; #define __HYPERVISOR_xc_reserved_op       39 /* reserved for XenClient */&#10;&#10; /* Architecture-specific hypercall definitions. */</span><br></pre></td></tr></table></figure>
</li>
<li><p>xen-4.4.1/xen/arch/x86/x86_64/entry.S</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -757,6 +757,7 @@&#10;         .quad do_domctl&#10;         .quad do_kexec_op&#10;         .quad do_tmem_op&#10;+        .quad do_rdtsc_hypercall&#10;         .rept __HYPERVISOR_arch_0-((.-hypercall_table)/8)&#10;         .quad do_ni_hypercall&#10;         .endr&#10;@@ -805,6 +806,7 @@&#10;         .byte 1 /* do_domctl            */&#10;         .byte 2 /* do_kexec             */&#10;         .byte 1 /* do_tmem_op           */&#10;+        .byte 1 /* do_rdtsc_hypercall   */&#10;         .rept __HYPERVISOR_arch_0-(.-hypercall_args_table)&#10;         .byte 0 /* do_ni_hypercall      */&#10;         .endr</span><br></pre></td></tr></table></figure>
</li>
<li><p>xen-4.4.1/xen/include/asm-x86/hypercall.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -110,4 +110,8 @@&#10; arch_compat_vcpu_op(&#10;     int cmd, struct vcpu *v, XEN_GUEST_HANDLE_PARAM(void) arg);&#10;&#10;+extern int&#10;+do_rdtsc_hypercall(&#10;+    char* str);&#10;+&#10; #endif /* __ASM_X86_HYPERCALL_H__ */</span><br></pre></td></tr></table></figure>
</li>
<li><p>xen-4.4.1/xen/arch/x86/traps.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -3762,6 +3762,14 @@&#10;     __domain_crash_synchronous();&#10; &#125;&#10;&#10;+int do_rdtsc_hypercall(char* str)&#10;+&#123;&#10;+    unsigned long long tsc;&#10;+    __asm__ volatile(&#34;rdtsc&#34; : &#34;=A&#34; (tsc));&#10;+    printk(&#34;str: %s, tsc: %llu\n&#34;, str, tsc);&#10;+    return 0;&#10;+&#125;&#10;+&#10; /*&#10;  * Local variables:&#10;  * mode: C</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>このハイパーコールは引数として受け取った文字列をTSCの値とともにコンソールログに出力する．有効化するには再度<code>make -j4 dist-xen</code>して再起動するとよい．</p>
<h1 id="ハイパーコールの呼び出し">ハイパーコールの呼び出し</h1><p>ハイパーコールの呼び出しはlibxcやlibxlによって抽象化されているが，ここではそれらが内部で参照している/proc/xen/privcmdに対してioctlを発行してみる．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rdtsc_hypercall.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;errno.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/ioctl.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;xenctrl.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;xen/sys/privcmd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"input the param"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *message = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(message, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">privcmd_hypercall_t</span> my_hypercall = &#123;</span><br><span class="line">            <span class="number">39</span>, <span class="comment">// __HYPERVISOR_rdtsc_hypercall</span></span><br><span class="line">            &#123;(__u64)message, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/xen/privcmd"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"cannot open /proc/xen/privcmd"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!ioctl(fd, IOCTL_PRIVCMD_HYPERCALL, &amp;my_hypercall))</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"cannot call do_rdtsc_hypercall"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このプログラムを実行するとハイパーコールが呼び出されたことが分かる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># gcc -o rdtsc_hypercall rdtsc_hypercall.c&#10;# sudo ./rdtsc_hypercall test&#10;# sudo xl dmesg | less&#10;(XEN) str: test, tsc: 2835883086</span><br></pre></td></tr></table></figure>
<h1 id="おわりに">おわりに</h1><p>Xenに追加したハイパーコールを呼び出すことができた．<br>さしあたってはMirage OSからこのハイパーコールを呼び出す方法を知りたいのだが．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>“C77 - paravirt.org - circle,” <a href="http://circle.paravirt.org/c77" target="_blank" rel="external">http://circle.paravirt.org/c77</a></li>
<li>“笑遍世界 &gt;&gt; Xen添加一个hypercall,” <a href="http://smilejay.com/2012/05/xen_hypercall/" target="_blank" rel="external">http://smilejay.com/2012/05/xen_hypercall/</a></li>
<li>“Making a New Hypercall &amp;&amp; Invoking It from userland via Privcmd | Sanity of Fortunate Fool” <a href="http://sanifool.com/2013/02/08/invoking-an-hypercall-from-userland-via-privcmd/" target="_blank" rel="external">http://sanifool.com/2013/02/08/invoking-an-hypercall-from-userland-via-privcmd/</a></li>
<li>“CPUクロックに基づく相対時刻の計測,” <a href="http://www.02.246.ne.jp/~torutk/cxx/clock/cpucounter.html" target="_blank" rel="external">http://www.02.246.ne.jp/~torutk/cxx/clock/cpucounter.html</a></li>
<li>“libxenctrlのメモ - はわわーっ,” <a href="http://yomi322.hateblo.jp/entry/2015/02/19/235522" target="_blank" rel="external">http://yomi322.hateblo.jp/entry/2015/02/19/235522</a></li>
<li>“libxenctrlのメモ #2 - はわわーっ,” <a href="http://yomi322.hateblo.jp/entry/2015/02/20/212853" target="_blank" rel="external">http://yomi322.hateblo.jp/entry/2015/02/20/212853</a></li>
<li>“xenのハイパーコールを呼んでみる - はわわーっ,” <a href="http://yomi322.hateblo.jp/entry/2015/02/21/145334" target="_blank" rel="external">http://yomi322.hateblo.jp/entry/2015/02/21/145334</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="はじめに">はじめに</h1><p>いわゆるVM床抜きをXenで試す．</p>
<h1 id="Xenのインストール">Xenのインストール</h1><p>いつかインストールしたXen 4.4.1を用いた．</p>
<ul>
<li><p>依存パッケージ</p>
]]>
    </summary>
    
      <category term="virtual machine introspection" scheme="http://ntddk.github.io/tags/virtual-machine-introspection/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DECAFによるマルウェア自動解析]]></title>
    <link href="http://ntddk.github.io/2015/08/16/automated-malware-analysis-using-decaf-in-seccamp15/"/>
    <id>http://ntddk.github.io/2015/08/16/automated-malware-analysis-using-decaf-in-seccamp15/</id>
    <published>2015-08-16T09:00:00.000Z</published>
    <updated>2016-07-08T08:53:12.907Z</updated>
    <content type="html"><![CDATA[<h1 id="はじめに">はじめに</h1><p>2015.08.11~15にわたって開催された<a href="https://www.ipa.go.jp/jinzai/camp/2015/zenkoku2015.html" target="_blank" rel="external">セキュリティ・キャンプ全国大会 2015</a>に解析トラックの講師として参加した．講義では「仮想化技術を用いてマルウェア解析」と題して，QEMUをベースに開発が行われている<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="external">DECAF</a>という解析プラットフォームを用いて演習を行った．</p>
<h1 id="講義資料">講義資料</h1><script async class="speakerdeck-embed" data-id="11c7632b9b844e199ac966e4494a1dd2" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<h1 id="講義内容">講義内容</h1><p>演習では実際のマルウェアに用いられている解析妨害機能を備えたサンプルプログラムを扱った．素のDECAFには解析妨害機能への対策が施されていない．そこで，受講者にはDECAFのプラグインを拡張し，対策手法を実装して頂いた．<br>演習で用いたプログラムはGitHub上で公開している．</p>
<ul>
<li>解析妨害機能を備えたサンプルプログラム<ul>
<li><a href="https://github.com/ntddk/blue" target="_blank" rel="external">ntddk/blue</a></li>
</ul>
</li>
<li>DECAFプラグインのひな形<ul>
<li><a href="https://github.com/ntddk/geteip" target="_blank" rel="external">ntddk/geteip</a></li>
</ul>
</li>
</ul>
<p>ひな形にある通り，IsDebuggerPresent()をフックするDECAFプラグインは以下のように書ける．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> DECAF_Handle isdebuggerpresent_handle = DECAF_NULL_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> call_stack[<span class="number">1</span>]; <span class="comment">//paramters and return address</span></span><br><span class="line">        DECAF_Handle hook_handle;</span><br><span class="line">&#125; IsDebuggerP<span class="keyword">resent_hook_context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * BOOL IsDebuggerPresent(VOID);</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_ret</span><span class="params">(<span class="keyword">void</span> *param)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span> *)param;</span><br><span class="line">        hookapi_remove_hook(ctx-&gt;hook_handle);</span><br><span class="line">        DECAF_printf(<span class="string">"EIP = %08x, EAX = %d\n"</span>, cpu_single_env-&gt;eip, cpu_single_env-&gt;regs[R_EAX]);</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_call</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        DECAF_printf(<span class="string">"IsDebuggerPresent "</span>);</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(IsDebuggerP<span class="keyword">resent_hook_context_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!ctx) <span class="keyword">return</span>;</span><br><span class="line">        DECAF_read_mem(NULL, cpu_single_env-&gt;regs[R_ESP], <span class="number">4</span>, ctx-&gt;call_stack);</span><br><span class="line">        ctx-&gt;hook_handle = hookapi_hook_return(ctx-&gt;call_stack[<span class="number">0</span>], IsDebuggerPresent_ret, ctx, <span class="keyword">sizeof</span>(*ctx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">geteip_loadmainmodule_callback</span><span class="params">(VMI_Callback_Params* params)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(params-&gt;cp.name,targetname) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                DECAF_printf(<span class="string">"Process %s you spcecified starts \n"</span>, params-&gt;cp.name);</span><br><span class="line">                target_cr3 = params-&gt;cp.cr3;</span><br><span class="line">                isdebuggerpresent_handle = hookapi_hook_function_byname(<span class="string">"kernel32.dll"</span>, <span class="string">"IsDebuggerPresent"</span>, <span class="number">1</span>, target_cr3, IsDebuggerPresent_call, NULL, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在のプロセスがデバッガのコンテキストで実行されていない場合，IsDebuggerPresent()は0を返す．ここで，IsDebuggerPresent()の戻り値を0にするには，モジュール（この場合はkernel32.dll）から戻る段階でeaxを書き換えてやればよい．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IsDebuggerPresent_ret</span><span class="params">(<span class="keyword">void</span> *param)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        IsDebuggerP<span class="keyword">resent_hook_context_t</span> *ctx = (IsDebuggerP<span class="keyword">resent_hook_context_t</span> *)param;</span><br><span class="line">        hookapi_remove_hook(ctx-&gt;hook_handle);</span><br><span class="line">        cpu_single_env-&gt;regs[R_EAX] = <span class="number">0</span>; <span class="comment">// 追加</span></span><br><span class="line">        DECAF_printf(<span class="string">"EIP = %08x, EAX = %d\n"</span>, cpu_single_env-&gt;eip, cpu_single_env-&gt;regs[R_EAX]);</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このようにDECAFのプラグインを書くことで，ゲストOSに解析用のエージェントを挿入することなくAPIの戻り値を書き換えることができる．<br>APIの引数を書き換えたい場合はモジュールに入る段階でコンテキスト構造体の<code>call_stack[]</code>を書き換えてやればよい．</p>
<h1 id="おわりに">おわりに</h1><p>受講者にサンドボックス開発の楽しさと難しさを実感してもらえたなら，講師として冥利に尽きる．<br>サンプルプログラムには4種類の解析妨害機能を実装しており，APIフックで対処できるのはうち前半2つだけとなっている．限られた演習時間の制約上，3つ目以降の解析妨害機能を回避できた受講者はいなかった．解析トラックリーダーの岩村さんから，受講者の2割がギリギリ解けないような問題を作るようにと仰せつかっていたが，やや意地悪な問題設定だったと思う．<br>なお，今回は拙作のサンプルを用いたが，より多くの解析妨害機能を備えたOSSに<a href="https://github.com/a0rtega/pafish" target="_blank" rel="external">pafish</a>がある．pafishはBackdoor.Win32.Agent.dkbp(MD5: de1af0e97e94859d372be7fcf3a5daa5)など一部のマルウェアに流用されている．</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="はじめに">はじめに</h1><p>2015.08.11~15にわたって開催された<a href="https://www.ipa.go.jp/jinzai/camp/2015/zenkoku2015.html" target="_blank" rel="exte]]>
    </summary>
    
      <category term="dynamic binary translation" scheme="http://ntddk.github.io/tags/dynamic-binary-translation/"/>
    
      <category term="symbolic execution" scheme="http://ntddk.github.io/tags/symbolic-execution/"/>
    
      <category term="taint analysis" scheme="http://ntddk.github.io/tags/taint-analysis/"/>
    
      <category term="virtual machine introspection" scheme="http://ntddk.github.io/tags/virtual-machine-introspection/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[QEMUの動的バイナリ変換におけるボトルネック]]></title>
    <link href="http://ntddk.github.io/2015/07/13/qemu-dbt-bottleneck/"/>
    <id>http://ntddk.github.io/2015/07/13/qemu-dbt-bottleneck/</id>
    <published>2015-07-13T06:00:00.000Z</published>
    <updated>2015-09-15T08:45:05.094Z</updated>
    <content type="html"><![CDATA[<h1 id="はじめに">はじめに</h1><p>QEMUは動的バイナリ変換を用いた完全仮想化式のハイパーバイザである．<br>QEMUは実行対象の命令列を逆アセンブルし，いちど中間表現に変換したうえで，ホストのアーキテクチャの命令列に変換して実行する．これによりQEMUは異なるアーキテクチャのバイナリを実行することができる．<br>しかしQEMUは遅かったため，アクセラレータとしてkqemuが開発された．<br>kqemuはユーザーモードのコードをホストのCPUに実行させる準仮想化ドライバであり，やがてKVMへと変貌を遂げた．さらにKVMはハードウェアによる仮想化支援機能を用いることで，さらなる高速化を実現した．もはやKVMにおいてQEMUはハードウェアのエミュレーションにしか用いられていない．<br>かわいそうなQEMU！<br>しかしQEMUの活躍する場面はいまだ多く残されている．たとえばマルウェア解析で．<br>それでも遅いのは困りものだ．QEMUはどこが遅いのだろうか．<br>ここでは<code>perf</code>を用いてQEMUのボトルネックを<strong>雑に</strong>特定する．</p>
<h1 id="実験">実験</h1><p>今回はARMエミュレーションについて調査した．ホスト・ゲストともOSにはUbuntu 12.04(3.2.0-23-generic)を用いた．<code>perf</code>でQEMUのプロファイリングを行っている間，ゲストではgccを用いてコンパイルを実行した．</p>
<ul>
<li><p>ARM版Ubuntu 12.04のインストール</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install qemu&#10;# wget http://odroid.us/odroid/users/osterluk/qemu-example/qemu-example.tgz&#10;# tar xzf qemu-example.tgz ./zImage&#10;# wget http://releases.linaro.org/12.04/ubuntu/precise-images/developer/linaro-precise-developer-20120426-86.tar.gz&#10;# tar xzf linaro-precise-developer-20120426-86.tar.gz&#10;# qemu-img create -f raw rootfs.img 3G&#10;# mkfs.ext3 rootfs.img&#10;# mkdir mnt&#10;# sudo mount -o loop rootfs.img mnt&#10;# rsync -a binary/boot/filesystem.dir/ mnt/&#10;# sudo umount mnt</span><br></pre></td></tr></table></figure>
</li>
<li><p>QEMUのビルド</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get build-dep qemu&#10;# git clone git://git.qemu-project.org/qemu.git&#10;# cd qemu&#10;# git log | grep &#39;^commit&#39; | head -1 | awk &#39;&#123;print $2&#125;&#39;&#10;6169b60285fe1ff730d840a49527e721bfb30899&#10;# git submodule update --init dtc&#10;# git submodule update --init pixman&#10;# ./configure --extra-ldflags=-pg --target-list=arm-softmmu&#10;# make</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>perf</code>のインストール</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install linux-tools&#10;# sudo echo 0 &#62; /proc/sys/kernel/perf_event_paranoid</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>perf</code>によるプロファイリング</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># perf record -a -g -F100000 qemu/arm-softmmu/qemu-system-arm -M vexpress-a9 -m 512 -kernel zImage -sd rootfs.img -append &#34;root=/dev/mmcblk0 rw physmap.enabled=0 console=ttyAMA0&#34; -monitor stdio&#10;WARNING: Image format was not specified for &#39;../../rootfs.img&#39; and probing guessed raw.&#10;         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.&#10;         Specify the &#39;raw&#39; format explicitly to remove the restrictions.&#10;QEMU 2.3.90 monitor - type &#39;help&#39; for more information&#10;(qemu) audio: Could not init `oss&#39; audio driver&#10;&#10;(qemu) q&#10;[ perf record: Woken up 37 times to write data ]&#10;[ perf record: Captured and wrote 9.465 MB perf.data (~413514 samples) ]&#10;&#10;&#10;Failed to open /tmp/perf-6993.map, continuing without symbols&#10;Failed to open [vmxnet], continuing without symbols&#10;Failed to open [vmci], continuing without symbols&#10;Failed to open [vsock], continuing without symbols&#10;no symbols found in /bin/dash, maybe install a debug package?&#10;no symbols found in /usr/bin/xargs, maybe install a debug package?&#10;no symbols found in /usr/bin/updatedb.mlocate, maybe install a debug package?&#10;no symbols found in /usr/bin/dpkg-query, maybe install a debug package?</span><br></pre></td></tr></table></figure>
</li>
<li><p>Flame Graphsによる可視化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.githubusercontent.com/brendangregg/FlameGraph/master/stackcollapse-perf.pl&#10;# wget https://raw.githubusercontent.com/brendangregg/FlameGraph/master/flamegraph.pl&#10;# perf script&#62; perf_data.txt&#10;# perl stackcollapse-perf.pl perf_data.txt|perl flamegraph.pl --title &#34;Flame Graphs - qemu-system-arm&#34; &#62; flamegraphs-qemu-system-arm.svg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>perf</code>の結果をFlame Graphsを用いて可視化すると下図のようになった．Flame GraphsはUSENIX LISA’2013にて発表された可視化ツールである．</p>
<p><img src="/image/flamegraphs-qemu-system-arm.png"></p>
<p>x軸は時系列，y軸はコールスタックを意味する．横幅が広く上位に位置する関数がボトルネックであるといえる．<br>よってボトルネックは<code>clear_page()</code>すなわちTCGの各関数で発生しているページフォルトである．</p>
<h1 id="おわりに">おわりに</h1><p>ページフォルトだけは勘弁してほしい．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>“perf + Flame Graphs で Linux カーネル内のボトルネックを特定する - ablog,” <a href="http://d.hatena.ne.jp/yohei-a/20150706/1436208007" target="_blank" rel="external">http://d.hatena.ne.jp/yohei-a/20150706/1436208007</a></li>
<li>Brendan Gregg, “<a href="https://www.usenix.org/conference/lisa13/technical-sessions/plenary/gregg" target="_blank" rel="external">Blazing Performance with Flame Graphs</a>,” Proceedings of the 27th Large Installation System Administration Conference, USENIX LISA’13, Washington, D.C., USA, 2013.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="はじめに">はじめに</h1><p>QEMUは動的バイナリ変換を用いた完全仮想化式のハイパーバイザである．<br>QEMUは実行対象の命令列を逆アセンブルし，いちど中間表現に変換したうえで，ホストのアーキテクチャの命令列に変換して実行する．これによりQEMUは異な]]>
    </summary>
    
      <category term="dynamic binary translation" scheme="http://ntddk.github.io/tags/dynamic-binary-translation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[そろそろ『記号と再帰』について一言言っておくか]]></title>
    <link href="http://ntddk.github.io/2015/04/04/semiotics-of-programming/"/>
    <id>http://ntddk.github.io/2015/04/04/semiotics-of-programming/</id>
    <published>2015-04-04T13:34:16.000Z</published>
    <updated>2015-04-10T13:01:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="はじめに">はじめに</h1><p>田中久美子『記号と再帰: 記号論の形式・プログラムの必然』(“Semiotics of Programming,” Cambridge University Press, 2010.)は，プログラミング言語の記号論についての記念碑的な書籍である．かねてよりPeter B. Andersenらによってコンピュータ記号論(computional semiotics)は語られていたものの，プログラミング言語については議論が追い付いていなかった．<br>本書はまず，対応関係が不明瞭であったソシュールの記号論とパースのそれとを，関数型パラダイムとオブジェクト指向パラダイムとの対比をもって整理する．その上で，記号の本質は再帰にある(p.1)として，絵画，プログラミング言語，哲学を横断した考察が展開される．とまあ随分と衒学的な書籍なのだが，それゆえ危うさを孕んでいるようにも思う．ここではあえて，本書の批判とはいかないまでも，いくつかの不満点を提示したい．</p>
<h1 id="汎記号主義">汎記号主義</h1><p>本書は「記号を媒介することなく対象を人間が認識できない」(p.27)とされ，「記号の解釈を記号系の中だけで捉える」(p.26)という汎記号主義を前提としている．この妥当性について考えても埒が明かないので，ひとまずはそういうことにしておこう．</p>
<h1 id="HaskellとJavaによるプログラム例">HaskellとJavaによるプログラム例</h1><p>本書で用いられるプログラミング言語は，HaskellとJavaである．<br>以下はHaskellによる平面上の長方形，楕円，円の面積を計算するプログラムである(p.15)．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data Shape = Rectangle  Double Double&#10;            | Ellipse   Double Double&#10;            | Circle    Double&#10;&#10;area (Rectangle width height) = width * height&#10;area (Ellipse   width height) = pi * width * height / 4.0&#10;area (Circle  radius)       = area (Ellipse (radius * 2.0)(radius *2.0))&#10;&#10;main = let&#10;        r = Rectangle 5.0 8.0&#10;        u = Ellipse   3.0 4.0&#10;        v = Circle    3.0&#10;        ss = [r, u, v]&#10;    in&#10;        for (\s -&#62; putStr(&#34;area: &#34;++show (area s)++&#34;\n&#34;)) ss&#10;&#10;for f [] = do return ()&#10;for f (s:ss) = do &#123; (f s); for f ss&#125;</span><br></pre></td></tr></table></figure>
<p>いきなり不安になってくる．Haskellについてはずぶの素人の私だが，それでもこのような場面では<code>forM</code>や<code>mapM</code>を用いるべきだと知っている．「このfor関数は，次の図2.2のJavaプログラムとの整合性をふまえて定義されている」(p.17)とあるが，首を傾げざるを得ない．なお<code>map</code>はp.141に至るまで登場しない．<br>続いて，同様にJavaによるプログラムが示される(p.18)．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;&#10;    double width, height;&#10;    Shape (double w, double h)&#123; width = w; height = h; &#125;&#10;    public double area () &#123; return width * height; &#125;&#10;&#125;&#10;&#10;class Rectangle extends Shape&#123;&#10;    Rectangle (double w, double h)&#123; super(w, h); &#125;&#10;&#125;&#10;&#10;class Ellipse extends Shape&#123; &#10;    Ellipse (double w, double h)&#123; super(w, h); &#125;&#10;    public double area()&#123; return Math.PI*width*height/4.0; &#125;&#10;&#125;&#10;&#10;class Circle extends Ellipse&#123;&#10;    Circle(double r)&#123; super(r*2.0, r*2.0); &#125;&#10;&#125;&#10;&#10;void run()&#123;&#10;    Rectangle r = new Rectangle(5.0, 8.0);&#10;    Ellipse   u = new Ellipse(3.0, 4.0);&#10;    Circle    v = new Circle(3.0);&#10;&#10;    Shape [] ss = new Shape[]&#123;r, u, v&#125;;&#10;    for (Shape s : ss)&#123; putStr(&#34;area: &#34; + s.area() + &#34;\n&#34;); &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>これらのプログラムは異なるパラダイム，異なる記法によって書かれているが，しかし同じ出力を得ることができる．ここに本書は，ソシュール二元論とパース三元論を託つける．</p>
<h1 id="ソシュール二元論とパース三元論">ソシュール二元論とパース三元論</h1><p>ソシュールとパースはそれぞれ記号について以下のように整理した．</p>
<ul>
<li>ソシュール二元論</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">シニフィアン</th>
<th style="text-align:center">シニフィエ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“tree”</td>
<td style="text-align:center">木</td>
</tr>
<tr>
<td style="text-align:center">ラベル</td>
<td style="text-align:center">内容</td>
</tr>
</tbody>
</table>
<ul>
<li>パース三元論</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">表意体</th>
<th style="text-align:center">解釈項</th>
<th style="text-align:center">対象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“tree”</td>
<td style="text-align:center">木の解釈</td>
<td style="text-align:center">木</td>
</tr>
<tr>
<td style="text-align:center">ラベル</td>
<td style="text-align:center">イデア</td>
<td style="text-align:center">対象</td>
</tr>
</tbody>
</table>
<p>この対応について，本書は，パース「記号は人に働きかけ，人の心の中に等価な記号を作り出し，あるいはより発展した記号を作り出す．もとの記号が作り出すこの記号のことを私は解釈項と呼ぶ」を根拠に(p.40)，「解釈項は記号の解釈を呼び，記号過程を生成するもので」あり「これに対応するものがソシュールの記号モデルの中にあるならば，それはシニフィエ以外にありえない」(p.41)と導く．<br>続いて，「記号の差異は他の記号と対比されてはじめて立ち現れるものである．とすると，記号の解釈にまつわる記号の使用はソシュールの記号モデルの構成要素には含まれてはいなが，全体論的価値として位置付けられていると考えることができる」(p.41)ことから，「ソシュールのシニフィエはパースの直接対象に対応し，そしてパースの解釈項はソシュールの記号モデルに外在する全体論的価値に内包される」(pp.41-42)という仮説を提示する．</p>
<h1 id="全体論的価値">全体論的価値</h1><p>関数型パラダイムとオブジェクト指向パラダイムの比較を通じて仮説を検証する前に，この「全体論的価値」とは何を意味するのだろうか．おそらくは意図的なのだろうが，本書にはパロールやラング，レフェランといった語が一切登場しない．これによって混乱してしまったのは私だけだろうか．記号論についてもずぶの素人である私の苦し紛れの解釈では「全体論的価値」はラングに相当するが，詳細は述べられていない．ソシュールの「言語記号は恣意的です」という原理も後に登場する(p.57)が，社会的慣習と全体論的価値が絡められることはなかった．</p>
<h1 id="ソシュール二元論とパース三元論の接続">ソシュール二元論とパース三元論の接続</h1><p>さて，ソシュールとパースの関係は，先に挙げたプログラム例の<code>area</code>関数のあり方によって整理される．</p>
<table>
<thead>
<tr>
<th style="text-align:center">プログラミング言語</th>
<th style="text-align:center">Haskell</th>
<th style="text-align:center">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">記号論</td>
<td style="text-align:center">二元論</td>
<td style="text-align:center">三元論</td>
</tr>
<tr>
<td style="text-align:center">area関数</td>
<td style="text-align:center">外在的</td>
<td style="text-align:center">内在的</td>
</tr>
</tbody>
</table>
<p>Haskellのプログラム例では，<code>area</code>は他のデータ構造に<strong>外在する</strong>が，Javaのプログラム例では<strong>内在する</strong>(p.42)．言い換えれば，Haskellにおいては記号がその使用によって意味付けられるが，Javaにおいては記号の定義がその使用を内在する．つまり，次のような対応関係になる(p.49)．</p>
<ul>
<li>ソシュールのシニフィアンはパースの表意体に対応する．</li>
<li>ソシュールのシニフィエはパースの直接対象に相当する（心的な対象）．</li>
<li>パースの解釈項は識別子の使用に相当する．パースの記号モデルでは，記号の使用は解釈項として記号モデルの中に埋め込まれ，記号過程は解釈項を次々と呼ぶことによって生成される．ソシュールにおいては，記号過程は記号が別の記号に呼ばれ，それがまた別の記号に呼ばれることにより生成される．ある記号の使用によって記号に付される価値は記号モデルに外在し，それは記号を併置した際の差異として現れる．</li>
</ul>
<p>こうして，ソシュールとパースの論が接続された．なるほど綺麗にまとまったかのように思える．</p>
<h1 id="プログラミングパラダイム">プログラミングパラダイム</h1><p>しかし，これはプログラミングパラダイムから見て妥当だろうか．HaskellやJavaに固有の特徴と，パラダイムの特徴を同一視していないだろうか．本書において，HaskellやJavaを選択した基準は最後まで明確に示されない（私はJavaScriptが良いのではないかと思った）．<br>CTMCPこと『コンピュータプログラミングの概念・技法・モデル』(“Concepts, Techniques, and Models of Computer Programming, “ The MIT Press, 2004.)のPeter Van-Royによると，オブジェクト指向パラダイムとは関数型パラダイムに状態(state)を追加したものである．私はこの考えに沿った展開に期待していたのだが，しかし状態の概念はp.190に至るまでほとんどといって触れられず，HaskellとJavaの比較に絡められることはなかった．<br>オブジェクト指向すなわちカプセル化という前提に立っているところ，プロトタイプベースのオブジェクト指向について触れていないところも勿体無い．</p>
<h1 id="モナドと状態">モナドと状態</h1><p>状態の概念は，「インタラクションを参照透明に記述しようと思うと，」「莫大な量の記号を使い捨てなければならない」(pp.198-199)からこそモナドが考案されたという流れで援用される．すなわち，参照透明性を保ちつつ状態を記述するためにモナドがある(p.196)．失敗系モナドが無視されているにせよ，このあたりの説明が明快なだけに，HaskellとJavaの比較において状態の概念が持ち出されなかったことが残念に思われる．</p>
<h1 id="参照の値渡し">参照の値渡し</h1><p>本書はJavaを「関数に値とアドレスのどちらかを渡すのかは，再び文脈により実用論的に決まり，」「プログラマが定義して導入する複合型」は「アドレスを渡す」ものとして紹介している(p.117)．これは端的に誤りである．なぜなら，Javaはあらゆる場面において値渡しであり，参照は参照の値(reference values)として扱われるためである．</p>
<h1 id="おわりに">おわりに</h1><p>主にプログラミングの観点から，『記号と再帰』に見られる不満点を述べた．要約すると次のようになる．</p>
<ul>
<li>Haskellのコードが微妙</li>
<li>全体論的価値の定義が不明瞭</li>
<li>HaskellとJavaを題材に選んだ根拠が不明瞭</li>
<li>Javaの参照の値渡しについての説明が不適切</li>
</ul>
<p>だからといって私は本書が駄本であると切り捨てたいわけではない．<br>シニフィアンを持たない状態で分節されたλ項にシニフィアンが付与されていく簡約の過程は大変面白かったし，再帰から是態（交換不可能性？）が立ち上るという考えも論証不足ながら興味深かった．<br>汎記号主義という極端な見地から，記号が投機的に記号系に導入されるからこそ再帰が成立すると言い切ることで，ここまで手際よく語ることができるのかという興奮があった．<br>だからこそ，（今後本書が重版されることがあればの話だが）今回述べたような不満点が解消されることを望む．<br>終盤に本書は，「何ら形式的な制約なく自然に作られた」自然言語の構造的な系と，「停止性が保証される最小の記号群からはじめ，停止性の制約下でボトムアップに構築される」プログラミング言語の構成的な系とを対比している(p.183)．再帰による是態の獲得．構造的な系．次に語られるのはニューラルネットの記号論だろうか．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>“Classification of the principal programming paradigms,” <a href="https://www.info.ucl.ac.be/~pvr/paradigms" target="_blank" rel="external">https://www.info.ucl.ac.be/~pvr/paradigms</a></li>
<li>“幻想再帰のアリュージョニスト,” <a href="http://ncode.syosetu.com/n9073ca/" target="_blank" rel="external">http://ncode.syosetu.com/n9073ca/</a></li>
<li>“EnJoe140で短編中さんはTwitterを使っています: 【記号と再帰―記号論の形式・プログラムの必然】止めて差し上げた方が良いのではないか。 <a href="http://book.akahoshitakuya.com/cmt/8818094" target="_blank" rel="external">http://book.akahoshitakuya.com/cmt/8818094</a> #bookmeter,” <a href="https://twitter.com/EnJoeToh/status/13886544494460928" target="_blank" rel="external">https://twitter.com/EnJoeToh/status/13886544494460928</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="はじめに">はじめに</h1><p>田中久美子『記号と再帰: 記号論の形式・プログラムの必然』(“Semiotics of Programming,” Cambridge University Press, 2010.)は，プログラミング言語の記号論についての記念]]>
    </summary>
    
      <category term="computational semiotics" scheme="http://ntddk.github.io/tags/computational-semiotics/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PinからPEMUへ]]></title>
    <link href="http://ntddk.github.io/2015/04/03/pin-to-pemu/"/>
    <id>http://ntddk.github.io/2015/04/03/pin-to-pemu/</id>
    <published>2015-04-03T11:45:00.000Z</published>
    <updated>2016-07-08T08:53:51.909Z</updated>
    <content type="html"><![CDATA[<h1 id="Dynamic_Binary_Instrumentation">Dynamic Binary Instrumentation</h1><p>Dynamic Binary Instrumentation(DBI)とは，実行中のプログラムにコードを挿入する技術である．<br>その目的は，プログラムの性能評価であったり，アーキテクチャのシミュレーションであったり，プログラムのデバッグであったり，プログラムのsheparding（ポリシを用いたセキュリティ制限）であったり，プログラムの最適化であったり，テイント解析などのデータフロー解析であったり，リバースエンジニアリングであったり，マルウェア解析であったり，……と多岐にわたっている．<br>デバッガとDBIを区別することは難しく，ニュアンスの問題になってしまうが，DBIはより「挿入するコードがプログラマブルであること」を重視している．また，instrumentation（名詞）/instrument（動詞）という語は，コードの挿入を通してプログラムの情報を取得したり，プログラムを制御したりといったニュアンスを含んでいる．<br>DBIのメリットとして，言語に依存しないこと，古いソフトウェアに対しても適用できること，再コンパイルの必要がないこと，動的に生成されるコードを扱うことができること，実行中のプロセスにアタッチできることが挙げられる．</p>
<h1 id="Pin">Pin</h1><p>Intelによって開発されている<a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool" target="_blank" rel="external">Pin</a>は，DBIフレームワークの中でも最も成功している一つであり，そのAPIの数は450種類を越える．<br>Pinにおけるinstrumentationの手法は，コードの実行時にinstrumentするjust-in-time Instrumentation(JITI)と，イメージ（実行ファイルや共有ライブラリ，構造体）のロード時にinstrumentするahead-of-time-insturumentation(AOTI)の二種類に大別される．<br>これらのinstrumentにあたって，Pinは解析対象のプログラムにpinvm.dllを挿入する．</p>
<h2 id="JITI">JITI</h2><p>JIITは以下の三種類を単位として行うことができる．</p>
<h3 id="Instruction_Level">Instruction Level</h3><p>第一に，最も低い粒度として，命令単位のinstrumentationがサポートされている．<br>これは，<code>INS_AddInstrumentFunction</code>のコールバックとして実現される．関連するAPIは，Pin 2.1.3の時点で142種類存在する．</p>
<h3 id="Basic_Block_Level(BBL)">Basic Block Level(BBL)</h3><p>第二に，Basic Block(BB)単位のinstrumentationがサポートされている．<br>ここでのBBとは，一つの入口と一つの出口を持ち，内部に分岐を含まない命令列のことであり，コンパイラ最適化におけるそれと同義である．Pinでは，<code>BBL_InsHead</code>や<code>BBL_InsTail</code>，<code>BBL_Next</code>や<code>BBL_Prev</code>といった関数を用いてBBの有向グラフを操作することができる．一方で<code>BBL_AddInstrumentationFunction</code>のコールバックは<strong>存在しない</strong>．関連するAPIは，Pin 2.1.3の時点で14種類存在する．</p>
<h3 id="Trace_Level">Trace Level</h3><p>第三に，Trace単位のinstrumentationがサポートされている．<br>Traceとは，Pin独自の単位であり，分岐命令を入り口とし，無条件分岐（<code>jmp</code>, <code>call</code>, <code>ret</code>など）を出口とする命令列のことである．つまり，Traceは<strong>複数のBBを含みうる</strong>．これは，<code>TRACE_AddInstrumentFunction</code>のコールバックとして実現される．関連するAPIは，Pin 2.1.3の時点で14種類存在する．<br>Pinでは，objdumpなどと同様に線型分析法によってバイナリを逆アセンブルし，Traceを取得する．ここで，JITIに用いるVMをトラップすることなく別のTraceに分岐を行うための<a href="http://www.cs.virginia.edu/kim/courses/cs851/papers/luk05pin.pdf" target="_blank" rel="external">trace-linking optimization[PDF]</a>が行われる．そのため，Trace単位のinstrumentationが命令単位のinstrumentationよりも高速になる場合がある．</p>
<h2 id="AOTI">AOTI</h2><p>AOTIは以下の二種類を単位として行うことができる．</p>
<h3 id="IMG_instrumentation">IMG instrumentation</h3><p>第一に，IMG単位のinstrumentationがサポートされている．<br>IMGは，特定の実行ファイルないし共有ライブラリ，構造体に相当する単位である．これは，<code>IMG_AddInstrumentFunction</code> APIによって実現される．また，IMGのセクション(SEC)についてもinstrumentを行うことができる．関連するAPIは，IMGについて27種類，SECについて16種類が存在する．</p>
<h3 id="RTN_instrumentation">RTN instrumentation</h3><p>第二に，RTN単位のinstrumentationがサポートされている．<br>RTNとは関数(Routine)に相当する単位である．これは，<code>RTN_AddInstrumentFunction</code> APIによって実現される．関連するAPIは，Pin 2.1.3の時点で39種類存在する．</p>
<h2 id="Transparency">Transparency</h2><p>このように様々な機能を備えるPinだが，マルウェア解析においてはどれほど有用なのだろうか．<br>Pinのinstrumentationは，素朴なDLLインジェクションによって成り立っており，Anti-Debuggingについては考えられていない．そのためPinは，親プロセス，引数，ロードされるpinvm.dll, エクスポート関数である<code>CharmVersionC</code>, <code>ZwAllocateVirtualMemory</code>の実行権限，<code>KiUserApcDispatcher</code>, <code>KiUserCallbackDispatcher</code>, <code>KiUserExceptionDispatcher</code>, <code>LdrInitializeThunk</code>のインラインフック，命令のパターン，セクション名，<code>FSTENV</code>命令，<code>FSAVE</code>命令，<code>FXSAVE</code>命令，……といった様々な要素から検出される危険性を孕んでいる．<br>これらは，<a href="http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=view&amp;type=tool&amp;name=eXait" target="_blank" rel="external">eXait</a>を用いてテストできる．なお，筆者の環境では<code>int2e</code>/<code>SYSENTER</code>についてfalse positiveが発生した．<br>Pinを検出するマルウェアの存在は寡聞にして知らないが，Pinをマルウェア解析に用いるのであれば，現状の構造は不適切である．<br>Anti-Debuggingのイタチごっこから脱するためには，エージェントをゲストOSに挿入するin-VMではなく，エージェントをゲストOSに挿入しないout-of-VMな解析環境でなければならない．</p>
<h1 id="QEMU">QEMU</h1><p>さらにPinにはカーネルへのinstrumentationが不可能であるという欠点が存在する．<br>翻って<a href="https://github.com/qemu/qemu" target="_blank" rel="external">QEMU</a>は，フルシステムエミュレーションを行うため，アーキテクチャに依存することなくカーネルへのinstrumentationを行うことができる．しかしながら，QEMUのソースコードは難解であり，PinのようにユーザーフレンドリーなAPIが提供されていない．QEMUはC言語によるメタプログラミングとオブジェクト指向の良質なサンプルであるとも言えるが，できることなら避けて通りたい道である．</p>
<h1 id="TEMU">TEMU</h1><p>QEMUにテイント解析機能を搭載し，これまで多くの研究で用いられてきた<a href="http://bitblaze.cs.berkeley.edu/temu.html" target="_blank" rel="external">TEMU</a>は，QEMUのソースコードを理解するための労力を削減することに成功した（と，後述するPEMUの論文にすら書かれている）が，APIの充実度はPinに劣っている．また，カーネルモジュールをゲストOSに挿入する必要があり，マルウェアから検出される可能性があること，いまや時代遅れのQEMU 0.9.1をベースとしていることから，現代的なマルウェア解析環境の候補からは外れつつある．<br>後継の<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="external">DECAF</a>はQEMU 1.0.0をベースとしており，カーネルモジュールを必要としないものの，APIの充実度はTEMUと変わらない．</p>
<h1 id="PEMU">PEMU</h1><p>こうした流れを汲んで開発されたのが，VEE’15にて新たに発表された<a href="https://github.com/utds3lab/pemu" target="_blank" rel="external">PEMU</a>である．嬉しい事にオープンソースとして提供されている．<br>Pinはin-VMであり，マルウェアの解析やカーネルへのinstrumentationに適さない．QEMUやTEMUはout-of-VMだが，Pinほど充実したAPIを用いることができない．そこでPEMUは，両者の利点と欠点を踏まえた上で，以下の四点を目的として開発された．</p>
<ol>
<li>Rich APIs<ul>
<li>Pinの既存APIをそのまま流用できること</li>
</ul>
</li>
<li>Cross-OS<ul>
<li>WindowsとLinuxをサポート</li>
</ul>
</li>
<li>Strong Isolation<ul>
<li>ゲストOSのRing 3やRing 0ではなく，out-of-VM(Ring -1)から監視(VM Introspection)を行うこと</li>
</ul>
</li>
<li>VM Introspection<ul>
<li>ゲストOSのプロセスやカーネルのセマンティクス情報を取得するAPIを提供すること</li>
</ul>
</li>
</ol>
<p>これらを達成するため，PEMUはQEMUの動的バイナリ変換器Tiny Code Generator(TCG)に手を加えてPin APIのサポートを追加した．</p>
<h2 id="Instrumentation_Engine">Instrumentation Engine</h2><p>さて，PEMUにおけるinstrumentationはどのようになっているのだろうか．<br>問題となるのは，QEMUとPinとの差異である．QEMUは命令とBB単位でしかinstrumentできず，PinにおけるTrace単位をサポートしていない．また，PEMUのベースとなっているQEMU 1.5.3では，BBの数が640までと制限されている．<br>そこで，PEMUではBBとTraceを対応付けるTRACE Constructorと，PinのAPIを通じてinstrumentするCode Injectorが導入された．</p>
<h3 id="TRACE_Constructor">TRACE Constructor</h3><p>TRACE Constructorは，複数のBBを組み合わせてTraceの単位に抽象化するものである．<br>まずXED2ライブラリを用いて，ゲストの実行前にQEMUでBBの先頭から条件分岐命令まで逆アセンブルを行う(<code>/target-i386/PEMU/DISAS.c</code>)．スワップされたか，ロードされていない命令については，ページフォルトを通じて取得する．さらに，コードを挿入する命令の位置をglobal hooking point hash-table(HPHT)にキャッシュする(<code>/target-i386/PEMU/hashTable.c</code>)．<br>ここにおけるアルゴリズムは以下のようになっている．</p>
<p><img src="/image/pemu_algorithm.png"></p>
<p>まず，Trace単位の開始アドレスであるPCの度にXED2を呼び出し，PCをTPCという保存領域に保存する．次に，全命令を逆アセンブルし，命令単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．さらに，無条件分岐の度にBBとTraceを対応付け，BB単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．そして，新しいBBを割り当て，次のTrace単位が始まるアドレスを探す．Trace単位のinstrumentationが必要な場合はそのアドレスをHPHTに保存する．そして，さらなるTraceを逆アセンブルしていくといった仕組みになる．</p>
<h3 id="Code_Injector">Code Injector</h3><p>TraceとBBの対応が取れた後は，QEMUのTCGが提供する<code>tcg_gen_helper</code>を用いてHPHTを参照し，instrumentを行えばよい（<code>/target-i386/PEMU/pemu_hook_helper.c</code>）．<br>IMGやSEC単位のinstrumentは<code>malloc</code>などの引数を確認する（セマンティクス情報を復元する）ことで実現している．<br>全体像は以下のようになる．</p>
<p><img src="/image/pemu_engine.png"></p>
<h2 id="Introspection_Engine">Introspection Engine</h2><p>PEMUでは，Page Global Directory(PGD)とCR3レジスタの対応を用いてプロセスの識別を行う(<code>target-i386/PEMU/pemu_helper.h</code>)．ここでは，プロセス作成時に発生するCR3レジスタへの<code>MOV</code>を検出して利用する．終了したプロセスのCR3は再利用されるため，プロセスの終了を検出する必要があるが，これは<code>exit</code> syscallを監視することで実現できる．スレッドは，kernel stack pointerのマスクから識別する．<br>ゲストとのセマンティックギャップの解決にあたっては，一時的にゲストを停止してシステムコールを挿入する手法を用いる．<code>PEMU_</code>というprefixでsyscallに相当するAPIが提供され，<code>getpid</code>, <code>gettimeofday</code>などゲストOSの情報を取得するためのAPI 28種類と，<code>open</code>, <code>fstat</code>, <code>lseek</code>などゲストOSを操作するためのAPI 15種を用いることができる．これらは都度レジスタコンテキストの退避と復元を伴って実行される．</p>
<h2 id="評価">評価</h2><p>論文での性能評価では，32-bit Ubuntu 12.04(Linux kernel 3.0.0-31-generic-pae)をホストとし，Intel Core i7, メモリ8GBのマシンが用いられた．速度の評価には32-bit Ubuntu 11.04(Linux kernel 2.6.38-8-generic)がゲストとして用いられた．<br>その結果として，PEMUではQEMUよりも4.33倍，Pinよりも83.61倍のオーバーヘッドが生じることが明らかになっている．</p>
<p><img src="/image/pemu_performance.png"></p>
<p>また，eXaitを用いた検出テストのため，Windows XP 32bitがゲストとして用いられた．論文ではeXaitの17手法全てがPinを検出した一方で，いずれの手法もPEMUを検出することができなかった．</p>
<h2 id="関連研究">関連研究</h2><p>PEMUがQEMUにPin APIのサポートを追加したのに対して，<a href="http://dl.acm.org/citation.cfm?id=1254830" target="_blank" rel="external">PinOS</a>はXenにPin APIのサポートを追加した．だがPinOSのinstrumentationは貧弱であり，セマンティクス情報を取得するAPIが提供されていない．また，解析ルーチンがカーネルや解析対象からアクセスできるため，isolationとして不十分である．<br>また，PinOS以外にカーネルへのinstrumentationをサポートしている<a href="https://github.com/DynamoRIO/drk" target="_blank" rel="external">DRK</a>は，LKMとして実装されているため，in-VMな手法に留まっている．</p>
<h1 id="おわりに">おわりに</h1><p>こうして，Pin APIを用いてout-of-VMにマルウェアを解析するための道標が示された．<br>今後のPEMUを用いた研究に期待したい，と他人事のように言っている場合ではなく，そろそろ論文を書かなければ．</p>
<h1 id="補足">補足</h1><p>PEMUは新しいといえどQEMU 1.5.3をベースとしており，やがてはQEMU 0.9.1をベースとしているTEMUのように技術的負債となるだろう．<br>そこで，PEMUを<a href="https://github.com/ntddk/pemu" target="_blank" rel="external">forkし</a>，<a href="https://github.com/ntddk/pemu/commit/af5bf0b7a3efcbb7c4b21abbfba0da02f034f95a" target="_blank" rel="external">QEMU 1.5.3からQEMU 2.2.1にアップデートを試みた</a>．が，QEMU 2.2.1に至るまで<code>cpu_single_env</code>変数が廃止されたことと，謎のコンパイルエラーが発生することから頓挫中である．そのうち何とかする．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi and Kim Hazelwood,<br>“<a href="http://www.cs.virginia.edu/kim/courses/cs851/papers/luk05pin.pdf" target="_blank" rel="external">Pin: building customized program analysis tools with dynamic instrumentation[PDF]</a>,”<br>In Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation, PLDI’05, pp. 190–200, 2005.</li>
<li>Francisco Falcón, Nahuel Riva,<br>“<a href="http://recon.cx/2012/schedule/events/216.en.html" target="_blank" rel="external">Dynamic Binary Instrumentation Frameworks: I know you’re there spying on me</a>,”<br>RECon 2012.</li>
<li>Junyuan Zeng, Yangchun Fu, and Zhiqiang Lin,<br>“<a href="http://dl.acm.org/citation.cfm?id=2731201" target="_blank" rel="external">PEMU: A Pin Highly Compatible Out-of-VM Dynamic Binary Instrumentation Framework</a>,”<br>In Proceedings of the 11th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments, pp. 147-160, VEE’15, 2015.</li>
<li>Prashanth P. Bungale, Chi-Keung Luk,<br>“<a href="http://dl.acm.org/citation.cfm?id=1254830" target="_blank" rel="external">PinOS: a programmable framework for whole-system dynamic instrumentation</a>,”<br>In Proceedings of the 3rd international conference on Virtual execution environments, VEE’07, pp. 137-147, 2007.</li>
<li>Peter Feiner, Angela Demke, and Ashvin Goel,<br>“<a href="http://dl.acm.org/citation.cfm?id=2150992" target="_blank" rel="external">Comprehensive Kernel Instrumentation via Dynamic Binary Translation</a>,”<br>In Proceedings of the 17th international conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS’12, pp. 135-146, 2012.</li>
<li>Yangchun Fu, Junyuan Zeng, and Zhiqiang Lin,<br>“<a href="https://www.usenix.org/conference/atc14/technical-sessions/presentation/fu" target="_blank" rel="external">HYPERSHELL: A Practical Hypervisor Layer Guest OS Shell for Automated In-VM Management</a>,”<br>In Proceedings of the 2014 USENIX conference on USENIX Annual Technical Conference, USENIX ATC’14, pp. 85-96, 2014.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Dynamic_Binary_Instrumentation">Dynamic Binary Instrumentation</h1><p>Dynamic Binary Instrumentation(DBI)とは，実行中のプログラムにコードを挿入する技術である．]]>
    </summary>
    
      <category term="dynamic binary translation" scheme="http://ntddk.github.io/tags/dynamic-binary-translation/"/>
    
      <category term="taint analysis" scheme="http://ntddk.github.io/tags/taint-analysis/"/>
    
      <category term="virtual machine introspection" scheme="http://ntddk.github.io/tags/virtual-machine-introspection/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[続・サンドボックスの透明性]]></title>
    <link href="http://ntddk.github.io/2015/03/14/sandbox-transparency-in-the-wild/"/>
    <id>http://ntddk.github.io/2015/03/14/sandbox-transparency-in-the-wild/</id>
    <published>2015-03-14T12:00:00.000Z</published>
    <updated>2016-07-08T08:54:08.236Z</updated>
    <content type="html"><![CDATA[<h1 id="耐解析機能の分類">耐解析機能の分類</h1><p><a href="https://twitter.com/gabrielnb" target="_blank" rel="external">Gabriel N. Barbosa</a>と<a href="https://twitter.com/BSDaemon" target="_blank" rel="external">Rodrigo R. Branco</a>は，マルウェアの耐解析機能を<strong>Anti-Debugging, Anti-Disassembly, Obfuscation, Anti-VM</strong>の四種類に分類した．彼らはIntelのセキュリティ研究者であり，マルウェアに備わった耐解析機能の統計を過去二回に渡って発信してきた．<br>気になるのは，サンドボックスの実装にあたって問題となるAnti-VMだ．8,103,167もの検体を用いた調査によると，その内訳は以下のようになっている．</p>
<p><img src="/image/anti-vm.jpg" title="" prevalent="" characteristics="" in="" modern="" malware"より"=""></p>
<p>これらはいずれもVMware社製品を検出するための手法である．残念ながら他の仮想マシンモニタについての情報は掲載されて<strong>いない</strong>．</p>
<h1 id="仮想マシンモニタの分類">仮想マシンモニタの分類</h1><p><a href="http://ntddk.github.io/2015/01/23/sandbox-transparency/">以前にも少しばかり述べた</a>，サンドボックスの透明性(transparency)に関する話を蒸し返そう．<br>サンドボックスにOut-of-the-boxなVMIを採用すれば，少なくともAnti-Debuggingについては無視できる．<br>では，サンドボックスにXenを用いれば，QEMUより検出されにくくなるだろうか．あるいは，その逆はどうだろうか．<br>多くの研究者が好き勝手なことを言っているが，仮想マシンモニタの実現手法をもってサンドボックスの透明性を語るのは些か性急だろう．なぜなら，サンドボックスの透明性はその設計ではなくマルウェアの実装によって左右されるからだ．<strong>Out-of-the-box VMIは設計の話だが，Anti-VMは実装の話だ</strong>（と思う）．<br>ところで私は，仮想マシンモニタの実現手法を「プロセッサ拡張によるもの」と「バイナリ変換によるもの」に分類していたが，別の分類方法を見つけた．</p>
<p><img src="/image/vm-class.png" title="" a="" survey="" of="" security="" issues="" in="" hardware="" virtualization"より"=""></p>
<p>命令セットアーキテクチャを基準に分類することで，より分かりやすくなっている．今後はこの図に準拠したい．<br>話を戻そう．<br>何が言いたいのかというと，in-the-wildなマルウェアに備わったAnti-VMの内訳が分からないことには，サンドボックスの透明性について云々することはできないということだ．</p>
<h1 id="検体">検体</h1><p>誰もやっていないようなので，調べてみることにした．<br>やや恣意的（誤用？）な選択だが，今回は<a href="http://virusshare.com/" target="_blank" rel="external">VirusShare.com</a>からCitadelのバリアント479検体や，Mandiantの<a href="http://intelreport.mandiant.com/Mandiant_APT1_Report.pdf" target="_blank" rel="external">APT1レポート</a>にて報告された中国軍総参謀部第三部第二局こと61398部隊<strong>と思しき</strong>グループ製の874検体を含む<strong>総計33,260検体</strong>を用いた．</p>
<h1 id="Anti-VMの実態">Anti-VMの実態</h1><p><a href="http://plusvic.github.io/yara/" target="_blank" rel="external">YARA</a>を用いてAnti-VMの実態を調べた．<br>ルールには公式の<a href="http://yararules.com/rules/antidebug.yar" target="_blank" rel="external">antidebug.yar</a>を用いた．なお，このルールにはAnti-VMのみならずAnti-Debuggerについても記載されている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># awk &#39;&#123; print $1&#125;&#39; yara.log | sort | uniq -c | sort -r&#10;  20340 DebuggerPattern__RDTSC&#10;  18966 DebuggerPattern__CPUID&#10;   9292 DebuggerTiming__Ticks&#10;   7371 DebuggerPattern__SEH_Inits&#10;   6955 DebuggerException__UnhandledFilter&#10;   5715 DebuggerTiming__PerformanceCounter&#10;   4377 DebuggerPattern__SEH_Saves&#10;   2949 DebuggerCheck__API&#10;   2631 DebuggerCheck__QueryInfo&#10;   2182 SEH__vba&#10;   1315 DebuggerOutput__String&#10;    887 ThreadControl__Context&#10;    604 vmdetect&#10;    303 DebuggerException__SetConsoleCtrl&#10;    186 SEH__vectored&#10;     83 DebuggerHiding__Thread&#10;     80 DebuggerHiding__Active&#10;     52 DebuggerException__ConsoleCtrl&#10;     10 Check_Dlls&#10;      5 DebuggerCheck__RemoteAPI&#10;      2 DebuggerCheck__GlobalFlags&#10;      1 &#9618;&#9618;DebuggerPattern__RDTSC&#10;      1 Debuggeattern__SEH_Inits&#10;      1 Check_VBox_VideoDrivers&#10;      1 Check_VBox_Description</span><br></pre></td></tr></table></figure>
<p>マルウェアの開発者がよりgenericな手法を好むことは，<code>RDTSC</code>命令を用いる検体が61.15%, <code>CPUID</code>命令を用いる検体が57.02%含まれていることからも明らかだ．たった2バイトを基準に検出しているため，false positiveだらけなのだろうとはいえ．<br>一方でvmdetectとして計上された検体は全体の1.18%に過ぎない．これはVMware, Virtual PC, Xen, Virtual Boxに関する文字列が含まれる検体を抽出するルールであり，コードは以下のようになっている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule vmdetect&#10;&#123;&#10;    meta:&#10;        author = &#34;nex&#34;&#10;        description = &#34;Possibly employs anti-virtualization techniques&#34;&#10;&#10;    strings:&#10;        // Binary tricks&#10;        $vmware = &#123;56 4D 58 68&#125;&#10;        $virtualpc = &#123;0F 3F 07 0B&#125;&#10;        $ssexy = &#123;66 0F 70 ?? ?? 66 0F DB ?? ?? ?? ?? ?? 66 0F DB ?? ?? ?? ?? ?? 66 0F EF&#125;&#10;        $vmcheckdll = &#123;45 C7 00 01&#125;&#10;        $redpill = &#123;0F 01 0D 00 00 00 00 C3&#125;&#10;&#10;        // Random strings&#10;        $vmware1 = &#34;VMXh&#34;&#10;        $vmware2 = &#34;Ven_VMware_&#34; nocase&#10;        $vmware3 = &#34;Prod_VMware_Virtual_&#34; nocase&#10;        $vmware4 = &#34;hgfs.sys&#34; nocase&#10;        $vmware5 = &#34;mhgfs.sys&#34; nocase&#10;        $vmware6 = &#34;prleth.sys&#34; nocase&#10;        $vmware7 = &#34;prlfs.sys&#34; nocase&#10;        $vmware8 = &#34;prlmouse.sys&#34; nocase&#10;        $vmware9 = &#34;prlvideo.sys&#34; nocase&#10;        $vmware10 = &#34;prl_pv32.sys&#34; nocase&#10;        $vmware11 = &#34;vpc-s3.sys&#34; nocase&#10;        $vmware12 = &#34;vmsrvc.sys&#34; nocase&#10;        $vmware13 = &#34;vmx86.sys&#34; nocase&#10;        $vmware14 = &#34;vmnet.sys&#34; nocase&#10;        $vmware15 = &#34;vmicheartbeat&#34; nocase&#10;        $vmware16 = &#34;vmicvss&#34; nocase&#10;        $vmware17 = &#34;vmicshutdown&#34; nocase&#10;        $vmware18 = &#34;vmicexchange&#34; nocase&#10;        $vmware19 = &#34;vmdebug&#34; nocase&#10;        $vmware20 = &#34;vmmouse&#34; nocase&#10;        $vmware21 = &#34;vmtools&#34; nocase&#10;        $vmware22 = &#34;VMMEMCTL&#34; nocase&#10;        $vmware23 = &#34;vmx86&#34; nocase&#10;        $vmware24 = &#34;vmware&#34; nocase&#10;        $virtualpc1 = &#34;vpcbus&#34; nocase&#10;        $virtualpc2 = &#34;vpc-s3&#34; nocase&#10;        $virtualpc3 = &#34;vpcuhub&#34; nocase&#10;        $virtualpc4 = &#34;msvmmouf&#34; nocase&#10;        $xen1 = &#34;xenevtchn&#34; nocase&#10;        $xen2 = &#34;xennet&#34; nocase&#10;        $xen3 = &#34;xennet6&#34; nocase&#10;        $xen4 = &#34;xensvc&#34; nocase&#10;        $xen5 = &#34;xenvdb&#34; nocase&#10;        $xen6 = &#34;XenVMM&#34; nocase&#10;        $virtualbox1 = &#34;VBoxHook.dll&#34; nocase&#10;        $virtualbox2 = &#34;VBoxService&#34; nocase&#10;        $virtualbox3 = &#34;VBoxTray&#34; nocase&#10;        $virtualbox4 = &#34;VBoxMouse&#34; nocase&#10;        $virtualbox5 = &#34;VBoxGuest&#34; nocase&#10;        $virtualbox6 = &#34;VBoxSF&#34; nocase&#10;        $virtualbox7 = &#34;VBoxGuestAdditions&#34; nocase&#10;        $virtualbox8 = &#34;VBOX HARDDISK&#34;  nocase&#10;&#10;        // MAC addresses&#10;        $vmware_mac_1a = &#34;00-05-69&#34;&#10;        $vmware_mac_1b = &#34;00:05:69&#34;&#10;        $vmware_mac_1c = &#34;000569&#34;&#10;        $vmware_mac_2a = &#34;00-50-56&#34;&#10;        $vmware_mac_2b = &#34;00:50:56&#34;&#10;        $vmware_mac_2c = &#34;005056&#34;&#10;        $vmware_mac_3a = &#34;00-0C-29&#34; nocase&#10;        $vmware_mac_3b = &#34;00:0C:29&#34; nocase&#10;        $vmware_mac_3c = &#34;000C29&#34; nocase&#10;        $vmware_mac_4a = &#34;00-1C-14&#34; nocase&#10;        $vmware_mac_4b = &#34;00:1C:14&#34; nocase&#10;        $vmware_mac_4c = &#34;001C14&#34; nocase&#10;        $virtualbox_mac_1a = &#34;08-00-27&#34;&#10;        $virtualbox_mac_1b = &#34;08:00:27&#34;&#10;        $virtualbox_mac_1c = &#34;080027&#34;&#10;&#10;    condition:&#10;        any of them&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>見ての通りQEMUに関する記述が存在しない．<br>そこで，vmdetectに以下の様なコードを追加し，再度スキャンしてみた．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule vmdetect&#10;&#123;&#10;    ~ &#30053; ~&#10;&#10;    strings:&#10;        $QEMU1 = &#34;Bochs&#34; nocase&#10;        $QEMU3 = &#34;QEMU_AUDIO_DRV&#34; nocase&#10;        $QEMU4 = &#34;QEMU VVFAT&#34; nocase&#10;        $QEMU5 = &#34;QEMU ADB Mouse&#34; nocase&#10;        $QEMU6 = &#34;QEMU ADS7846-driven Touchscreen&#34; nocase&#10;        $QEMU7 = &#34;QEMU HARDDISK&#34; nocase&#10;        $QEMU8 = &#34;QEMU CD-ROM&#34; nocase&#10;        $QEMU9 = &#34;QEMU MICRODRIVE&#34; nocase&#10;        $QEMU10 = &#34;QEMU-MEMORY&#34; nocase&#10;        $QEMU11 = &#34;QEMU_BIOS&#34; nocase&#10;        $QEMU12 = &#34;QEMU PS/2 Mouse&#34; nocase&#10;        $QEMU13 = &#34;QEMU Sun Mouse&#34; nocase&#10;        $QEMU14 = &#34;QEMU TSC2102-driven Touchscreen&#34; nocase&#10;        $QEMU15 = &#34;QEMU USB Mouse&#34; nocase&#10;        $QEMU16 = &#34;QEMU USB Tablet&#34; nocase&#10;        $QEMU17 = &#34;QEMU_VERSION&#34; nocase&#10;        $QEMU18 = &#34;QEMU USB Keyboard&#34; nocase&#10;        $QEMU19 = &#34;QEMU USB Hub&#34; nocase&#10;        $QEMU20 = &#34;QEMU USB MSD&#34; nocase&#10;        $QEMU21 = &#34;QEMU PenPartner tablet&#34; nocase&#10;        $QEMU22 = &#34;QEMUware SVGA&#34; nocase&#10;&#10;    condition:&#10;        any of them&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>結果は608検体．QEMUを検出するのは4検体だけという結果になった．<br>自分がマルウェアを開発する立場だったらこうした文字列をそのまま埋め込むことはしないし，このルールは表層的なものでしかなく，例えばQEMUの動的バイナリ変換のスケジューリングに着目したAnti-VMを検出することはできない．<br>とはいえ，おかげで現状を大雑把に把握することはできた．</p>
<h1 id="パッカーの実態">パッカーの実態</h1><p>ついでに，<a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml" target="_blank" rel="external">PEiD</a>を用いてパッカーの利用状況を調べた．<br>UserDBには<a href="https://code.google.com/p/reverse-engineering-scripts/downloads/detail?name=UserDB.TXT" target="_blank" rel="external">Bob / Team PEiD signatures</a>を用いた．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># awk &#39;&#123;&#123;for(i=3;i&#60;NF;i++)printf(&#34;%s &#34;,$i) &#125;print($NF)&#125;&#39; peid.log | sort | uniq -c | sort -r&#10;  21159 Nothing found *&#10;   3065 Nothing found [Overlay] *&#10;   1412 Microsoft Visual Basic 5.0 / 6.0&#10;    916 Microsoft Visual C++ 8.0 DLL Method2&#10;    747 Microsoft Visual C++ 6.0&#10;    685 Microsoft Visual Basic 5.0 - 6.0&#10;    405 Borland Delphi 6.0 - 7.0 [Overlay]&#10;    351 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo&#10;    333 Microsoft Visual C++ 7.0 [Overlay]&#10;    320 UPX 2.93 - 3.00 [LZMA] -&#62; Markus Oberhumer, Laszlo Molnar &#38; John Reiser [Overlay] *&#10;    239 Borland Delphi 6.0 - 7.0&#10;    201 Microsoft Visual C++ 6.0 [Overlay]&#10;    185 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo [Overlay]&#10;    167 Nullsoft PiMP Stub [Nullsoft PiMP SFX] *&#10;     99 Microsoft Visual C++ 6.0 DLL&#10;     83 Microsoft Visual C++ 7.0 [Debug] [Overlay]&#10;     82 Nothing found [Debug] *&#10;     79 UPX 0.89.6 - 1.02 / 1.05 - 2.90 (Delphi) stub -&#62; Markus &#38; Laszlo [Overlay]&#10;     63 Microsoft Visual C++ 7.0&#10;     62 Microsoft Visual C# / Basic .NET&#10;     61 Microsoft Visual Basic 5.0 / 6.0 [Overlay]&#10;     42 Themida 1.8.x.x - 1.9.x.x -&#62; Oreans Technologies&#10;     42 ASPack 2.12 -&#62; Alexey Solodovnikov [Overlay]&#10;     38 ASProtect 1.2x - 1.3x [Registered] -&#62; Alexey Solodovnikov&#10;     32 ASPack 2.12 -&#62; Alexey Solodovnikov&#10;     31 PE Win32 DLL (0 EntryPoint)&#10;     31 Nothing found [RAR SFX] *&#10;     31 Microsoft Visual C++ 6.0 DLL [Overlay]&#10;     28 Borland C++&#10;     26 PECompact 2.x -&#62; Jeremy Collake [Overlay]&#10;     24 Morphine 1.2 - 1.3 -&#62; rootkit&#10;     23 MinGW GCC 3.x [Overlay] *&#10;     22 UPX 0.89.6 - 1.02 / 1.05 - 2.90 (Delphi) stub -&#62; Markus &#38; Laszlo&#10;     22 Microsoft Visual C# / Basic .NET [Overlay]&#10;     19 Nothing found [ZIP SFX] *&#10;     18 PECompact 2.x -&#62; Jeremy Collake&#10;     18 Microsoft Visual C++ 7.0 [Debug]&#10;     15 Borland C++ [Overlay]&#10;     14 Borland Delphi 4.0 - 5.0&#10;     14 ASProtect 1.33 - 2.1 Registered -&#62; Alexey Solodovnikov *&#10;     13 UPX 2.93 - 3.00 [LZMA] -&#62; Markus Oberhumer, Laszlo Molnar &#38; John Reiser *&#10;     13 Microsoft Visual C++ 6.0 [Debug]&#10;     13 Microsoft Visual C++ 5.0&#10;     12 UPX 0.80 - 1.24 DLL -&#62; Markus &#38; Laszlo&#10;     12 BobSoft Mini Delphi -&#62; BoB / BobSoft [Overlay] *&#10;     11 Themida 1.8.x.x -&#62; Oreans Technologies *&#10;     11 Microsoft Visual C++ Private Version 1&#10;     11 Borland Delphi 6.0&#10;     11 Borland Delphi 2.0 [Overlay]&#10;     10 BobSoft Mini Delphi -&#62; BoB / BobSoft *&#10;      9 NsPack 2.9 -&#62; North Star *&#10;      9 Microsoft Visual C++ 5.0 [Debug]&#10;      8 Microsoft Visual C++ 7.1 DLL&#10;      8 Microsoft Visual C++ 7.0 Method2&#10;      7 Xtreme-Protector v1.05 *&#10;      7 Microsoft Visual C++ 8.0 DLL Method2 [Overlay]&#10;      6 Xtreme-Protector v1.05 [Overlay] *&#10;      6 Microsoft Visual C++ 8.0 [Debug] [Debug]&#10;      6 ASProtect 1.2x - 1.3x [Registered] -&#62; Alexey Solodovnikov [Overlay]&#10;      5 nSPack 3.7 -&#62; North Star/Liu Xing Ping&#10;      5 Wise Installer Stub [Overlay] *&#10;      5 WinZip 32-bit SFX 8.x module&#10;      5 Thinstall 2.4x - 2.5x -&#62; Jitit Software [Overlay] *&#10;      5 PureBasic 4.x -&#62; Neil Hodgson *&#10;      5 PE Win32 DLL (0 EntryPoint) [Overlay]&#10;      5 Microsoft Visual C++ 7.1 DLL [Overlay]&#10;      4 tElock 0.98b1 -&#62; tE!&#10;      4 Themida 1.8.x.x - 1.9.x.x -&#62; Oreans Technologies [Overlay]&#10;      4 PureBasic 4.x -&#62; Neil Hodgson [Overlay] *&#10;      4 PC-Guard 5.0 -&#62; Blagoje Ceklic [Overlay]&#10;      4 MoleBox v2.0 *&#10;      4 Microsoft Visual C++ 8.0 [Debug]&#10;      4 Microsoft Visual C++ 5.0 [Overlay]&#10;      4 Borland Delphi 4.0 - 5.0 [Overlay]&#10;      4 Borland C++ 1999 [Overlay]&#10;      4 Borland C++ 1999&#10;      4 Armadillo 3.78 - 4.xx -&#62; Silicon Realms Toolworks&#10;      4 Armadillo 1.xx - 2.xx -&#62; Silicon Realms Toolworks&#10;      4 ASProtect 2.1x SKE -&#62; Alexey Solodovnikov&#10;      3 nSPack 3.7 -&#62; North Star/Liu Xing Ping [Overlay]&#10;      3 Upack 0.39 beta -&#62; Dwing&#10;      3 UPX 0.80 - 1.24 DLL -&#62; Markus &#38; Laszlo [Overlay]&#10;      3 Themida 1.2.0.1 (compressed) -&#62; Oreans Technologies [Overlay]&#10;      3 Themida 1.2.0.1 (compressed) -&#62; Oreans Technologies&#10;      3 NsPack 3.4 -&#62; North Star *&#10;      3 NakedPacker 1.0 - by BigBoote *&#10;      3 MinGW GCC 3.x [ZIP SFX] *&#10;      3 Microsoft Visual C++ [Overlay]&#10;      3 Microsoft Visual C++ 6.0 SPx Method 1&#10;      3 Microsoft Visual Basic 5.0 - 6.0 [Overlay]&#10;      3 Inno Setup Module Heuristic Mode [Overlay]&#10;      3 ASProtect 2.1x SKE -&#62; Alexey Solodovnikov [Overlay]&#10;      2 tElock 0.90 -&#62; tE! [Overlay]&#10;      2 Upack 0.28 - 0.399 (relocated image base) - Delphi, .NET, DLL -&#62; Dwing&#10;      2 Upack 0.24 - 0.29 beta -&#62; Dwing&#10;      2 UltraProtect 1.x -&#62; RISCO Software Inc. [Overlay]&#10;      2 UltraProtect 1.x -&#62; RISCO Software Inc.&#10;      2 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo [RAR SFX]&#10;      2 SVKP 1.3x -&#62; Pavol Cerven&#10;      2 PureBasic DLL -&#62; Neil Hodgson *&#10;      2 PEtite 2.x [Level 0] -&#62; Ian Luck&#10;      2 PE-Armor V0.7X -&#62; hying *&#10;      2 PC-Guard 5.0 -&#62; Blagoje Ceklic&#10;      2 Nullsoft Install System 2.1x [Nullsoft PiMP SFX]&#10;      2 NsPack 1.4 -&#62; Liuxingping *&#10;      2 NTKrnl Security Suite -&#62; NTKrnl Team&#10;      2 Morphine 1.4 - 2.7 -&#62; Holy_Father &#38; Ratter/29A&#10;      2 MinGW GCC 3.x *&#10;      2 Microsoft Visual C++ Private Version 1 [Overlay]&#10;      2 Microsoft Visual C++ DLL Method 1&#10;      2 Microsoft Visual C++ 7.0 Method2 [Debug] [Overlay]&#10;      2 Microsoft Visual C++ 7.0 DLL Method 3&#10;      2 Microsoft Visual C++&#10;      2 Microsoft Visual Basic 5.0 / 6.0 [Debug]&#10;      2 MASM32 / TASM32&#10;      2 EXECryptor 2.2.4 -&#62; Strongbit/SoftComplete Development (h1) *&#10;      2 EXECryptor 1.x.x -&#62; SoftComplete Developement&#10;      2 Borland Delphi DLL&#10;      2 Borland Delphi 6.0 [Overlay]&#10;      2 Borland Delphi 3.0&#10;      2 Borland C++ DLL Method 2 [Overlay]&#10;      1 yoda&#39;s Protector 1.3 -&#62; Ashkbiz Danehkar&#10;      1 yoda&#39;s Protector 1.03.3 -&#62; Ashkbiz Danehkar&#10;      1 yoda&#39;s Protector 1.03.2 -&#62; Ashkbiz Danehkar&#10;      1 tElock v0.90 [Overlay] *&#10;      1 tElock v0.90 *&#10;      1 tElock 1.0 (private) -&#62; tE!&#10;      1 tElock 0.61 -&#62; tE!&#10;      1 nSpack V2.3 -&#62; LiuXingPing *&#10;      1 eXPressor 1.3.0 -&#62; CGSoftLabs&#10;      1 Winkript 1.0 -&#62; Mr. Crimson/WKT&#10;      1 WinRAR 32-bit SFX Module [RAR SFX] *&#10;      1 WWPack32 1.x -&#62; Piotr Warezak&#10;      1 Upack 0.28 - 0.399 (relocated image base) - Delphi, .NET, DLL -&#62; Dwing [Overlay]&#10;      1 Upack 0.24 - 0.29 beta -&#62; Dwing [Overlay]&#10;      1 UPX 1.03 - 1.04 -&#62; Markus &#38; Laszlo [Overlay]&#10;      1 UPX 1.03 - 1.04 -&#62; Markus &#38; Laszlo&#10;      1 UPX 0.89.6 - 1.02 / 1.05 - 2.90 -&#62; Markus &#38; Laszlo [Nullsoft PiMP SFX]&#10;      1 Themida 1.8.x.x -&#62; Oreans Technologies [Overlay] *&#10;      1 Themida -&#62; Oreans Technologies 2004 *&#10;      1 SafeDisc 2.05.030 -&#62; Macrovision [Overlay]&#10;      1 RLPack V1.11 -&#62; ap0x [Overlay] *&#10;      1 RLPack 1.20 Basic Edition [aPLib] -&#62; Ap0x *&#10;      1 RCryptor v1.6d --&#62; Vaska *&#10;      1 Pelles C 3.00, 4.00, 4.50 EXE (X86 CRT-LIB) [Overlay]&#10;      1 PKLITE32 v1.1 *&#10;      1 PEtite 2.x [Level 1/9] -&#62; Ian Luck [Overlay]&#10;      1 PEtite 2.x [Level 1/9] -&#62; Ian Luck&#10;      1 PEncrypt 4.0 Gamma / 4.0 Phi -&#62; junkcode&#10;      1 PESpin 0.3x - 1.xx -&#62; cyberbob&#10;      1 PECompact 2.xx --&#62; BitSum Technologies [Overlay] *&#10;      1 PECompact 2.xx --&#62; BitSum Technologies *&#10;      1 PECompact 1.40 - 1.45 -&#62; Jeremy Collake [Overlay]&#10;      1 PEBundle 2.0x - 2.4x-&#62; Jeremy Collake&#10;      1 PEBundle 0.2 - 3.x -&#62; Jeremy Collake&#10;      1 PE Pack 1.0 -&#62; ANAKiN [Overlay]&#10;      1 PE Pack 1.0 -&#62; ANAKiN&#10;      1 PE Crypt 1.02 -&#62; random, killa &#38; acpizer&#10;      1 Obsidium 1.3.0.4 -&#62; Obsidium Software [Overlay]&#10;      1 Nullsoft PiMP stub [Nullsoft PiMP SFX]&#10;      1 Nullsoft Install System 2.x [Nullsoft PiMP SFX]&#10;      1 NsPack 2.9 -&#62; North Star [Overlay] *&#10;      1 Nothing found [CAB SFX] *&#10;      1 NSPack 3.x -&#62; Liu Xing Ping *&#10;      1 Morphine 1.4 - 2.7 -&#62; Holy_Father &#38; Ratter/29A [Overlay]&#10;      1 MoleBox v2.0 [Overlay] *&#10;      1 Microsoft Visual C++ 8.0 [Debug] [Overlay]&#10;      1 Microsoft Visual C++ 7.0 Method2 [Overlay]&#10;      1 Microsoft Visual C++ 7.0 DLL Method 3 [Overlay]&#10;      1 Microsoft Visual C++ 6.0 [ZIP SFX]&#10;      1 Microsoft Visual C++ 6.0 SPx Method 1 [Overlay]&#10;      1 Microsoft Visual C++ 6.0 DLL [Debug]&#10;      1 Microsoft Visual C++ 4.x [Overlay]&#10;      1 Microsoft Visual C++ 4.x [Debug]&#10;      1 Microsoft Visual Basic 6.0 DLL [Overlay]&#10;      1 Microsoft CAB SFX module&#10;      1 LCC Win32 1.x -&#62; Jacob Navia&#10;      1 KByS V0.28 -&#62; shoooo [Overlay] *&#10;      1 KByS V0.22 -&#62; shoooo *&#10;      1 InstallShield AFW [Overlay]&#10;      1 Install Stub 32-bit -&#62; InstallShield [Overlay]&#10;      1 Inno Installer 4.0.5 [Inno SFX]&#10;      1 FSG 2.0 -&#62; bart/xt&#10;      1 EZIP 1.0 -&#62; Jonathan Clark [Overlay]&#10;      1 EXECryptor 1.x.x -&#62; SoftComplete Developement [Overlay]&#10;      1 CD-Cops II -&#62; Link Data Security [Overlay]&#10;      1 Borland Delphi DLL [Overlay]&#10;      1 Borland Delphi 5.0 KOL/MCK [Overlay]&#10;      1 Borland Delphi 5.0 KOL [Overlay]&#10;      1 Borland Delphi 3.0 [Overlay]&#10;      1 Borland Delphi 2.0 [Inno SFX]&#10;      1 Borland Delphi 2.0&#10;      1 Borland Component&#10;      1 Armadillo v1.71 [Overlay] *&#10;      1 Armadillo 3.78 - 4.xx -&#62; Silicon Realms Toolworks [Overlay]&#10;      1 Armadillo 2.01 -&#62; Silicon Realms Toolworks [Overlay]&#10;      1 ASProtect SKE 2.1x (exe) -&#62; Alexey Solodovnikov [Overlay] *&#10;      1 ASProtect 2.0x Registered -&#62; Alexey Solodovnikov [Overlay]&#10;      1 ASProtect 2.0x Registered -&#62; Alexey Solodovnikov&#10;      1 ASProtect 1.33 - 2.1 Registered -&#62; Alexey Solodovnikov [Overlay] *&#10;      1 ASProtect 1.2 / 1.2c-&#62; Alexey Solodovnikov&#10;      1 ASPack 2.12b -&#62; Alexey Solodovnikov&#10;      1 ASPack 1.08.03 -&#62; Alexey Solodovnikov [Overlay]&#10;      1 ASPack 1.06b / 1.061b -&#62; Alexey Solodovnikov [Overlay]&#10;      1 AHTeam EP Protector 0.3 (fake Microsoft Visual C++ 7.0) -&#62; FEUERRADER *&#10;      1 ACProtect V2.0 -&#62; risco *&#10;      1 ACProtect 2.00 - RISCO Software Inc. [Overlay]&#10;      1 ACProtect 1.40 - 1.41 - RISCO Software Inc.&#10;      1 .BJFNT 1.1b -&#62; :MARQUiS:&#10;      1 * PseudoSigner 0.2 [Microsoft Visual Basic 5.0 - 6.0] --&#62; Anorganix [Overlay] *&#10;      1 * PseudoSigner 0.2 [Microsoft Visual Basic 5.0 - 6.0] --&#62; Anorganix *</span><br></pre></td></tr></table></figure>
<p>ほとんど検出できていないのが残念．ひときわ面倒なThemidaは11検体だった．</p>
<h1 id="サンドボックスの実態">サンドボックスの実態</h1><p>サンドボックスの透明性が研究されている一方で，実際のマルウェアはあまり凝ったAnti-VMを備えていなかった．<br>一方で，現実のサンドボックスはどうだろうか．いくら論文で優れた手法が編み出されようが，役立てられていなければ意味がない．<br>そこで，一般に公開されているサンドボックスに対してシステム情報を取得するプログラムを挿入し，仮想マシンモニタの種類を判別できるかどうか試してみたのだが，実態はあまりにもお粗末だった．<br>詳細は言うまい．<br>だが，systeminfoコマンドとNtQuerySystemInformationだけで露見する代物ばかりだった．<br>マルウェアの解析ではなく検出を目的としたサービス，言ってしまえばVirusTotalをサンドボックスのフロントエンドとしたことが，この一因として挙げられる．<br>凝ったAnti-VMを備えたマルウェアがあまり多くないことも考えると，現状のサンドボックスで十分だということなのだろうか．</p>
<h1 id="感想">感想</h1><p>研究をしているうちに袋小路に突入してしまい，サンドボックスの透明性やAnti Anti-VMあくまでマルウェア解析の一側面に過ぎないことを私は忘れかけていた．<br>本質は別のところにある．</p>
<h1 id="TEQUILABOOMBOOM">TEQUILABOOMBOOM</h1><p>公開されているサンドボックスの中にTEQUILABOOMBOOMというホスト名のものがあった．<br><a href="http://www.virusradar.com/en/Win32 Kasidet.AA/description" target="_blank" rel="external">Trojan.Win32.Inject.uljv</a>や<a href="http://securitykitten.github.io/vm-checking-and-detecting/" target="_blank" rel="external">Backdoor.Win32.Agent.dkbp</a>など一部のマルウェアは，このホスト名に基づいてサンドボックスを検出することが知られている．調べてみると，<a href="http://webcache.googleusercontent.com/search?q=cache:hackforums.net/printthread.php?tid=3733605" target="_blank" rel="external">Question about keylogged PC - Printable Version</a>や<a href="http://webcache.googleusercontent.com/search?q=cache:wrb-hdtEFFkJ:www.hackforums.net/showthread.php%3Ftid%3D4522377%26page%3D16+&amp;cd=9&amp;hl=ja&amp;ct=clnk&amp;gl=jp" target="_blank" rel="external">[FUD][FREE] Agent Tesla [Keylogger] [ClipboardLogger] [On-Screen Keyboard Logger] - Page 16</a>など，2013年の時点で情報が攻撃者の間で共有されている．</p>
<blockquote>
<p>So I managed to crypt a keylogger and have my victim download it through dropbox (I think). I haven’t received any logs yet but it shows that I’m connected to a computer from france which is janettedoe@TEQUILABOOMBOOM. I’m not sure how this is possible, or if it’s some sort of error. Does anybody know what this is? My keylogger hasn’t been sent anywhere other than to my targets email. </p>
</blockquote>
<p>どうやらこれはGoogleが動かしているCuckoo Sandboxが用いるホスト名らしく，攻撃者によるサンドボックスの実態調査が進んでいることを伺わせる．<br>サンドボックスの透明性について拘りすぎる必要はないにせよ，その情報が攻撃者の手に渡ることを前提としたサービスについては検討の余地がある．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Gabriel Negreira Barbosa, Rodrigo Rubira Branco,<br>“<a href="https://www.blackhat.com/docs/us-14/materials/us-14-Branco-Prevalent-Characteristics-In-Modern-Malware.pdf" target="_blank" rel="external">Prevalent Characteristics in Modern Malware[PDF]</a>,”<br>Black Hat USA 2014.</li>
<li>Gábor Pék, Levente Buttyán, Boldizsár Bencsáth,<br>“<a href="http://www.profsandhu.com/cs6393_s14/csur_hw_virt_2013.pdf" target="_blank" rel="external">A Survey of Security Issues in Hardware Virtualization[PDF]</a>,”<br>ACM Computing Surveys, vol. 45, issue. 3, 2013.</li>
<li>“VirusShare.com,” <a href="http://virusshare.com/" target="_blank" rel="external">http://virusshare.com/</a></li>
<li><a href="http://intelreport.mandiant.com/Mandiant_APT1_Report.pdf" target="_blank" rel="external">http://intelreport.mandiant.com/Mandiant_APT1_Report.pdf[PDF]</a></li>
<li>“YARA - The pattern matching swiss knife for malware researchers,” <a href="http://plusvic.github.io/yara/" target="_blank" rel="external">http://plusvic.github.io/yara/</a></li>
<li>“PEiD Download - Softpedia,” <a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml" target="_blank" rel="external">http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml</a></li>
<li>“Win32/Kasidet.AA | ESET Virusradar,” <a href="http://www.virusradar.com/en/Win32 Kasidet.AA/description" target="_blank" rel="external">http://www.virusradar.com/en/Win32 Kasidet.AA/description</a></li>
<li>“VM Checking and Detecting Adventures in Security,” <a href="http://securitykitten.github.io/vm-checking-and-detecting/" target="_blank" rel="external">http://securitykitten.github.io/vm-checking-and-detecting/</a></li>
<li>“Question about keylogged PC - Printable Version,” <a href="http://webcache.googleusercontent.com/search?q=cache:hackforums.net/printthread.php?tid=3733605" target="_blank" rel="external">http://webcache.googleusercontent.com/search?q=cache:hackforums.net/printthread.php?tid=3733605</a></li>
<li>“[FUD][FREE] Agent Tesla [Keylogger] [ClipboardLogger] [On-Screen Keyboard Logger] - Page 16],” <a href="http://webcache.googleusercontent.com/search?q=cache:wrb-hdtEFFkJ:www.hackforums.net/showthread.php%3Ftid%3D4522377%26page%3D16+&amp;cd=9&amp;hl=ja&amp;ct=clnk&amp;gl=jp" target="_blank" rel="external">http://webcache.googleusercontent.com/search?q=cache:wrb-hdtEFFkJ:www.hackforums.net/showthread.php%3Ftid%3D4522377%26page%3D16+&amp;cd=9&amp;hl=ja&amp;ct=clnk&amp;gl=jp</a></li>
<li>Katsunari Yoshioka, Yoshihiko Hosobuchi, Tatsunori Orii, Tsutomu Matsumoto,<br>“<a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=5598065&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5598065" target="_blank" rel="external">Vulnerability in Public Malware Sandbox Analysis Systems</a>,”<br>IEEE/IPSJ 12th International Symposium on Applications and the Internet, pp. 265-268, 2010.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="耐解析機能の分類">耐解析機能の分類</h1><p><a href="https://twitter.com/gabrielnb" target="_blank" rel="external">Gabriel N. Barbosa</a>と<a href="htt]]>
    </summary>
    
      <category term="virtual machine introspection" scheme="http://ntddk.github.io/tags/virtual-machine-introspection/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[__attribute__((constructor))が呼ばれる前に]]></title>
    <link href="http://ntddk.github.io/2015/02/24/before-c-constructor/"/>
    <id>http://ntddk.github.io/2015/02/24/before-c-constructor/</id>
    <published>2015-02-24T13:46:08.000Z</published>
    <updated>2015-09-15T08:44:08.251Z</updated>
    <content type="html"><![CDATA[<h1 id="__attribute__((constructor))"><code>__attribute__((constructor))</code></h1><p><code>main()</code>が呼ばれる前に関数を呼ぶ方法として，一般にgcc拡張である<code>__attribute__((constructor))</code>が利用されている．<br>例えば次のコードでは，<code>main()</code>の前に<code>constructor()</code>が呼び出される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdio.h&#62;&#10;&#10;__attribute__((constructor)) void constructor()&#123;&#10;  printf(&#34;constructor\n&#34;);&#10;&#125;&#10;&#10;int main()&#123;&#10;  printf(&#34;main\n&#34;);&#10;  return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="__libc_start_main()"><code>__libc_start_main()</code></h1><p>gccが内部で呼び出すldは，glibcの初期化を行うためにcrt*.oを静的リンクする．これによって，<code>_start()</code>などのシンボルがバイナリに埋め込まれることになる．<br>ここで埋め込まれるシンボルには未定義なものが存在する．その一つとして，crt1.oに含まれる<code>__libc_start_main()</code>が挙げられる．<br>これは<code>main()</code>より先んじて呼び出される関数であり，暗黙的にcrt1.oがリンクの対象となる．しかし未定義であるがゆえに，先にソースコードに<code>__libc_start_main()</code>が宣言されていた場合，ldはこちらをシンボルとして採用してしまう．</p>
<h1 id="どちらが先か">どちらが先か</h1><p>上記を踏まえて，次のコードではどちらの関数が先に呼び出されるだろうか．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdio.h&#62;&#10;&#10;__attribute__((constructor)) void constructor()&#123;&#10;  printf(&#34;constructor\n&#34;);&#10;&#125;&#10;&#10;int __libc_start_main()&#123;&#10;  printf(&#34;__libc_start_main\n&#34;);&#10;  return 0;&#10;&#125;&#10;&#10;int main()&#123;&#10;  printf(&#34;main\n&#34;);&#10;  return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>正解は<code>__libc_start_main()</code>だ．私は実行するまで分からなかった．</p>
<h1 id="__do_global_ctors_aux()"><code>__do_global_ctors_aux()</code></h1><p>なぜ<code>__libc_start_main()</code>が<code>__attribute__((constructor))</code>よりも先に呼び出されるのか．それは<code>__attribute__((constructor))</code>が，<code>__do_global_ctors_aux()</code>によって実現されているからだ．<br><code>__do_global_ctors_aux()</code>は<code>_start()</code>, <code>__libc_start_main()</code>, <code>__libc_csu_init()</code>, <code>_init()</code>を通ってようやく呼び出される．そのため，<code>__libc_start_main()</code>の方がより先んじて呼び出されるのだ．</p>
<h1 id="__libc_csu_init()"><code>__libc_csu_init()</code></h1><p>Sigreturn-oriented Programmingでにわかに脚光を浴びている<code>__libc_csu_init()</code>は<code>__libc_start_main()</code>の引数にセットされるコンストラクタだが，シンボルを上書きして<code>__libc_start_main()</code>の代わりにこちらを<code>main()</code>ないし<code>__attribute__((constructor))</code>の先に呼び出すこともできる．<br>当初私は<code>__attribute__((constructor))</code>はこの辺りから呼び出されるものだと誤解していた．</p>
<h1 id="Windowsでは">Windowsでは</h1><p>今回は触れないが，<code>.CRT$X??</code>のセクションや<code>Thread Local Storage</code>のコールバックによって同様の機能を実現できる．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>高林哲, 鵜飼文敏, 佐藤祐介, 浜地慎一郎, 首藤 一幸,<br>“Binary Hacks - ハッカー秘伝のテクニック100選,”<br>オライリー・ジャパン, 2006.</li>
<li>“Linux x86 Program Start Up,”<br><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html" target="_blank" rel="external">http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="__attribute__((constructor))"><code>__attribute__((constructor))</code></h1><p><code>main()</code>が呼ばれる前に関数を呼ぶ方法として，一般にgcc拡張である<code]]>
    </summary>
    
      <category term="exploiting" scheme="http://ntddk.github.io/tags/exploiting/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[XenとLibVMI]]></title>
    <link href="http://ntddk.github.io/2015/01/31/xen-libvmi/"/>
    <id>http://ntddk.github.io/2015/01/31/xen-libvmi/</id>
    <published>2015-01-31T14:39:37.000Z</published>
    <updated>2016-07-08T08:54:20.485Z</updated>
    <content type="html"><![CDATA[<h1 id="はじめに">はじめに</h1><p><a href="https://github.com/libvmi/libvmi" target="_blank" rel="external">LibVMI</a>はXenならびにKVMを対象としたVMIライブラリである．ここでは，その基盤と応用についてまとめる．</p>
<h1 id="libxc">libxc</h1><p>そもそもXenにおけるVMIの研究ではかねてより，各ドメインの制御機能ないしハイパーコールを提供するlibxcというライブラリが用いられてきた．libxcという名称はthe Xen Control libraryの略称であり，Xenによって公式に提供されている(<code>tools/libxc/</code>)．なお，libxcとして提供されている関数は<code>xc_</code>というprefixを備えている．<br>このうち，VMIと密接に関連があるのは<code>xenctrl.h</code>と<code>xenguest.h</code>である．なかでも<code>xenctrl.h</code>はlibxenctrlとも呼ばれ，PFNの参照やハイパーコールの追加などの機能が提供されている．<br>LibVMIのソースコードにgrepを掛けると，libxcに由来する構造体と関数が多く用いられていることが分かる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% grep -rhoe &#34;xc_[a-zA-z]*_[a-zA-z]*&#34; . | grep -v &#34;]&#34; | sort | uniq&#10;xc_domain_debug_control&#10;xc_domain_decrease_reservation_exact&#10;xc_domain_getinfo&#10;xc_domain_getinfolist&#10;xc_domain_hvm_getcontext&#10;xc_domain_hvm_getcontext_partial&#10;xc_domain_hvm_setcontext&#10;xc_domain_maximum_gpfn&#10;xc_domain_pause&#10;xc_domain_populate_physmap_exact&#10;xc_domain_set_access_required&#10;xc_domain_unpause&#10;xc_domaininfo_t&#10;xc_dominfo_t&#10;xc_evtchn_bind_interdomain&#10;xc_evtchn_close&#10;xc_evtchn_fd&#10;xc_evtchn_notify&#10;xc_evtchn_open&#10;xc_evtchn_pending&#10;xc_evtchn_t&#10;xc_evtchn_unbind&#10;xc_evtchn_unmask&#10;xc_get_hvm_param&#10;xc_hvm_get_mem_access&#10;xc_hvm_inject_trap&#10;xc_hvm_set_mem_access&#10;xc_interface_close&#10;xc_interface_open&#10;xc_map_foreign_batch&#10;xc_map_foreign_range&#10;xc_mem_access_disable&#10;xc_mem_access_enable&#10;xc_mem_access_resume&#10;xc_mem_event_disable&#10;xc_mem_event_enable&#10;xc_memory_op&#10;xc_set_hvm_param&#10;xc_set_mem_access&#10;xc_vcpu_getcontext&#10;xc_vcpu_setcontext</span><br></pre></td></tr></table></figure>
<p>とりわけVMIにおいて重要なのは<code>xc_map_foreign_range()</code>という関数である．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *xc_map_foreign_ranges(xc_interface *xch, uint32_t dom,&#10;                            size_t size, int prot, size_t chunksize,&#10;                            privcmd_mmap_entry_t entries[], int nentries);</span><br></pre></td></tr></table></figure>
<p>Xenの各ドメインにはドメインや仮想CPUの構造体(<code>xen/include/xen/sched.h</code>)のほか，マシンメモリ（物理メモリ）と擬似物理メモリが割り当てられる．ドメインにおけるページングは，このマシンフレーム番号(MFN)と疑似物理フレーム番号(PFN)とを対応付けるP2Mテーブルによって実現されている．つまり，ドメインの仮想アドレスは擬似物理メモリフレーム番号に対応し，その疑似物理フレーム番号はさらにマシンフレーム番号に対応する．なお，Intel EPTが有効な環境においてはP2MはEPTによって代替される(<code>ept-p2m.c</code>)．<br><code>xc_map_foreign_range()</code>はこうした仕組みに基づき，ページテーブルを辿ってDom0のメモリ空間にDomUのマシンフレームを割り当てる．<br>VMIに求められるデータ構造の解釈はXenにおいて，この関数があることから成り立つものである．また，これによるフォールトインジェクションに関してもかつて研究が行われていたようだ．</p>
<h1 id="libxenstore">libxenstore</h1><p>Xenではxenstore-lsやxenstore-readなどのコマンドからxenstoredというデーモンを経由して各ドメインの情報を読み出すことができる．この仕組みをXenStoreといい，関連してlibxenstoreというライブラリが提供されている．(<code>tools/xenstore/</code>)．libxsと呼ばれることもある．<br>XenStoreは名の通りKVSとしてドメインのUUIDやドメイン名，メモリのコミット状況などを格納している．<br>LibVMIにおいても，xenstordへのアクセスのため用いられている(<code>xen_private.h</code>)．</p>
<h1 id="libxenlight">libxenlight</h1><p>libxenlightはlibxcとlibxenstoreのラッパとして公式に開発されているライブラリである(<code>tools/libxl/</code>)．<br>LibVMIでは用いられていないものの，Xen Projectの本流ではこちらが推進されているように見受けられる．</p>
<h1 id="XenAccess">XenAccess</h1><p><a href="https://code.google.com/p/xenaccess/" target="_blank" rel="external">XenAccess</a>はlibxcのラッパであり，LibVMIの前身にあたる．<br>目的としてセマンティックギャップの解決が掲げられており，任意のPIDに対応するEPROCESS構造体を取得することができる．<br>EPROCESS構造体はWindowsの各プロセスに割り当てられる構造体であり，Windowsのプロセスリストはこの構造体のActiveProcessLinksメンバからなる双方向リンクリストによって成り立っている．タスクマネージャが参照するのはこの構造体である．<br>XenAccessはこの構造体を手掛かりにカーネルのベースアドレスを取得する．<br>まず，メモリ空間をPEヘッダの先頭すなわちMZという文字列で検索する．そして，発見したアドレスについてシステムプロセス固有のPsInitialSystemProcessのオフセットを加算し，EPROCESS構造体の先頭メンバである_EPROCESS.Pcb.headerにあたるシグネチャと比較する．一致した場合，発見したアドレスがベースアドレスということになる(<code>windows_memory.c</code>, <code>windows_core.c</code>, <code>windows_process.c</code>)．<br>これによって，プロセスリストと任意のプロセスの情報を取得することができるようになった．</p>
<h1 id="LibVMI">LibVMI</h1><p>LibVMIはXenAccessの後継であり，かつてvmitoolsとも呼ばれていた．<br>先述したようなカーネル空間の解析機能をLibVMIはフォレンジックツールに委譲した．フォレンジックツールを導入するメリットとして，より詳細な構造体の解析を低い実装コストで実現できるという点が挙げられる．<br>さて，LibVMIは<a href="https://github.com/volatilityfoundation/volatility" target="_blank" rel="external">Volatility</a>と<a href="https://github.com/google/rekall" target="_blank" rel="external">Rekall</a>という二種類のフォレンジックツールに対応している．RekallはGoogleによるVolatilityの拡張であり，かつてはLibVMIのサポート外だったものの，<a href="https://github.com/libvmi/libvmi/commit/a4f065a31b986562dc39c9a10d9dff080792f3f4" target="_blank" rel="external">commit a4f065a31b986562dc39c9a10d9dff080792f3f4</a>にて導入された．<br>では，両者の差異はどこにあるのか．</p>
<h1 id="Kernel_Debugger_Block">Kernel Debugger Block</h1><p>XenAccessが行っていたようなEPROCESS構造体のスキャンについて考えてみよう．<br>VolatilityとRekallはいずれも，まずリンクリストの先頭であるPsActiveProcessHeadを特定しようとする．<br>x86において，このPsActiveProcessHeadは，KPCR(Kernel Processor Control Region)構造体のKdVersionBlockメンバが示すKDDEBUGGER_DATA32構造体から取得することができる．<br>このKPCR構造体だが，x86ではFSレジスタ，x86_64ではGSレジスタが先頭アドレスを保持しており，Windows XPでは0xFFDFF000というマジックナンバーを用いて検索することができる．<br>では，KdVersionBlockはどうか．なんと，Windows 7の64-bit版からこのメンバは空になってしまっている．ゆえに，x86_64ではKDDEBUGGER_DATA64構造体をKdVersionBlockに頼らず検索する必要が生ずる．<br>ここで，VolatilityはKDDEBUGGER_DATA64構造体のヘッダに存在するKDBGシグネチャをスキャンするのに対し(<code>kdbgscan.py</code>)，Rekallはカーネルのバージョンに対応したプロファイル情報を用いて構造体にアクセスする．</p>
<h1 id="DRAKVUF">DRAKVUF</h1><p><a href="https://github.com/tklengyel/drakvuf" target="_blank" rel="external">DRAKVUF</a>はTamas K Lengyelによって開発されたサンドボックスであり，論文のオーサーにはXenAccessとLibVMIの開発者であるBryan D. Payneも名を連ねている．<br>LibVMIにRekallのサポートを追加したのがほかでもないTamas K Lengyelその人である．<br>Volatilityは前述の通りメモリからKDBG構造体を検索する．だが，ゲストOSのメモリはマルウェアによって改竄されてしまうおそれがあることに加え，Windows 8の64-bit版ではKDBG構造体が難読化されているという問題点がある．<br>一方で，Rekallのプロファイルはゲストから不可視であり，改竄の影響を受けないため，この問題を解決することができる．<br>DRAKVUFはマルウェア解析を目的としてLibVMIを拡張しており，当然プログラムの実行をトラップする機能を備えている．<br>特筆すべきは，Intel EPTを用いたメモリアクセスの監視である(<code>vmi.c</code>)．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Now we can set the EPT permissions&#10;if (!container-&#62;guard) &#123;&#10;    container-&#62;guard = g_malloc0(sizeof(vmi_event_t));&#10;    SETUP_MEM_EVENT(container-&#62;guard, container-&#62;pa, VMI_MEMEVENT_PAGE,&#10;            VMI_MEMACCESS_RW, trap_guard);&#10;    if (VMI_FAILURE == vmi_register_event(vmi, container-&#62;guard)) &#123;&#10;        printf(&#34;*** FAILED TO REGISTER MEMORY GUARD @ PAGE %lu ***\n&#34;,&#10;                pa &#62;&#62; 12);&#10;        free(container-&#62;guard);&#10;        free(container);&#10;        continue;&#10;    &#125;&#10;    container-&#62;guard-&#62;data = g_hash_table_new(g_int64_hash,&#10;            g_int64_equal);&#10;    printf(&#34;\t\tNew memory event trap set on page %lu\n&#34;, pa &#62;&#62; 12);&#10;&#125; else &#123;&#10;    printf(&#34;\t\tMemory event trap already set on page %lu\n&#34;, pa &#62;&#62; 12);&#10;&#125;&#10;&#10;struct memevent *test = g_hash_table_lookup(container-&#62;guard-&#62;data,&#10;        &#38;container-&#62;pa);&#10;if (!test) &#123;&#10;    g_hash_table_insert(container-&#62;guard-&#62;data, &#38;container-&#62;pa,&#10;            container);&#10;&#125; else if (test-&#62;sID == SYMBOLWRAP) &#123;&#10;    printf(&#34;Address is already guarded\n&#34;);&#10;&#125; else &#123;&#10;    printf(&#34;Address is trapped by another feature! ERROR/TODO!\n&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>このアイデア自体はKVMをベースとして開発されたCXPInspectorを下敷きにしている．<br>かつては任意のアドレスについてNX bitを設定し，ページフォルトハンドラをブレークポイントとする手法が一般的であった．これがカーネル空間から可視であるのに対し，EPTは不可視であるためよりカーネルルートキットの解析に適している．</p>
<h1 id="おわりに">おわりに</h1><p>LibVMIの登場と洗練によってもはや，セマンティックギャップは過去の問題になりつつある．XenにおけるVMIにおいて，これを用いない手はないだろう．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>“Where to start with Xen? - Stack Overflow,”<br><a href="http://stackoverflow.com/questions/11575299/where-to-start-with-xen" target="_blank" rel="external">http://stackoverflow.com/questions/11575299/where-to-start-with-xen</a></li>
<li>Linux Technical Sales, IBM Japan,<br>“Xen ハイパーバイザー準仮想化モードの内部構造入門,”<br><a href="http://www-06.ibm.com/jp/linux/tech/doc/attachments/00393cd9_xen_pv_internal_v1_0.pdf" target="_blank" rel="external">http://www-06.ibm.com/jp/linux/tech/doc/attachments/00393cd9_xen_pv_internal_v1_0.pdf[PDF]</a></li>
<li>Kenichi Kourai and Shigeru Chiba,<br>“<a href="http://dl.acm.org/citation.cfm?id=1065006&amp;dl=ACM&amp;coll=DL&amp;CFID=595394357&amp;CFTOKEN=42837423" target="_blank" rel="external">HyperSpector: Virtual Distributed Monitoring Environments for Secure Intrusion Detection</a>,”<br>Proceedings of the 1st ACM/USENIX International Conference on Virtual Execution Environments, pp. 197-207, NY, USA, 2005.</li>
<li>新井 昇鎬, 千葉 滋,<br>“<a href="http://www.csg.ci.i.u-tokyo.ac.jp/paper/tadokoro-master2009.pdf" target="_blank" rel="external">複数OSに対応した仮想マシン間プロセススケジューリング[PDF]</a>,”<br>学士論文, 東京工業大学, 2009.</li>
<li>安積 武志, 千葉 滋,<br>“<a href="http://www.csg.ci.i.u-tokyo.ac.jp/paper/azumi-master2011.pdf" target="_blank" rel="external">踏み台攻撃だけを抑制できるVMMレベルパケット・フィルタ[PDF]</a>,”<br>修士論文, 東京工業大学, 2011.</li>
<li>Bryan D. Payne, Martim D. P. de A. Carbone, and Wenke Lee,<br>“<a href="http://www.acsac.org/2007/papers/138.pdf" target="_blank" rel="external">Secure and Flexible Monitoring of Virtual Machines[PDF]</a>“,<br>Proceedings of the 23rd Annual Computer Security Applications Conference, pp. 385-397, Miami Beach, FL, 2007.</li>
<li>Bryan D. Payne,<br>“<a href="http://prod.sandia.gov/techlib/access-control.cgi/2012/127818.pdf" target="_blank" rel="external">Simplifying Virtual Machine Introspection Using LibVMI[PDF]</a>,”<br>SANDIA REPORT, 2012.</li>
<li>“Do we need the Kernel Debugging Block? - Rekall Memory Forensic Flamework,”<br><a href="http://www.rekall-forensic.com/posts/2014-02-21-do-we-need-kdbg.html" target="_blank" rel="external">http://www.rekall-forensic.com/posts/2014-02-21-do-we-need-kdbg.html</a></li>
<li>Amit Vasudevan, Ramesh Yerraballi,<br>“<a href="https://www.acsac.org/2005/papers/72.pdf" target="_blank" rel="external">Stealth Breakpoints[PDF]</a>,”<br>Proceedings of the 21st Annual Computer Security Applications Conference, pp. 381-392, AZ, USA, 2005.</li>
<li>Carsten Willems, Ralf Hund, and Thorsten Holz,<br>“<a href="https://www.hgi.rub.de/media/emma/veroeffentlichungen/2012/11/26/TR-HGI-2012-002.pdf" target="_blank" rel="external">CXPInspector: Hypervisor-Based, Hardware-Assisted System Monitoring[PDF]</a>,”<br>Technical Report TR-HGI-2012-002, Ruhr-Uni­ver­si­tät Bo­chum, Horst Görtz Institut für IT-Sicherheit(HGI), 2012.</li>
<li>Tamas K. Lengyel, Steve Maresca, Bryan D. Payne, George D. Webster, Sebastian Vogl, and Aggelos Kiayias,<br>“<a href="https://www.sec.in.tum.de/assets/Uploads/scalability-fidelity-stealth.pdf" target="_blank" rel="external">Scalability, Fidelity and Stealth in the DRAKVUF Dynamic Malware Analysis System[PDF]</a>,”<br>Proceedings of the 30th Annual Computer Security Applications Conference, pp. 386-395, NY, USA, 2014.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="はじめに">はじめに</h1><p><a href="https://github.com/libvmi/libvmi" target="_blank" rel="external">LibVMI</a>はXenならびにKVMを対象としたVMIライブラリである．こ]]>
    </summary>
    
      <category term="virtual machine introspection" scheme="http://ntddk.github.io/tags/virtual-machine-introspection/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[サンドボックスの透明性]]></title>
    <link href="http://ntddk.github.io/2015/01/23/sandbox-transparency/"/>
    <id>http://ntddk.github.io/2015/01/23/sandbox-transparency/</id>
    <published>2015-01-23T14:45:59.000Z</published>
    <updated>2016-07-08T08:53:22.736Z</updated>
    <content type="html"><![CDATA[<h1 id="VMI">VMI</h1><p>仮想マシンモニタからゲストのリソースを監視・制御する技術をVMI(Virtual Machine Introspection)という．<br>その発祥は2003年に遡る．当時はハニーポットの研究が盛んな時期であり，VMIは仮想マシンにおける侵入検知を実現する手法として提案された．これはマルウェア解析の自動化に応用されており，仮想マシンモニタによるサンドボックスを構築し，VMIによってマルウェアの挙動を監視するというアプローチが一般的となっている．<br>さて，VMIにおける問題点にセマンティックギャップというものがある．原義は高級言語とハードウェアとの乖離であるが，OSと同じ粒度で情報を取得することのできるゲスト内部(in-the-box)とハードウェアの粒度で情報を取得することしかできないゲスト外部(out-of-the-box)の乖離という意味でも援用される．</p>
<h1 id="Transparent_Sandbox">Transparent Sandbox</h1><p>セマンティックギャップを解決する方法として，ゲスト内部にエージェントを挿入し，仮想マシンモニタに情報を送信するというアプローチが考えられる．<br>だがマルウェア解析において，ゲスト内部にエージェントを挿入することは，自らの姿を曝け出していることにほかならない．ファイルやサービス名，フックによって変化するAPIの挙動といったものは，マルウェアがエージェントと同じ権限で動作する限り避けられない．そもそも仮想マシンモニタは特権を有していたところで<code>RDTSC</code>や<code>ICEBP</code>などの命令，あるいはハードウェア名やIDTといった要素から検出される可能性を孕んでいる．そのため，ゲスト内部にエージェントを挿入することは，仮想マシンモニタがマルウェアから検出される可能性を高めることに繋がる．フォレンジックにおける完全性(integrity)のためにも，ゲスト内部にエージェントを挿入すべきではないと私は考える．<br>この議論に関して，マルウェアから検出されない仮想マシンモニタをtransparent sandbox（透明なサンドボックス？）といい，仮想マシンモニタの検出を試みるマルウェアをevasive malwareという．<br>ではどのような仮想マシンモニタがより「透明」に近いのか．</p>
<h1 id="仮想マシンモニタの歴史">仮想マシンモニタの歴史</h1><p>ここでPopekとGoldbergの仮想化要件に立ち返ると，ベアメタルな仮想マシンモニタは等価性(equivalence)，資源管理(resource control)，効率性(efficiency)の三原則を実現しており，なおかつユーザセンシティブ命令が特権命令でなければならない．センシティブ命令かつ特権命令でなければ，例外によって仮想マシンモニタに通知することができないためである．<br>だが，以前のx86アーキテクチャはこの要件を満たしていなかった．そこで，ニ種類の解決方法が編み出された．<br>一つ目はバイナリ変換(binary translation)による完全仮想化である．これはソフトウェアで命令をエミュレートする手法で，QEMUやVMwareが該当する．QEMUは全ての命令を中間コードに変換するのに対し，VMwareはPopekとGoldbergの仮想化要件を満たさない命令をライブラリ呼び出しに変換する．<br>二つ目は準仮想化である．これはPopekとGoldbergの仮想化要件を満たさない命令に差し掛かると仮想マシンモニタに通知されるようゲストOSのカーネルを修正する手法で，Xenが該当する．<br>ではバイナリ変換による完全仮想化とカーネル書き換えによる準仮想化のどちらがより「透明」に近いのか．<br>その前にIntel VT-xについて考えなければならない．Intel VT-xはCPUのモード切り替えによってセンシティブ命令かつ特権命令でない命令のトラップを実現する拡張機能である．すなわちPopekとGoldbergの仮想化要件を満たすハードウェア側からのアプローチである．これにより準仮想化カーネルの必要はなくなった．エージェントの挿入が「透明」性に関わるのと同様，カーネルの書き換えは仮想マシンモニタを検出する手掛かりとなる．<br>そのためマルウェア解析においては，バイナリ変換による完全仮想化か，Intel VT-xによる完全仮想化が前提となる．なおKVMはIntel Vt-xを前提としているが，部分的にQEMUを用いている．<br>ではどちらの手法がより「透明」に近いのか．</p>
<h1 id="バイナリ変換とIntel_VT-x">バイナリ変換とIntel VT-x</h1><p>Christopher KruegelはWineのようなシステムコール単位のエミュレーションあるいはフックは情報量として不十分であり，またIntel VT-xによる完全仮想化はRedPillのようなアプローチで検出可能であることから，バイナリ変換による完全仮想化すなわちQEMUを支持している．<br>システムコール単位の監視は<code>IsDebuggerPresent</code>のようなカーネルモードに遷移せず構造体を参照するだけの処理を見逃してしまう．システムコールのフックを用いた研究や製品は多数存在するが，それらは不完全である．この点で私は氏と意見を一にするが，バイナリ変換がより「透明」に近いかどうかは検討の余地があるだろう．寧ろ氏は実行パスの拡張がより容易に行えるがゆえにバイナリ変換を支持しているのだろうということは読み取れるが，氏がチーフサイエンティストを務めるLastlineの製品がQEMUをベースとしていることもあり，些かポジショントークのようにも感じられる．<br>このような論調でバイナリ変換とIntel VT-xを二項対立の図式に落とし込んでいる論文が数多く見られる．しかし，どちらがより「透明」に近いのかという議論はナンセンスであろう．<br>ゲスト内部にエージェントを挿入することで，果たして本当にマルウェアから検出されやすくなるのかと言うと，それは飽くまで可能性でしかない．だがゲスト内部にエージェントを挿入しないという選択で，その問題は検討項目から外すことができる．一方で，バイナリ変換であるという理由でIntel VT-xを用いた仮想マシンモニタよりも検出されにくいといったことはない．逆もまた然りである．<br>そしてそもそも，ネットワーク経由で仮想マシンモニタを検出するという手法がある以上，完全に「透明」なサンドボックスは実現不可能であるとされる．<br>ゆえにそれぞれのアプローチについて「透明」性の他にもメリット・デメリットを検討し，なおかつ両者を接合するようなシステムこそが望ましい．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Tal Garfinkel, Mendel Rosenblu,<br>“<a href="http://suif.stanford.edu/papers/vmi-ndss03.pdf" target="_blank" rel="external">A Virtual Machine Introspection Based Architecture for Intrusion Detection[PDF]</a>,”<br>Proceedings of the 10th Annual Network and Distributed System Security Symposium, pp. 191–206, SD, USA, 2003.</li>
<li>Gerald J. Popek, Robert P. Goldberg,<br>“<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.141.4815&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Formal Requirements for Virtualizable Third Generation Architectures[PDF]</a>,”<br>Communications of the ACM CACM Homepage archive, Vol. 17, Issue. 7, pp. 412-421, NY, USA, 1974.</li>
<li>John Scott Robin, Cynthia E. Irvine,<br>“<a href="http://www.cse.psu.edu/~bhuvan/teaching/spring06/papers/analysis-pentium.pdf" target="_blank" rel="external">Analysis of the Intel Pentium’s Ability to Support a Secure Virtual Machine Monitor[PDF]</a>,”<br>Proceedings of the 9th conference on USENIX Security Symposium, Vol. 9, pp. 10-10, CA, USA, 2000.</li>
<li>Christopher Kruegel,<br>“<a href="https://www.blackhat.com/docs/us-14/materials/us-14-Kruegel-Full-System-Emulation-Achieving-Successful-Automated-Dynamic-Analysis-Of-Evasive-Malware-WP.pdf" target="_blank" rel="external">Full System Emulation: Achieving Successful Automated Dynamic Analysis of Evasive Malware[PDF]</a>,”<br>Black Hat USA, 2014.</li>
<li>Tal Garfinkel, Keith Adams, Andrew Warfield and Jason Franklin,<br>“<a href="http://www.cs.cmu.edu/~jfrankli/hotos07/vmm_detection_hotos07.pdf" target="_blank" rel="external">Compatibility is Not Transparency: VMM Detection Myths and Realities[PDF]</a>,”<br>Proceedings of the 11th USENIX workshop on Hot topics in operating systems, No. 6, CA, USA, 2007.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="VMI">VMI</h1><p>仮想マシンモニタからゲストのリソースを監視・制御する技術をVMI(Virtual Machine Introspection)という．<br>その発祥は2003年に遡る．当時はハニーポットの研究が盛んな時期であり，VMIは仮想マシン]]>
    </summary>
    
      <category term="dynamic binary translation" scheme="http://ntddk.github.io/tags/dynamic-binary-translation/"/>
    
      <category term="virtual machine introspection" scheme="http://ntddk.github.io/tags/virtual-machine-introspection/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Intel PinにおけるNXの扱い]]></title>
    <link href="http://ntddk.github.io/2014/12/11/pintool-nx/"/>
    <id>http://ntddk.github.io/2014/12/11/pintool-nx/</id>
    <published>2014-12-11T09:00:00.000Z</published>
    <updated>2014-12-11T15:43:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="はじめに">はじめに</h1><p>2014.12.07~08にわたって開催されたSECCON CTF 2014の予選（英語版）にて，ROP: Impossibleというpwn問題が出題された．タイトルの通り，この問題ではROPが制限されている．<br>ここでは，その実現手法として用いられていたIntel Pin(pintool)について，またこの問題にあった欠陥について述べる．<br>したがって，このエントリはROP: Impossibleの<strong>ネタバレ</strong>を兼ねている．注意されたし．</p>
<h1 id="問題の概要">問題の概要</h1><p>問題文は以下の通り．Pinによって保護された脆弱なバイナリからフラグを読み出せというものだ．</p>
<blockquote>
<p>ropi.pwn.seccon.jp:10000<br>read <code>/flag</code> and write the content to stdout, such as the following pseudo code.<br><code>open(&quot;/flag&quot;, 0);</code><br><code>read(3, buf, 32);</code><br><code>write(1, buf, 32);</code><br>Notice that the <code>vuln</code> executable is protected by an Intel Pin tool, the source code of which is <code>norop.cpp</code>.</p>
</blockquote>
<p>パッと見，バイナリは良心的な構成であるように思われる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.6.26, BuildID[sha1]=0xcb671b1dc0409082c3f3962818d366fcb8771ead, not stripped</span><br></pre></td></tr></table></figure></p>
<p>有効になっているのはNXだけだ．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE&#10;No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   vuln</span><br></pre></td></tr></table></figure></p>
<p>だからといって，解法が自明であるわけではない．この問題の肝は，いかにしてPinによる保護をかい潜るかにある．</p>
<h1 id="Pin">Pin</h1><p>Pinは，Intelによって開発されたDBI(dynamic binary instrumentation)フレームワークである．<br>DBIとは，プログラムにコードを挿入することで実行時の情報を取得・操作する技術であり，プログラムのパフォーマンス測定やエラー検出，CPUキャッシュの分析や未定義命令のエミュレーションなど，多方面で応用されている．<br>さて，ROP: Impossibleは以下のコードによって保護されている．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdlib.h&#62;&#10;#include &#34;pin.H&#34;&#10;&#10;ADDRINT&#9;shadow_stack[4096];&#10;int&#9;&#9;shadow_sp = -1;&#10;&#10;VOID push_retaddr(ADDRINT esp, ADDRINT eip)&#10;&#123;&#10;&#9;if(shadow_sp &#62;= (int)sizeof(shadow_stack) - 1)&#123;&#10;&#9;&#9;// cannot push retaddr to shadow stack&#10;&#9;&#9;exit(-1);&#10;&#9;&#125;&#10;&#9;PIN_SafeCopy(&#38;shadow_stack[++shadow_sp], (VOID*)esp, sizeof(ADDRINT));&#10;&#125;&#10;&#10;VOID pop_retaddr(ADDRINT esp, ADDRINT eip)&#10;&#123;&#10;&#9;ADDRINT&#9;&#9;retaddr;&#10;&#10;&#9;PIN_SafeCopy(&#38;retaddr, (VOID*)esp, sizeof(ADDRINT));&#10;&#10;&#9;while(shadow_sp &#62;= 0 &#38;&#38; shadow_stack[shadow_sp--] != retaddr);&#10;&#9;if(shadow_sp &#60; 0)&#123;&#10;&#9;&#9;exit(-1);&#10;&#9;&#125;&#10;&#125;&#10;&#10;VOID check_syscall(ADDRINT eax)&#10;&#123;&#10;&#9;switch(eax)&#123;&#10;&#9;// syscalls for exploit&#10;&#9;case 3:&#9;&#9;// sys_read&#10;&#9;case 4:&#9;&#9;// sys_write&#10;&#9;case 5:&#9;&#9;// sys_open&#10;&#9;case 6:&#9;&#9;// sys_close&#10;&#10;&#9;// syscalls executed until entry point&#10;&#9;case 45:&#9;// sys_brk&#10;&#9;case 122:&#9;// sys_newuname&#10;&#9;case 192:&#9;// sys_mmap2&#10;&#9;case 197:&#9;// sys_fstatfs64&#10;&#9;case 243:&#9;// sys_set_thread_area&#10;&#9;&#9;break;&#10;&#10;&#9;// invalid syscalls&#10;&#9;default:&#10;&#9;&#9;exit(-1);&#10;&#9;&#125;&#10;&#125;&#10;&#10;VOID insert_hooks(INS ins, VOID *val)&#10;&#123;&#10;&#9;if(INS_IsCall(ins))&#123;&#10;&#9;&#9;// push retaddr to shadow stack&#10;&#9;&#9;if(XED_ICLASS_CALL_FAR == INS_Opcode(ins))&#123;&#10;&#9;&#9;&#9;exit(-1);&#10;&#9;&#9;&#125;&#10;&#9;&#9;INS_InsertCall(ins, IPOINT_TAKEN_BRANCH,(AFUNPTR)push_retaddr,&#10;&#9;&#9;&#9;IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);&#10;&#9;&#125;else if(INS_IsRet(ins))&#123;&#10;&#9;&#9;// pop retaddr from shadow stack, and then check it&#10;&#9;&#9;if(XED_ICLASS_RET_FAR == INS_Opcode(ins))&#123;&#10;&#9;&#9;&#9;exit(-1);&#10;&#9;&#9;&#125;else&#123;&#10;&#9;&#9;&#9;INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)pop_retaddr,&#10;&#9;&#9;&#9;&#9;IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);&#10;&#9;&#9;&#125;&#10;&#9;&#125;else if(INS_IsSyscall(ins))&#123;&#10;&#9;&#9;// check syscall&#10;&#9;&#9;INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)check_syscall,&#10;&#9;&#9;&#9;IARG_REG_VALUE, REG_EAX, IARG_END);&#10;&#9;&#125;&#10;&#125;&#10;&#10;int main(int argc, char *argv[])&#10;&#123;&#10;&#9;PIN_Init(argc, argv);&#10;&#9;INS_AddInstrumentFunction(insert_hooks, NULL);&#10;    PIN_StartProgram();&#10;    &#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>このプログラムが，vulnの共有ライブラリとして噛まされている．<code>INS_*</code>は命令単位のinstumentationのために提供されているPinのAPIである．<br>要するに，リターンアドレスの検証によって，ROPが制限されているのだ．</p>
<h1 id="JOP">JOP</h1><p>ROPができない環境ならば，どうすればよいのか．<br>そもそも，ROPに用いられる<code>ret</code>は，スタックの最上位アドレスに対する<code>pop</code>と<code>jmp</code>と等価であると見做せる．ゆえに<code>jmp</code>によってchainを構築すれば，<code>ret</code>を用いること無くROPと同様なコードを作成することができる．これをJOP(Jump-oriented programming)という．<br>さらに，スタックに対するアドレスの<code>push</code>と<code>jmp</code>は，<code>call</code>と等価であると見做せる．ゆえに<code>call</code>と<code>pop</code>によってROPを代替することができる．<br>つまり，ROP: Impossibleは<code>ret</code>制限下の環境を前提に<code>jmp</code>と<code>call</code>でchainを構築しろというストイックな問題だった．<br>Pinに起因する欠陥がなければ．</p>
<h1 id="writeup">writeup</h1><p>この問題を最初に解いたのは，TOEFL BEGINNERという謎のチームだった．続いてbinja, PPPと続いている．<br>優勝チームであるPPPメンバーのRicky Zhouが公開しているwriteupを見てみよう．</p>
<ul>
<li><a href="https://rzhou.org/~ricky/seccon2014/rop_impossible/" target="_blank" rel="external">Index of /~ricky/seccon2014/rop_impossible/</a></li>
</ul>
<p>明らかにおかしい．bssセグメントにシェルコードを置いて実行しているだけではないか．<br>だが，このバイナリはNXが有効だったはずだ．ローカルでこのコードを実行しても，SIGSEGVが発生する．<br>これは一体どうしたことだろう．</p>
<h1 id="JITコンパイルの弊害">JITコンパイルの弊害</h1><p>結論から言うと，Pinの制御下にあるバイナリのNXは無効化されるようになっている．<br>/proc/pid/mapsを確認すると，一見nonexecであるように見える．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bf984000-bf9a5000 rw-p 00000000 00:00 0          [stack]</span><br></pre></td></tr></table></figure></p>
<p>だが，実際はそうではない．<br>PinはJITコンパイルによってinstrumentationを実現している．そのため，バイナリはPinによってmmapされ，execされる．このとき，Pinは元来バイナリに付与されていた実行権限を無視してしまう．<br>つまり，ROPを制限するためのPinが，NXを無効化してしまっていたのだ．<br>そもそも，LinuxにおいてNXの状態をmaps以外から取得するのは難しい．強いて挙げるならば，checksecのように<code>readelf -W -l file | grep &#39;GNU_STACK&#39;</code>を叩くといったところだろうか．だが，これだけではmmapやmprotectに追随することができない．WindowsのVirtualQueryに相当する機能はないのだろうか．</p>
<h1 id="おわりに">おわりに</h1><p>XSS Bonsaiも同様だが，CTFについてもテストは重要であるということを気付かされた．<br>運営の穴を突くのもCTFの醍醐味のひとつなのだろうが，しかし厄介な問題である．<br>最近はPinやDynamoRioによるマルウェア解析が流行っているように見受けられるが，やがてはDBIツールのデメリットについても検討を加えなければならなくなるだろう．</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="はじめに">はじめに</h1><p>2014.12.07~08にわたって開催されたSECCON CTF 2014の予選（英語版）にて，ROP: Impossibleというpwn問題が出題された．タイトルの通り，この問題ではROPが制限されている．<br>ここでは，]]>
    </summary>
    
      <category term="exploiting" scheme="http://ntddk.github.io/tags/exploiting/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[マルウェア解析におけるRecord and Replayの設計]]></title>
    <link href="http://ntddk.github.io/2014/12/09/v2e/"/>
    <id>http://ntddk.github.io/2014/12/09/v2e/</id>
    <published>2014-12-09T09:00:00.000Z</published>
    <updated>2016-07-08T08:53:38.543Z</updated>
    <content type="html"><![CDATA[<h1 id="はじめに">はじめに</h1><p>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>“という論文を通して，Record and Replayを用いた解析環境の設計を学ぶ．</p>
<h1 id="著者">著者</h1><p>この論文のラストオーサーであるYinはSyracuse Universityの助教である．彼はテイント解析の第一人者として知られ，現在は<a href="https://code.google.com/p/decaf-platform/" target="_blank" rel="external">DECAF</a>の開発を主導している．またBitBlaze ProjectのDawn Songや，マルウェア解析の大御所であるChristopher Kruegelと過去に共著を出している．<br>ファーストオーサーのYanは提案手法をAndroidに適用し，2013年に博士論文を著している．Android向けの拡張にあたっては，DECAFのサブプロジェクトであるDroidScopeを用いているようだ．</p>
<h1 id="Record_and_Replay">Record and Replay</h1><p>あるいはLogging and Replay, Lockstep, 順序再演法，最小情報トレースなどと呼ばれるこれらは，仮想マシンモニタ上のイベントを記録し，再生するための技術である．乱暴に言うとhistoryからdockerfileやvagrantfileを作成し，deployするようなものだ．<br>一般にステートマシンにおける命令の出力は，内部状態から一意に与えられる．そこで，ある環境の初期状態と入力のみを記録(Record)し，同じ環境を別の環境の上に再生(Raplay)するといった試みがなされてきた．実マシンにおいては，時刻や割り込みなどの非決定性とその記録の困難性からRecord and Replayは不可能であるとされる．だが，仮想マシンモニタの世界ではこれらの問題をある程度無視できる．実際，VMware Workstationなどにこの機能は実装されている．<br>本論文では，マルウェア解析に求められるサンドボックスの特性を加味したRecord and Replayについて論じられている．かつて大居さん(<a href="https://twitter.com/a4lg" target="_blank" rel="external">@a4lg</a>)が研究されていた内容に近い．</p>
<h1 id="背景">背景</h1><p>マルウェアを解析するためのサンドボックスは検出不可能(transparent)であり，なおかつ拡張可能であるべきだ．<br>いかに仮想マシンモニタの存在を隠蔽しようと，Timing Attackなどが成り立つ以上，transparentなサンドボックスを実現することは不可能である．しかし，Intel VTなどハードウェア仮想化技術を用いることで，ほぼtransparentな環境を作り出すことは可能である．例えば，<a href="http://ether.gtisc.gatech.edu/" target="_blank" rel="external">Ether</a>は命令・システムコール単位の解析機能を備えているが，Xenをベースに高いtransparent性を実現している．<br>だが，ハードウェア仮想化技術に依存した解析環境には拡張性の点で問題がある．特に，instrumentationによる詳細な解析が不可能であるという点は，大きな痛手である．<br>他方，QEMUなどのソフトウェアエミュレーションは動的バイナリ変換を用いることでDBI(dynamic binary instrumentation)と解析効率の向上を実現している．しかし，transparentなサンドボックスには至れない．<br>QEMUの動的バイナリ変換はバイナリをコードブロック単位で変換し，softmmuからTLBを参照してアドレス変換を行うというものだ．<br>そしてその性質から，以下のような自己書き換えコードによって検出されうる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm&#123;&#10;&#9;xor eax, eax&#10;&#9;mov edi, target&#10;&#9;mov esi, copy_insn&#10;&#9;mov ecx, 3&#10;&#10;target:&#10;&#9;rep movsw&#9;&#9;// f3 66 a5&#10;&#9;jmp qemu_found&#9;&#9;// eb XX&#10;&#9;nop&#9;&#9;&#9;// 90&#10;&#10;non_qemu:&#10;&#9;...&#10;&#10;qemu_found:&#10;&#9;...&#10;&#10;copy_insn:&#10;&#9;_emit 0xeb&#9;&#9;// eb&#10;&#9;_emit 0x01&#9;&#9;// 01&#10;&#9;_emit 0x90&#9;&#9;// 90&#10;&#9;_emit 0xeb&#10;&#9;_emit 0x01&#10;&#9;_emit 0x90&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>実マシンでは，<code>ecx*word=6</code>バイトが1回で書き換わるが，QEMUの動的バイナリ変換では2バイトずつ3回で書き換わる．そのため，1回目の書き換えで<code>0xeb 0x01 0xa5</code>すなわち<code>jmp +01</code>になってしまい，<code>qemu_found</code>にジャンプしてしまう．<br>その他には，ページ境界を越えてブロックの変換が行われた場合にページフォルトが発生してしまうことも考えられるし，ブロック境界でのみ割り込みが行われる，CPUサイクルの消費が著しいといった実マシンとの相違点もある．<br>さらに問題なのが，フラグの遅延評価だ．例えば，<code>cmp</code>と<code>jz</code>の組み合わせなどの条件分岐は，EFLAGSを更新する．だが，QEMUにおいては<code>cmp</code>が実行される段階でEFLAGSの計算は行われない．実際に計算されるのは<code>jz</code>の実行時，それも分岐を決定するためのZFのみが計算される．この設計はエミュレーションの高速化に寄与しているが，もちろん検出に用いることが可能だ．<br>当然ながら命令のエミュレーション自体にも限界がある．SIMDさえ厳しいのだ，システム管理モードやIntel TXTなんてものは考えたくないだろう．<br>このように，QEMUによるエミュレーションが検出される余地は枚挙に暇がない．<br>なお，解析環境検出をテーマとした最近の研究では，第2回システム系論文輪読会で<a href="http://ntddk.github.io/barecloud/">紹介した</a>BareCloudや忠鉢さん(<a href="https://twitter.com/yuzuhara" target="_blank" rel="external">@yuzuhara</a>)のTENTACLEなどがある．</p>
<h1 id="研究目的">研究目的</h1><p>ハードウェア仮想化技術を用いる解析環境とソフトウェアエミュレーションを用いる解析環境にはそれぞれ問題がある．そこで，ハードウェア仮想化技術を用いる解析環境でRecordを行い，ソフトウェアエミュレーションを用いる解析環境でReplayを行うことで，検出不可能性と拡張可能性という二つの目的について達成したのが，今回紹介するV2Eである．</p>
<h1 id="形式的定義">形式的定義</h1><p>本論文におけるRecord and Replayの設計はどのようなものか．<br>Recorderにおける遷移関数<code>f</code>について，毎時<sub><code>i</code></sub>におけるプログラムの状態を<code>S</code><sub><code>i</code></sub>とし，入力を<code>I</code><sub><code>i</code></sub>とする．すなわち<code>f</code>は<code>S</code><sub><code>i</code></sub><code>= f(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と表される．<br>次にReplayerにおける遷移関数<code>f&#39;</code>についてプログラムの初期状態を<code>S</code><sub><code>0</code></sub>とし，全ての入力を<code>I</code>としたとき，<code>f = f&#39;</code>と言えないだろうか．<br>これは二つのチューリング機械の同値性が解決可能であるかという問題に相当する．だが<code>EQ</code><sub><code>TM</code></sub><code>= {(M</code><sub><code>1</code></sub><code>, M</code><sub><code>2</code></sub>)<code>|M</code><sub><code>1</code></sub><code>とM</code><sub><code>2</code></sub><code>はTMであり，L(M</code><sub><code>1</code></sub><code>) = L(M</code><sub><code>2</code></sub><code>)}</code>は判定不可能とされ（『計算理論の基礎』における定理5.4），実装上でもハードウェアの割り込みなどの要因から<code>f != f&#39;</code>となってしまう．<br>そこでV2Eは，プログラムの初期状態と全ての入力を保存することに加え，<code>S</code><sub><code>j</code></sub><code>= S&#39;</code><sub><code>j</code></sub>となるような<sub><code>j</code></sub>について状態の変化を保存することにした．これは<code>⊿</code><sub><code>j</code></sub><code>= S</code><sub><code>j</code></sub><code>- S</code><sub><code>j-1</code></sub>と表される．<br>ここで，新たな遷移関数<code>f&#39;</code><sub><code>r</code></sub>を<code>S&#39;</code><sub><code>i</code></sub><code>= f&#39;</code><sub><code>r</code></sub><code>(S&#39;</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>, ⊿</code><sub><code>i</code></sub><code>)</code>として定義する．これは，<code>⊿</code><sub><code>i</code></sub><code>!= null</code>のとき<code>S&#39;</code><sub><code>i-1</code></sub><code>+ ⊿</code><sub><code>i</code></sub>と同値であり，それ以外について<code>f&#39;(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と同値をとる．<br>なお，<code>S</code><sub><code>0</code></sub>, <code>I</code>, <code>⊿</code>および<code>f&#39;</code><sub><code>r</code></sub>, <code>S&#39;</code><sub><code>i</code></sub><code>= S</code><sub><code>i</code></sub>は<code>i ∈ [0, n]</code>について恒真である．<br>これを実装に起こすと，特定の命令やイベントが正しくエミュレート可能な場合は単にそれらをエミュレートし，そうでなければ状態の変化を記録し，Replayにあたって変更を適用するというアプローチになる．</p>
<h1 id="理論と実際">理論と実際</h1><p>プログラムの大部分を占める<code>mov</code>, <code>push</code>, <code>pop</code>などのデータ転送命令，<code>call</code>, <code>ret</code>, <code>jz</code>, <code>jmp</code>などの制御転送命令，<code>add</code>, <code>shl</code>などの整数演算命令におけるエミュレーションは失敗しないものと見做せる．これらはそのままRecorderでエミュレートされる．<br>一方で，割り込み，MMIO, Port IO, DMA, TSCについては，V2Eは既存研究を踏襲し，監視領域においてのみこれらをRecordするようになっている．<br>では，例外，モデル固有レジスタ，<code>cpuid</code>はどうすべきだろうか．既存手法は，これらのエミュレーションは困難であるという理由から，そもそも入力として扱わない戦略を採っていたようだ．V2Eではこれらを<code>⊿</code>, すなわちエミュレートが困難な状態の変化としてRecordすることで，Replayの正確性を高めている．<br>次に問題となるのが浮動小数点演算とSIMDの扱いだ．MMXやSSEを正確にエミュレートするのは難しい．だが，<code>⊿</code>として命令の結果を記録する設計は大幅なパフォーマンスの低下を招く．そこでV2EはReplayにあたってこれらの命令をパススルーする．もちろん，ReplayerはSIMDをサポートしているマシンで実行されることが前提にある．</p>
<h1 id="Transparent_Recorder">Transparent Recorder</h1><p>RecorderはKVMを用いて実装されている．<br>V2EはRecord対象の領域とそれ以外のシステムを分割するため，TDP(two dimensional paging)を用いている．何のことかと思ったら，Intel EPTやAMD NPTの総称らしい．<br><img src="/image/tdp.jpg"><br>要するに，TDPとは仮想マシンと物理マシン間のページテーブルのことだ．通常のページングでは，メモリアクセスに応じてMMUによってページテーブルが参照され，仮想アドレスが物理アドレスへと変換される．TDPでは，ゲストマシンからの仮想メモリ空間へのアクセスに応じてCR3にセットされたページテーブルが参照され，ゲスト物理アドレスがホスト物理アドレスへと変換される．<br>この仕組を用いたV2Eは，<strong>監視対象用のTDPテーブルと，それ以外用のTDPテーブルを別々に作成する</strong>．マルウェアに属するページはCR3の監視に基づき監視対象用のTDPテーブルに書き込まれる．マルウェアとそれ以外の部分のインタラクションはTDPページフォルトや<code>VMExit</code>によって媒介される．共有されるデータは読み取り専用として双方に与えられる．なお，TDPページフォルトに応じてCPUの状態が入力<code>I</code><sub><code>i</code></sub>として保存される．</p>
<h1 id="Precise_Replayer">Precise Replayer</h1><p>ReplayerはTEMUを用いて実装されている．バイナリ変換器に中間表現がなく，単純に古いQEMU 0.9.1をベースとしているのが玉に瑕だが，TEMUは動的テイント解析に求められる機能をほぼ網羅している．<br>TEMUはプラグインを共有ライブラリとしてロードし，コールバック関数からテイント解析の機能を呼び出すプラットフォームとなっている．V2EのReplayerは既存のプラグインであるtracecap, unpackerを用いる．だがRecordされたログには監視対象の情報のみが記述されているため，<br><code>return ((*TEMU_cpu_hflags &amp; HF_CPL_MASK) != 3)</code>といった，現在実行しているコードが解析対象のものかどうか判定するコードは除去されているようだ．TEMUのプラグインについては，こうした僅かな変更しか施されていない．<br>一方でその下で動くQEMUには結構手が加えられている．フラグの遅延評価は廃止され，ページフォルト以外の例外は除去されており，SIMDについては独自のヘルパー関数が追加されたようだ．QEMUのdyngenに手を加えるのはなかなか骨の折れる作業だと思う．<br>さて，Replayを行うためには，ReplayerはRecorderと同様のページングの仕組みをエミュレーションによって再現しなければならない．そこで，V2Eは物理ページコンテナという仕組みを用いている．これは，物理ページがログからロードされていることを示すものである．通常，物理ページコンテナは監視対象用のTDPテーブルを複製する．Replayされたプログラムが物理ページコンテナに存在しないページにアクセスした場合，Replayerは適切なタイミングでログからCPUの状態を復元し，ロードするようになっている．<br>V2Eにおけるテイント解析はおそらく，マルウェアのメモリ領域を正確に把握するためのものではない．それは，Recorderの段階でTDPテーブルの分割というアプローチによって実現されるべきものだからだ．TEMUのプラグインを使いたかったのだろうが，論文中からはあまりテイント解析を導入することのメリットが読み取れなかった．ここでのテイント解析は解析環境検出の対策に先立つものとして設定されているのだろうか．</p>
<h1 id="評価">評価</h1><p>解析環境検出については問題なし．<code>cpuid</code>, <code>rdtsc</code>, <code>cmpxch8b</code>, <code>icbp</code>, <code>rep stosb</code>, <code>fnstcw</code>といった命令や，一般保護例外などについてテストされている．なお，<code>rdtsc</code>については<code>VMRESUME</code>前にホストのTSCを参照することで対応している．<br>in-the-wildのマルウェアについても実験が行われており，アンパッカーとして期待できるパフォーマンスを見せている．<br>Recordにおける速度だが，コンテキストスイッチが頻繁に発生するカーネルモードルートキットで17倍，Internet Explorerで5倍と高速だ．KVMのシングルステップモードには3000倍のオーバーヘッドがあると言うのに．<br>全体的にpositiveな結果で，かなり良い．</p>
<h1 id="おわりに">おわりに</h1><p>マルウェアによる解析環境検出に対して，復数の環境を組み合わせたRecord and Replayを用いる研究について紹介した．何より，監視対象とそれ以外で別個にTDPテーブルを作るというアプローチが素晴らしい．自分も研究でテイント解析を扱っているが，この流れを包摂していきたい．<br>ただ，これはサンドボックス全般に言えることなのだが，感染ホストにおけるユーザーのブラウザ操作が条件分岐に影響するMITBマルウェアについて，どう対処すべきなのだろうか．正常系のユーザーのブラウザ操作をデータセットとしてRecorderに与えたいところだが，果たしてどうなるのか．<br>このエントリは<a href="http://www.adventar.org/calendars/440" target="_blank" rel="external">システム系論文紹介 Advent Calendar 2014</a>の9日目として書かれた．</p>
<h1 id="参考文献">参考文献</h1><ul>
<li>Lok-Kwong Yan, Manjukumar Jayachandra, Mu Zhang and Heng Yin,<br>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>,”<br>Proceedings of the 8th ACM SIGPLAN/SIGOPS conference on Virtual Execution Environments, pp. 227-238, NY, USA, 2012.</li>
<li>George W. Dunlap, Samuel T. King, Sukru Cinar, Murtaza A. Basrai and Peter M. Chen,<br>“<a href="http://web.engr.illinois.edu/~kingst/Research_files/dunlap02.pdf" target="_blank" rel="external">ReVirt: Enabling Intrusion Analysis through Virtual-Machine Logging and Replay[PDF]</a>,”<br>Proceedings of the 2002 Symposium on Operating Systems Design and Implementation, pp. 211-224, NY, USA, 2002.</li>
<li>A. Dinaburg, P. Royal, M. Sharif and W. Lee.<br>“<a href="http://ether.gtisc.gatech.edu/ether_ccs_2008.pdf" target="_blank" rel="external">Ether: malware analysis via hardware virtualization extensions[PDF]</a>,”<br>Proceedings of the 15th ACM Conference on Computer and Communications Security, pp. 51–62, NY, USA, 2008.</li>
<li>大居司,<br>“<a href="http://www.slideshare.net/a4lg/a-new-tracer-for-reverse-engineering" target="_blank" rel="external">リバースエンジニアリングのための新しいトレース手法</a>,”<br>PacSec 2010, 東京, 日本, 2010.</li>
<li>Dhilung Kirat, Giovanni Vigna, and Christopher Kruegel,<br>“<a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kirat.pdf" target="_blank" rel="external">BareCloud: Bare-metal Analysis-based Evasive Malware Detection[PDF]</a>,”<br>Proceedings of the 23rd USENIX conference on Security Symposium, pp. 287-301, CA, USA, 2014.</li>
<li>忠鉢洋輔, 愛甲健二,<br>“<a href="https://pacsec.jp/psj14/PSJ2014_chubachi_final_ja.pdf" target="_blank" rel="external">TENTACLE: Environment-Sensitive Malware Palpation[PDF]</a>,”<br>PacSec Tokyo 2014, 東京, 日本, 2014.</li>
<li>M. Siper,<br>“<a href="http://www.cs.virginia.edu/~robins/Sipser_2006_Second_Edition_Problems.pdf" target="_blank" rel="external">Introduction to the Theory of Computation. International</a>,”<br>Thomson Publishing, 1996.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="はじめに">はじめに</h1><p>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E:]]>
    </summary>
    
      <category term="dynamic binary translation" scheme="http://ntddk.github.io/tags/dynamic-binary-translation/"/>
    
      <category term="symbolic execution" scheme="http://ntddk.github.io/tags/symbolic-execution/"/>
    
      <category term="taint analysis" scheme="http://ntddk.github.io/tags/taint-analysis/"/>
    
      <category term="virtual machine introspection" scheme="http://ntddk.github.io/tags/virtual-machine-introspection/"/>
    
  </entry>
  
</feed>