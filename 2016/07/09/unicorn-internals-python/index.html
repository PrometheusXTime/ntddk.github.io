<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Unicornのソースコードを読む（Python編） | 一生あとで読んでろ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="※Rackサーバの方のUnicornではない．
はじめに　UnicornはQEMUベースの軽量，マルチプラットフォーム・マルチアーキテクチャ・JIT対応のCPUエミュレータ．周辺機器をエミュレーションしないため用途は限られるが，GoやPythonなど複数言語のバインディングを備えている．現在システムセキュリティ分野で最も注目されているOSSのひとつと言っても過言ではなく，AsiaCCS 2016で">
<meta property="og:type" content="article">
<meta property="og:title" content="Unicornのソースコードを読む（Python編）">
<meta property="og:url" content="http://ntddk.github.io/2016/07/09/unicorn-internals-python/index.html">
<meta property="og:site_name" content="一生あとで読んでろ">
<meta property="og:description" content="※Rackサーバの方のUnicornではない．
はじめに　UnicornはQEMUベースの軽量，マルチプラットフォーム・マルチアーキテクチャ・JIT対応のCPUエミュレータ．周辺機器をエミュレーションしないため用途は限られるが，GoやPythonなど複数言語のバインディングを備えている．現在システムセキュリティ分野で最も注目されているOSSのひとつと言っても過言ではなく，AsiaCCS 2016で">
<meta property="og:updated_time" content="2016-07-09T06:28:34.216Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unicornのソースコードを読む（Python編）">
<meta name="twitter:description" content="※Rackサーバの方のUnicornではない．
はじめに　UnicornはQEMUベースの軽量，マルチプラットフォーム・マルチアーキテクチャ・JIT対応のCPUエミュレータ．周辺機器をエミュレーションしないため用途は限られるが，GoやPythonなど複数言語のバインディングを備えている．現在システムセキュリティ分野で最も注目されているOSSのひとつと言っても過言ではなく，AsiaCCS 2016で">
<meta name="twitter:creator" content="@ntddk">
  
    <link rel="alternative" href="/atom.xml" title="一生あとで読んでろ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一生あとで読んでろ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技術ブログ</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-unicorn-internals-python" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Unicornのソースコードを読む（Python編）
    </h1>
  

      </header>
    
    <time class="article-date" datetime="2016-07-09T06:20:00.000Z" itemprop="datePublished">07-09-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>　※Rackサーバの方のUnicornではない．</p>
<h1 id="はじめに">はじめに</h1><p>　<a href="http://www.unicorn-engine.org/" target="_blank" rel="external">Unicorn</a>は<a href="http://www.qemu.org/" target="_blank" rel="external">QEMU</a>ベースの軽量，マルチプラットフォーム・マルチアーキテクチャ・JIT対応のCPUエミュレータ．周辺機器をエミュレーションしないため用途は限られるが，GoやPythonなど<a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings" target="_blank" rel="external">複数言語のバインディング</a>を備えている．現在システムセキュリティ分野で最も注目されているOSSのひとつと言っても過言ではなく，<a href="https://github.com/vrtadmin/ROPMEMU" target="_blank" rel="external">AsiaCCS 2016で発表されたROPチェーン解析ツールROPMEMU</a>や，<a href="https://github.com/oblivia-simplex/roper" target="_blank" rel="external">遺伝的アルゴリズムによってROPチェーンを自動生成するツールroper</a>のバックエンドとして用いられたり，Unicornと同じように注目を集めているバイナリ解析ツール<a href="https://github.com/angr/simuvex/issues/29" target="_blank" rel="external">angrとの連携</a>が進められたりと，一大コミュニティを形成しつつある．<br>　コンセプトの説明は<a href="http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf" target="_blank" rel="external">Black Hat USA 2015の発表スライド</a>に譲るとして，ここではその利用方法と内部実装にふれる．</p>
<h1 id="Pythonバインディング">Pythonバインディング</h1><blockquote>
<p>　情報セキュリティに興味があり，セキュリティ関係の仕事に携わりたいという人には，Pythonはうってつけの言語だ．その理由は，リバースエンジニアリングと攻撃コード作成のためのライブラリが充実しているためだ．<br>　　　　　　　— Justin Seitz『<a href="https://www.oreilly.co.jp/books/9784873117317/" target="_blank" rel="external">サイバーセキュリティプログラミング———Pythonで学ぶハッカーの思考</a>』序文</p>
</blockquote>
<p>　リバースエンジニアリングというタスクにUnicornを用いることを考える．他言語を選ぶ積極的な理由やPythonへのアレルギーがなければ，他のライブラリとの連携も考慮して，Pythonバインディングを活用すべきだろう．</p>
<h1 id="エミュレーション">エミュレーション</h1><p>　最もシンプルな用例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># unicorn/bindings/python/sample_x86.pyを抜粋・改変</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function <span class="comment"># Python 2.7を利用</span></span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># エミュレーション対象の機械語</span></span><br><span class="line">X86_CODE32 = <span class="string">b"\x41\x4a"</span> <span class="comment"># INC ecx; DEC edx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各基本ブロックに対するコールバック</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_block</span><span class="params">(uc, address, size, user_data)</span>:</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt; Tracing basic block at 0x%x, block size = 0x%x"</span> %(address, size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 各命令に対するコールバック</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span><span class="params">(uc, address, size, user_data)</span>:</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = %u"</span> %(address, size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x86 32bitのコードをエミュレーション</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_i386</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Emulate i386 code"</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># x86-32bitモードでエミュレータを初期化</span></span><br><span class="line">        mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># エミュレーション用に2MBのメモリを割り当て</span></span><br><span class="line">        mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 割り当てられたメモリに機械語を書き込み</span></span><br><span class="line">        mu.mem_write(ADDRESS, X86_CODE32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># レジスタ初期化</span></span><br><span class="line">        mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>) <span class="comment"># エミュレーション中に加算される</span></span><br><span class="line">        mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>) <span class="comment"># エミュレーション中に減算される</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 各基本ブロックに対するコールバックを設定</span></span><br><span class="line">        mu.hook_add(UC_HOOK_BLOCK, hook_block)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 各命令に対するコールバックを設定</span></span><br><span class="line">        mu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># エミュレーション開始</span></span><br><span class="line">        mu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># レジスタの表示</span></span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; Emulation done. Below is the CPU context"</span>)</span><br><span class="line"></span><br><span class="line">        r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">        r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; ECX = 0x%x"</span> %r_ecx)</span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; EDX = 0x%x"</span> %r_edx)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># メモリから命令列を読む</span></span><br><span class="line">        tmp = mu.mem_read(ADDRESS, <span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"&gt;&gt;&gt; Read 2 bytes from [0x%x] ="</span> %(ADDRESS), end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">            print(<span class="string">" 0x%x"</span> %i, end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"ERROR: %s"</span> % e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_i386()</span><br></pre></td></tr></table></figure>
<p>　これを実行すると次のような出力が得られる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Emulate i386 code&#10;&#62;&#62;&#62; Tracing basic block at 0x1000000, block size = 0x2&#10;&#62;&#62;&#62; Tracing instruction at 0x1000000, instruction size = 1&#10;&#62;&#62;&#62; Tracing instruction at 0x1000001, instruction size = 1&#10;&#62;&#62;&#62; Emulation done. Below is the CPU context&#10;&#62;&#62;&#62; ECX = 0x1235&#10;&#62;&#62;&#62; EDX = 0x788f&#10;&#62;&#62;&#62; Read 2 bytes from [0x1000000] = 0x41 0x4a</span><br></pre></td></tr></table></figure>
<p>　はい．<br>　なおエミュレーション時に各命令のトレースを得たければ，同じ開発陣による逆アセンブラ<a href="http://www.capstone-engine.org/" target="_blank" rel="external">Capstone</a>のPythonバインディングを併用して（詳細は割愛）次のようなフックを用意すればよい：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleEngine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.capmd = Cs(CS_ARCH_X86, CS_MODE_32) <span class="comment"># アーキテクチャ指定</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disas_single</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.capmd.disasm(data, <span class="number">16</span>): <span class="comment"># 逆アセンブル</span></span><br><span class="line">            print(<span class="string">"\t%s\t%s"</span> % (i.mnemonic, i.op_str))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">disasm = SimpleEngine()</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span><span class="params">(uc, address, size, user_data)</span>:</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = %u, "</span> %(address, size), end=<span class="string">""</span>)</span><br><span class="line">    <span class="comment"># メモリから実行される命令を読む</span></span><br><span class="line">    ins = uc.mem_read(address, size)</span><br><span class="line">    disasm.disas_single(str(ins))</span><br></pre></td></tr></table></figure>
<p>　実行すると命令のトレースが得られる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;&#62;&#62;&#62; Tracing instruction at 0x1000000, instruction size = 1,     inc     ecx&#10;&#62;&#62;&#62; Tracing instruction at 0x1000001, instruction size = 1,     dec     edx&#10;...</span><br></pre></td></tr></table></figure>
<p>　このように，Unicornではプラグイン側のエントリポイントからQEMUの機能を呼び出していくことになる．</p>
<h1 id="Pythonバインディングの内部">Pythonバインディングの内部</h1><p>　この内部では，ctypesによる共有ライブラリのロードが行われている．<code>unicorn/bindings/python/unicorn/unicorn.py</code>を見よう：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _lib <span class="keyword">in</span> _all_libs:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> _lib == <span class="string">"unicorn.dll"</span>:</span><br><span class="line">            <span class="keyword">for</span> dll <span class="keyword">in</span> _all_windows_dlls:    <span class="comment"># load all the rest DLLs first</span></span><br><span class="line">                _lib_file = os.path.join(_lib_path, dll)</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(_lib_file):</span><br><span class="line">                    ctypes.cdll.LoadLibrary(_lib_file)</span><br><span class="line">        _lib_file = os.path.join(_lib_path, _lib)</span><br><span class="line">        _uc = ctypes.cdll.LoadLibrary(_lib_file)</span><br><span class="line">        _found = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>　ここで<code>_uc</code>に<code>unicorn.dll</code>（環境によって異なるがいずれにせよ共有ライブラリ）がロードされている．<br>　さて，これまで利用してきた関数のプロトタイプ宣言は<code>unicorn/bindings/python/unicorn/unicorn.py</code>にある：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup all the function prototype</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_setup_prototype</span><span class="params">(lib, fname, restype, *argtypes)</span>:</span></span><br><span class="line">    getattr(lib, fname).restype = restype</span><br><span class="line">    getattr(lib, fname).argtypes = argtypes</span><br><span class="line"></span><br><span class="line">ucerr = ctypes.c_int</span><br><span class="line">uc_engine = ctypes.c_void_p</span><br><span class="line">uc_hook_h = ctypes.c_size_t</span><br><span class="line"></span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_version"</span>, ctypes.c_uint, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int))</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_arch_supported"</span>, ctypes.c_bool, ctypes.c_int)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_open"</span>, ucerr, ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(uc_engine))</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_close"</span>, ucerr, uc_engine)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_strerror"</span>, ctypes.c_char_p, ucerr)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_errno"</span>, ucerr, uc_engine)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_reg_read"</span>, ucerr, uc_engine, ctypes.c_int, ctypes.c_void_p)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_reg_write"</span>, ucerr, uc_engine, ctypes.c_int, ctypes.c_void_p)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_read"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.POINTER(ctypes.c_char), ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_write"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.POINTER(ctypes.c_char), ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_emu_start"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_uint64, ctypes.c_uint64, ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_emu_stop"</span>, ucerr, uc_engine)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_hook_del"</span>, ucerr, uc_engine, uc_hook_h)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_map"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_uint32)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_map_ptr"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_unmap"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_mem_protect"</span>, ucerr, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_uint32)</span><br><span class="line">_setup_prototype(_uc, <span class="string">"uc_query"</span>, ucerr, uc_engine, ctypes.c_uint32, ctypes.POINTER(ctypes.c_size_t))</span><br><span class="line"></span><br><span class="line"><span class="comment"># uc_hook_add is special due to variable number of arguments</span></span><br><span class="line">_uc.uc_hook_add = _uc.uc_hook_add</span><br><span class="line">_uc.uc_hook_add.restype = ucerr</span><br><span class="line"></span><br><span class="line">UC_HOOK_CODE_CB = ctypes.CFUNCTYPE(<span class="keyword">None</span>, uc_engine, ctypes.c_uint64, ctypes.c_size_t, ctypes.c_void_p)</span><br><span class="line">UC_HOOK_MEM_INVALID_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    ctypes.c_bool, uc_engine, ctypes.c_int,</span><br><span class="line">    ctypes.c_uint64, ctypes.c_int, ctypes.c_int64, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_MEM_ACCESS_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    <span class="keyword">None</span>, uc_engine, ctypes.c_int,</span><br><span class="line">    ctypes.c_uint64, ctypes.c_int, ctypes.c_int64, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INTR_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    <span class="keyword">None</span>, uc_engine, ctypes.c_uint32, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INSN_IN_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    ctypes.c_uint32, uc_engine, ctypes.c_uint32, ctypes.c_int, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INSN_OUT_CB = ctypes.CFUNCTYPE(</span><br><span class="line">    <span class="keyword">None</span>, uc_engine, ctypes.c_uint32,</span><br><span class="line">    ctypes.c_int, ctypes.c_uint32, ctypes.c_void_p</span><br><span class="line">)</span><br><span class="line">UC_HOOK_INSN_SYSCALL_CB = ctypes.CFUNCTYPE(<span class="keyword">None</span>, uc_engine, ctypes.c_void_p)</span><br></pre></td></tr></table></figure>
<p>　メモリ・レジスタを読み書きできることがわかる．<br>　さきほどは基本ブロック・命令単位のコールバック関数———フック———を設置した．その他のフックも次のように書ける：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mu.hook_add(UC_HOOK_BLOCK, hook_block) <span class="comment"># 基本ブロック単位</span></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)   <span class="comment"># 命令単位</span></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code, <span class="keyword">None</span>, ADDRESS, ADDRESS+<span class="number">20</span>) <span class="comment"># 指定範囲[ADDRESS, ADDRESS+20]の全命令</span></span><br><span class="line">mu.hook_add(UC_HOOK_INSN, hook_in, <span class="keyword">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_IN)   <span class="comment"># IN命令</span></span><br><span class="line">mu.hook_add(UC_HOOK_INSN, hook_out, <span class="keyword">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_OUT) <span class="comment"># OUT命令</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_access) <span class="comment"># メモリ書き込み</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ, hook_mem_access)  <span class="comment"># メモリ読み込み</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, hook_mem_access) <span class="comment"># その両方</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED, hook_mem_invalid) <span class="comment"># 無効なメモリアクセス</span></span><br><span class="line">mu.hook_add(UC_HOOK_INSN, hook_syscall, <span class="keyword">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_SYSCALL) <span class="comment"># システムコール</span></span><br><span class="line">mu.hook_add(UC_HOOK_INTR, hook_intr) <span class="comment"># 割り込み</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>　こうしたフックや，これまで用いてきたレジスタやメモリの読み書き・エミュレーションといった機能は<code>Uc</code>クラスのメソッドとして用意されている：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uc</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arch, mode)</span>:</span></span><br><span class="line">        <span class="comment"># verify version compatibility with the core before doing anything</span></span><br><span class="line">        (major, minor, _combined) = uc_version()</span><br><span class="line">        <span class="keyword">if</span> major != uc.UC_API_MAJOR <span class="keyword">or</span> minor != uc.UC_API_MINOR:</span><br><span class="line">            self._uch = <span class="keyword">None</span></span><br><span class="line">            <span class="comment"># our binding version is different from the core's API version</span></span><br><span class="line">            <span class="keyword">raise</span> UcError(uc.UC_ERR_VERSION)</span><br><span class="line"></span><br><span class="line">        self._arch, self._mode = arch, mode</span><br><span class="line">        self._uch = ctypes.c_void_p()</span><br><span class="line">        status = _uc.uc_open(arch, mode, ctypes.byref(self._uch))</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            self._uch = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line">        <span class="comment"># internal mapping table to save callback &amp; userdata</span></span><br><span class="line">        self._callbacks = &#123;&#125;</span><br><span class="line">        self._ctype_cbs = &#123;&#125;</span><br><span class="line">        self._callback_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># emulate from @begin, and stop when reaching address @until</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">emu_start</span><span class="params">(self, begin, until, timeout=<span class="number">0</span>, count=<span class="number">0</span>)</span>:</span></span><br><span class="line">        status = _uc.uc_emu_start(self._uch, begin, until, timeout, count)</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return the value of a register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reg_read</span><span class="params">(self, reg_id)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._arch == uc.UC_ARCH_X86:</span><br><span class="line">            <span class="keyword">if</span> reg_id <span class="keyword">in</span> [x86_const.UC_X86_REG_IDTR, x86_const.UC_X86_REG_GDTR, x86_const.UC_X86_REG_LDTR, x86_const.UC_X86_REG_TR]:</span><br><span class="line">                reg = uc_x86_mmr()</span><br><span class="line">                status = _uc.uc_reg_read(self._uch, reg_id, ctypes.byref(reg))</span><br><span class="line">                <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">                    <span class="keyword">raise</span> UcError(status)</span><br><span class="line">                <span class="keyword">return</span> reg.selector, reg.base, reg.limit, reg.flags</span><br><span class="line">            <span class="keyword">if</span> reg_id <span class="keyword">in</span> range(x86_const.UC_X86_REG_FP0, x86_const.UC_X86_REG_FP0+<span class="number">8</span>):</span><br><span class="line">                reg = uc_x86_float80()</span><br><span class="line">                status = _uc.uc_reg_read(self._uch, reg_id, ctypes.byref(reg))</span><br><span class="line">                <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">                    <span class="keyword">raise</span> UcError(status)</span><br><span class="line">                <span class="keyword">return</span> reg.mantissa, reg.exponent</span><br><span class="line"></span><br><span class="line">        <span class="comment"># read to 64bit number to be safe</span></span><br><span class="line">        reg = ctypes.c_int64(<span class="number">0</span>)</span><br><span class="line">        status = _uc.uc_reg_read(self._uch, reg_id, ctypes.byref(reg))</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line">        <span class="keyword">return</span> reg.value</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read data from memory</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mem_read</span><span class="params">(self, address, size)</span>:</span></span><br><span class="line">        data = ctypes.create_string_buffer(size)</span><br><span class="line">        status = _uc.uc_mem_read(self._uch, address, data, size)</span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line">        <span class="keyword">return</span> bytearray(data)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add a hook</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hook_add</span><span class="params">(self, htype, callback, user_data=None, begin=<span class="number">1</span>, end=<span class="number">0</span>, arg1=<span class="number">0</span>)</span>:</span></span><br><span class="line">        _h2 = uc_hook_h()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># save callback &amp; user_data</span></span><br><span class="line">        self._callback_count += <span class="number">1</span></span><br><span class="line">        self._callbacks[self._callback_count] = (callback, user_data)</span><br><span class="line">        cb = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> htype == uc.UC_HOOK_INSN: <span class="comment"># 特定の命令に応じた内部処理</span></span><br><span class="line">            insn = ctypes.c_int(arg1)</span><br><span class="line">            <span class="keyword">if</span> arg1 == x86_const.UC_X86_INS_IN:  <span class="comment"># IN命令</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_INSN_IN_CB(self._hook_insn_in_cb), UC_HOOK_INSN_IN_CB)</span><br><span class="line">            <span class="keyword">if</span> arg1 == x86_const.UC_X86_INS_OUT:  <span class="comment"># OUT命令</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_INSN_OUT_CB(self._hook_insn_out_cb), UC_HOOK_INSN_OUT_CB)</span><br><span class="line">            <span class="keyword">if</span> arg1 <span class="keyword">in</span> (x86_const.UC_X86_INS_SYSCALL, x86_const.UC_X86_INS_SYSENTER):  <span class="comment"># SYSCALL/SYSENTER命令</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_INSN_SYSCALL_CB(self._hook_insn_syscall_cb), UC_HOOK_INSN_SYSCALL_CB)</span><br><span class="line">            status = _uc.uc_hook_add(</span><br><span class="line">                self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                ctypes.c_uint64(begin), ctypes.c_uint64(end), insn</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> htype == uc.UC_HOOK_INTR: <span class="comment"># 割り込み</span></span><br><span class="line">            cb = ctypes.cast(UC_HOOK_INTR_CB(self._hook_intr_cb), UC_HOOK_INTR_CB)</span><br><span class="line">            status = _uc.uc_hook_add(</span><br><span class="line">                self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> htype <span class="keyword">in</span> (uc.UC_HOOK_BLOCK, uc.UC_HOOK_CODE): <span class="comment"># 基本ブロック・命令単位</span></span><br><span class="line">                <span class="comment"># set callback with wrapper, so it can be called</span></span><br><span class="line">                <span class="comment"># with this object as param</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_CODE_CB(self._hookcode_cb), UC_HOOK_CODE_CB)</span><br><span class="line">                status = _uc.uc_hook_add(</span><br><span class="line">                    self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                    ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                    ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">elif</span> htype &amp; (uc.UC_HOOK_MEM_READ_UNMAPPED |  <span class="comment"># 無効なメモリアクセス</span></span><br><span class="line">                          uc.UC_HOOK_MEM_WRITE_UNMAPPED |</span><br><span class="line">                          uc.UC_HOOK_MEM_FETCH_UNMAPPED |</span><br><span class="line">                          uc.UC_HOOK_MEM_READ_PROT |      <span class="comment"># 保護された領域へのメモリアクセス</span></span><br><span class="line">                          uc.UC_HOOK_MEM_WRITE_PROT |</span><br><span class="line">                          uc.UC_HOOK_MEM_FETCH_PROT):</span><br><span class="line">                cb = ctypes.cast(UC_HOOK_MEM_INVALID_CB(self._hook_mem_invalid_cb), UC_HOOK_MEM_INVALID_CB)</span><br><span class="line">                status = _uc.uc_hook_add(</span><br><span class="line">                    self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                    ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                    ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># メモリ読み書き</span></span><br><span class="line">                cb = ctypes.cast(UC_HOOK_MEM_ACCESS_CB(self._hook_mem_access_cb), UC_HOOK_MEM_ACCESS_CB)</span><br><span class="line">                status = _uc.uc_hook_add(</span><br><span class="line">                    self._uch, ctypes.byref(_h2), htype, cb,</span><br><span class="line">                    ctypes.cast(self._callback_count, ctypes.c_void_p),</span><br><span class="line">                    ctypes.c_uint64(begin), ctypes.c_uint64(end)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># save the ctype function so gc will leave it alone.</span></span><br><span class="line">        self._ctype_cbs[self._callback_count] = cb</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> status != uc.UC_ERR_OK:</span><br><span class="line">            <span class="keyword">raise</span> UcError(status)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _h2.value</span><br></pre></td></tr></table></figure>
<h1 id="おわりに">おわりに</h1><p>　PythonからUnicornを利用する方法を紹介した．<br>　結局のところctypesでラップされており，こうした機能がどのようにして実行されるのかは本体のコードを読まなければ理解できない．そういうわけで，次回はUnicorn本体の実装を読んでいく．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2016/07/09/unicorn-internals-python/" data-id="ciqes9buv0000eooslvarl9la" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/06/29/cyber-security-in-israel/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">イスラエルのサイバーセキュリティ事情</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 ntddk<br>
      <a href="https://github.com/ntddk/hexo-theme-jathena" target="_blank">JAthena</a> by <a href="http://ntddk.github.io" target="_blank">ntddk</a> | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>